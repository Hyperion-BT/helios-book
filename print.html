<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Helios Smart Contract Language</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/custom.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="intro.html">Introduction</a></li><li class="chapter-item affix "><a href="understanding-eutxos.html">Understanding eUTxOs</a></li><li class="chapter-item affix "><a href="changelog.html">Changelog</a></li><li class="chapter-item "><a href="lang/index.html"><strong aria-hidden="true">1.</strong> Helios language</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lang/comments.html"><strong aria-hidden="true">1.1.</strong> Comments</a></li><li class="chapter-item "><a href="lang/variables.html"><strong aria-hidden="true">1.2.</strong> Variables</a></li><li class="chapter-item "><a href="lang/primitive-types.html"><strong aria-hidden="true">1.3.</strong> Primitive types</a></li><li class="chapter-item "><a href="lang/container-types.html"><strong aria-hidden="true">1.4.</strong> Container types</a></li><li class="chapter-item "><a href="lang/branching.html"><strong aria-hidden="true">1.5.</strong> Branching</a></li><li class="chapter-item "><a href="lang/print_error_assert.html"><strong aria-hidden="true">1.6.</strong> Print, error, assert</a></li><li class="chapter-item "><a href="lang/functions/index.html"><strong aria-hidden="true">1.7.</strong> Functions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lang/functions/multiple_return_values.html"><strong aria-hidden="true">1.7.1.</strong> Multiple return values</a></li><li class="chapter-item "><a href="lang/functions/void.html"><strong aria-hidden="true">1.7.2.</strong> Void functions</a></li><li class="chapter-item "><a href="lang/functions/anonymous.html"><strong aria-hidden="true">1.7.3.</strong> Anonymous functions</a></li><li class="chapter-item "><a href="lang/functions/unused_arguments.html"><strong aria-hidden="true">1.7.4.</strong> Unused arguments</a></li><li class="chapter-item "><a href="lang/functions/optional_arguments.html"><strong aria-hidden="true">1.7.5.</strong> Optional arguments</a></li><li class="chapter-item "><a href="lang/functions/named_arguments.html"><strong aria-hidden="true">1.7.6.</strong> Named arguments</a></li><li class="chapter-item "><a href="lang/functions/values.html"><strong aria-hidden="true">1.7.7.</strong> Function values</a></li><li class="chapter-item "><a href="lang/functions/example.html"><strong aria-hidden="true">1.7.8.</strong> Example: Collatz sequence</a></li></ol></li><li class="chapter-item "><a href="lang/operators.html"><strong aria-hidden="true">1.8.</strong> Operators</a></li><li class="chapter-item "><a href="lang/structs.html"><strong aria-hidden="true">1.9.</strong> Structs</a></li><li class="chapter-item "><a href="lang/enums.html"><strong aria-hidden="true">1.10.</strong> Enums</a></li><li class="chapter-item "><a href="lang/destructuring.html"><strong aria-hidden="true">1.11.</strong> Destructuring</a></li><li class="chapter-item "><a href="lang/methods.html"><strong aria-hidden="true">1.12.</strong> Methods</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lang/associated-functions-and-constants.html"><strong aria-hidden="true">1.12.1.</strong> Associated functions and constants</a></li><li class="chapter-item "><a href="lang/automatic-methods.html"><strong aria-hidden="true">1.12.2.</strong> Automatic methods</a></li><li class="chapter-item "><a href="lang/example-rational.html"><strong aria-hidden="true">1.12.3.</strong> Example: Rational</a></li></ol></li><li class="chapter-item "><a href="lang/script-structure.html"><strong aria-hidden="true">1.13.</strong> Structure of a script</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lang/example-script.html"><strong aria-hidden="true">1.13.1.</strong> Example: always_succeeds</a></li><li class="chapter-item "><a href="lang/parameterized.html"><strong aria-hidden="true">1.13.2.</strong> Contract Parameters</a></li></ol></li><li class="chapter-item "><a href="lang/modules.html"><strong aria-hidden="true">1.14.</strong> Modules</a></li><li class="chapter-item "><a href="lang/builtins/index.html"><strong aria-hidden="true">1.15.</strong> Builtins</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lang/builtins/address.html"><strong aria-hidden="true">1.15.1.</strong> Address</a></li><li class="chapter-item "><a href="lang/builtins/assetclass.html"><strong aria-hidden="true">1.15.2.</strong> AssetClass</a></li><li class="chapter-item "><a href="lang/builtins/bool.html"><strong aria-hidden="true">1.15.3.</strong> Bool</a></li><li class="chapter-item "><a href="lang/builtins/bytearray.html"><strong aria-hidden="true">1.15.4.</strong> ByteArray</a></li><li class="chapter-item "><a href="lang/builtins/credential.html"><strong aria-hidden="true">1.15.5.</strong> Credential</a></li><li class="chapter-item "><a href="lang/builtins/data.html"><strong aria-hidden="true">1.15.6.</strong> Data</a></li><li class="chapter-item "><a href="lang/builtins/datumhash.html"><strong aria-hidden="true">1.15.7.</strong> DatumHash</a></li><li class="chapter-item "><a href="lang/builtins/dcert.html"><strong aria-hidden="true">1.15.8.</strong> DCert</a></li><li class="chapter-item "><a href="lang/builtins/duration.html"><strong aria-hidden="true">1.15.9.</strong> Duration</a></li><li class="chapter-item "><a href="lang/builtins/int.html"><strong aria-hidden="true">1.15.10.</strong> Int</a></li><li class="chapter-item "><a href="lang/builtins/list.html"><strong aria-hidden="true">1.15.11.</strong> List</a></li><li class="chapter-item "><a href="lang/builtins/map.html"><strong aria-hidden="true">1.15.12.</strong> Map</a></li><li class="chapter-item "><a href="lang/builtins/mintingpolicyhash.html"><strong aria-hidden="true">1.15.13.</strong> MintingPolicyHash</a></li><li class="chapter-item "><a href="lang/builtins/option.html"><strong aria-hidden="true">1.15.14.</strong> Option</a></li><li class="chapter-item "><a href="lang/builtins/outputdatum.html"><strong aria-hidden="true">1.15.15.</strong> OutputDatum</a></li><li class="chapter-item "><a href="lang/builtins/pubkey.html"><strong aria-hidden="true">1.15.16.</strong> PubKey</a></li><li class="chapter-item "><a href="lang/builtins/pubkeyhash.html"><strong aria-hidden="true">1.15.17.</strong> PubKeyHash</a></li><li class="chapter-item "><a href="lang/builtins/real.html"><strong aria-hidden="true">1.15.18.</strong> Real</a></li><li class="chapter-item "><a href="lang/builtins/scriptcontext.html"><strong aria-hidden="true">1.15.19.</strong> ScriptContext</a></li><li class="chapter-item "><a href="lang/builtins/scripthash.html"><strong aria-hidden="true">1.15.20.</strong> ScriptHash</a></li><li class="chapter-item "><a href="lang/builtins/scriptpurpose.html"><strong aria-hidden="true">1.15.21.</strong> ScriptPurpose</a></li><li class="chapter-item "><a href="lang/builtins/stakekeyhash.html"><strong aria-hidden="true">1.15.22.</strong> StakeKeyHash</a></li><li class="chapter-item "><a href="lang/builtins/stakingcredential.html"><strong aria-hidden="true">1.15.23.</strong> StakingCredential</a></li><li class="chapter-item "><a href="lang/builtins/stakinghash.html"><strong aria-hidden="true">1.15.24.</strong> StakingHash</a></li><li class="chapter-item "><a href="lang/builtins/stakingpurpose.html"><strong aria-hidden="true">1.15.25.</strong> StakingPurpose</a></li><li class="chapter-item "><a href="lang/builtins/stakingvalidatorhash.html"><strong aria-hidden="true">1.15.26.</strong> StakingValidatorHash</a></li><li class="chapter-item "><a href="lang/builtins/string.html"><strong aria-hidden="true">1.15.27.</strong> String</a></li><li class="chapter-item "><a href="lang/builtins/time.html"><strong aria-hidden="true">1.15.28.</strong> Time</a></li><li class="chapter-item "><a href="lang/builtins/timerange.html"><strong aria-hidden="true">1.15.29.</strong> TimeRange</a></li><li class="chapter-item "><a href="lang/builtins/tx.html"><strong aria-hidden="true">1.15.30.</strong> Tx</a></li><li class="chapter-item "><a href="lang/builtins/txid.html"><strong aria-hidden="true">1.15.31.</strong> TxId</a></li><li class="chapter-item "><a href="lang/builtins/txinput.html"><strong aria-hidden="true">1.15.32.</strong> TxInput</a></li><li class="chapter-item "><a href="lang/builtins/txoutput.html"><strong aria-hidden="true">1.15.33.</strong> TxOutput</a></li><li class="chapter-item "><a href="lang/builtins/txoutputid.html"><strong aria-hidden="true">1.15.34.</strong> TxOutputId</a></li><li class="chapter-item "><a href="lang/builtins/validatorhash.html"><strong aria-hidden="true">1.15.35.</strong> ValidatorHash</a></li><li class="chapter-item "><a href="lang/builtins/value.html"><strong aria-hidden="true">1.15.36.</strong> Value</a></li></ol></li></ol></li><li class="chapter-item "><a href="api/index.html"><strong aria-hidden="true">2.</strong> Helios API</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="api/setup.html"><strong aria-hidden="true">2.1.</strong> Setup</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="api/deno.html"><strong aria-hidden="true">2.1.1.</strong> Deno</a></li></ol></li><li class="chapter-item "><a href="api/compiling.html"><strong aria-hidden="true">2.2.</strong> Compiling Helios sources</a></li><li class="chapter-item "><a href="api/generating.html"><strong aria-hidden="true">2.3.</strong> Generating datums and redeemers</a></li><li class="chapter-item "><a href="api/building/index.html"><strong aria-hidden="true">2.4.</strong> Building transactions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="api/building/inputs.html"><strong aria-hidden="true">2.4.1.</strong> Transaction inputs</a></li><li class="chapter-item "><a href="api/building/outputs.html"><strong aria-hidden="true">2.4.2.</strong> Transaction outputs</a></li><li class="chapter-item "><a href="api/building/collateral.html"><strong aria-hidden="true">2.4.3.</strong> Collateral</a></li><li class="chapter-item "><a href="api/building/signers.html"><strong aria-hidden="true">2.4.4.</strong> Explicit signers</a></li><li class="chapter-item "><a href="api/building/minting.html"><strong aria-hidden="true">2.4.5.</strong> Minting</a></li><li class="chapter-item "><a href="api/building/finalizing.html"><strong aria-hidden="true">2.4.6.</strong> Finalizing</a></li><li class="chapter-item "><a href="api/building/signing-and-submitting.html"><strong aria-hidden="true">2.4.7.</strong> Signing and submitting</a></li></ol></li><li class="chapter-item "><a href="api/picoswap/index.html"><strong aria-hidden="true">2.5.</strong> Example: PicoSwap</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="api/picoswap/script.html"><strong aria-hidden="true">2.5.1.</strong> Main script</a></li><li class="chapter-item "><a href="api/picoswap/datums.html"><strong aria-hidden="true">2.5.2.</strong> Generating datums</a></li><li class="chapter-item "><a href="api/picoswap/contract-class.html"><strong aria-hidden="true">2.5.3.</strong> Contract helper class</a></li><li class="chapter-item "><a href="api/picoswap/new-sale.html"><strong aria-hidden="true">2.5.4.</strong> Creating a new sale</a></li><li class="chapter-item "><a href="api/picoswap/cancel-sale.html"><strong aria-hidden="true">2.5.5.</strong> Canceling a sale</a></li><li class="chapter-item "><a href="api/picoswap/buying.html"><strong aria-hidden="true">2.5.6.</strong> Buying for-sale assets</a></li></ol></li><li class="chapter-item "><a href="api/reference/index.html"><strong aria-hidden="true">2.6.</strong> API Reference</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="api/reference/globals.html"><strong aria-hidden="true">2.6.1.</strong> Globals</a></li><li class="chapter-item "><a href="api/reference/functions.html"><strong aria-hidden="true">2.6.2.</strong> Functions</a></li><li class="chapter-item "><a href="api/reference/address.html"><strong aria-hidden="true">2.6.3.</strong> Address</a></li><li class="chapter-item "><a href="api/reference/assetclass.html"><strong aria-hidden="true">2.6.4.</strong> AssetClass</a></li><li class="chapter-item "><a href="api/reference/assets.html"><strong aria-hidden="true">2.6.5.</strong> Assets</a></li><li class="chapter-item "><a href="api/reference/blockfrostv0.html"><strong aria-hidden="true">2.6.6.</strong> BlockfrostV0</a></li><li class="chapter-item "><a href="api/reference/bytearraydata.html"><strong aria-hidden="true">2.6.7.</strong> ByteArrayData</a></li><li class="chapter-item "><a href="api/reference/cbordata.html"><strong aria-hidden="true">2.6.8.</strong> CborData</a></li><li class="chapter-item "><a href="api/reference/cip30handle.html"><strong aria-hidden="true">2.6.9.</strong> Cip30Handle</a></li><li class="chapter-item "><a href="api/reference/cip30wallet.html"><strong aria-hidden="true">2.6.10.</strong> Cip30Wallet</a></li><li class="chapter-item "><a href="api/reference/coinselection.html"><strong aria-hidden="true">2.6.11.</strong> CoinSelection</a></li><li class="chapter-item "><a href="api/reference/constrdata.html"><strong aria-hidden="true">2.6.12.</strong> ConstrData</a></li><li class="chapter-item "><a href="api/reference/crypto.html"><strong aria-hidden="true">2.6.13.</strong> Crypto</a></li><li class="chapter-item "><a href="api/reference/datum.html"><strong aria-hidden="true">2.6.14.</strong> Datum</a></li><li class="chapter-item "><a href="api/reference/datumhash.html"><strong aria-hidden="true">2.6.15.</strong> DatumHash</a></li><li class="chapter-item "><a href="api/reference/fuzzytest.html"><strong aria-hidden="true">2.6.16.</strong> FuzzyTest</a></li><li class="chapter-item "><a href="api/reference/heliosdata.html"><strong aria-hidden="true">2.6.17.</strong> HeliosData</a></li><li class="chapter-item "><a href="api/reference/intdata.html"><strong aria-hidden="true">2.6.18.</strong> IntData</a></li><li class="chapter-item "><a href="api/reference/listdata.html"><strong aria-hidden="true">2.6.19.</strong> ListData</a></li><li class="chapter-item "><a href="api/reference/mapdata.html"><strong aria-hidden="true">2.6.20.</strong> MapData</a></li><li class="chapter-item "><a href="api/reference/mintingpolicyhash.html"><strong aria-hidden="true">2.6.21.</strong> MintingPolicyHash</a></li><li class="chapter-item "><a href="api/reference/network.html"><strong aria-hidden="true">2.6.22.</strong> Network</a></li><li class="chapter-item "><a href="api/reference/networkemulator.html"><strong aria-hidden="true">2.6.23.</strong> NetworkEmulator</a></li><li class="chapter-item "><a href="api/reference/networkparams.html"><strong aria-hidden="true">2.6.24.</strong> NetworkParams</a></li><li class="chapter-item "><a href="api/reference/program.html"><strong aria-hidden="true">2.6.25.</strong> Program</a></li><li class="chapter-item "><a href="api/reference/pubkeyhash.html"><strong aria-hidden="true">2.6.26.</strong> PubKeyHash</a></li><li class="chapter-item "><a href="api/reference/signature.html"><strong aria-hidden="true">2.6.27.</strong> Signature</a></li><li class="chapter-item "><a href="api/reference/stakeaddress.html"><strong aria-hidden="true">2.6.28.</strong> StakeAddress</a></li><li class="chapter-item "><a href="api/reference/stakekeyhash.html"><strong aria-hidden="true">2.6.29.</strong> StakeKeyHash</a></li><li class="chapter-item "><a href="api/reference/stakingvalidatorhash.html"><strong aria-hidden="true">2.6.30.</strong> StakingValidatorHash</a></li><li class="chapter-item "><a href="api/reference/tx.html"><strong aria-hidden="true">2.6.31.</strong> Tx</a></li><li class="chapter-item "><a href="api/reference/txid.html"><strong aria-hidden="true">2.6.32.</strong> TxId</a></li><li class="chapter-item "><a href="api/reference/txoutput.html"><strong aria-hidden="true">2.6.33.</strong> TxOutput</a></li><li class="chapter-item "><a href="api/reference/txrefinput.html"><strong aria-hidden="true">2.6.34.</strong> TxRefInput</a></li><li class="chapter-item "><a href="api/reference/txwitnesses.html"><strong aria-hidden="true">2.6.35.</strong> TxWitnesses</a></li><li class="chapter-item "><a href="api/reference/uplcbool.html"><strong aria-hidden="true">2.6.36.</strong> UplcBool</a></li><li class="chapter-item "><a href="api/reference/uplcbytearray.html"><strong aria-hidden="true">2.6.37.</strong> UplcByteArray</a></li><li class="chapter-item "><a href="api/reference/uplcdata.html"><strong aria-hidden="true">2.6.38.</strong> UplcData</a></li><li class="chapter-item "><a href="api/reference/uplcdatavalue.html"><strong aria-hidden="true">2.6.39.</strong> UplcDataValue</a></li><li class="chapter-item "><a href="api/reference/uplcint.html"><strong aria-hidden="true">2.6.40.</strong> UplcInt</a></li><li class="chapter-item "><a href="api/reference/uplcpair.html"><strong aria-hidden="true">2.6.41.</strong> UplcPair</a></li><li class="chapter-item "><a href="api/reference/uplcprogram.html"><strong aria-hidden="true">2.6.42.</strong> UplcProgram</a></li><li class="chapter-item "><a href="api/reference/uplcstring.html"><strong aria-hidden="true">2.6.43.</strong> UplcString</a></li><li class="chapter-item "><a href="api/reference/uplcunit.html"><strong aria-hidden="true">2.6.44.</strong> UplcUnit</a></li><li class="chapter-item "><a href="api/reference/uplcvalue.html"><strong aria-hidden="true">2.6.45.</strong> UplcValue</a></li><li class="chapter-item "><a href="api/reference/usererror.html"><strong aria-hidden="true">2.6.46.</strong> UserError</a></li><li class="chapter-item "><a href="api/reference/utxo.html"><strong aria-hidden="true">2.6.47.</strong> UTxO</a></li><li class="chapter-item "><a href="api/reference/validatorhash.html"><strong aria-hidden="true">2.6.48.</strong> ValidatorHash</a></li><li class="chapter-item "><a href="api/reference/value.html"><strong aria-hidden="true">2.6.49.</strong> Value</a></li><li class="chapter-item "><a href="api/reference/wallet.html"><strong aria-hidden="true">2.6.50.</strong> Wallet</a></li><li class="chapter-item "><a href="api/reference/walletemulator.html"><strong aria-hidden="true">2.6.51.</strong> WalletEmulator</a></li><li class="chapter-item "><a href="api/reference/wallethelper.html"><strong aria-hidden="true">2.6.52.</strong> WalletHelper</a></li></ol></li></ol></li><li class="chapter-item "><a href="cli/index.html"><strong aria-hidden="true">3.</strong> Helios CLI</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="cli/setup.html"><strong aria-hidden="true">3.1.</strong> Setup</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="cli/install.html"><strong aria-hidden="true">3.1.1.</strong> Install helios-cli</a></li><li class="chapter-item "><a href="cli/cardano-node.html"><strong aria-hidden="true">3.1.2.</strong> Setup cardano-node</a></li><li class="chapter-item "><a href="cli/wallet.html"><strong aria-hidden="true">3.1.3.</strong> Wallet setup</a></li></ol></li><li class="chapter-item "><a href="cli/usage.html"><strong aria-hidden="true">3.2.</strong> Using helios-cli</a></li><li class="chapter-item "><a href="cli/example-always-succeeds.html"><strong aria-hidden="true">3.3.</strong> Example: Always succeeds</a></li><li class="chapter-item "><a href="cli/example-time-lock.html"><strong aria-hidden="true">3.4.</strong> Example: Time lock</a></li></ol></li><li class="chapter-item "><a href="integrations/index.html"><strong aria-hidden="true">4.</strong> Integrations</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="integrations/different-versions.html"><strong aria-hidden="true">4.1.</strong> Different versions of Helios</a></li><li class="chapter-item "><a href="integrations/vscode.html"><strong aria-hidden="true">4.2.</strong> VSCode</a></li><li class="chapter-item "><a href="integrations/webpack.html"><strong aria-hidden="true">4.3.</strong> Webpack</a></li></ol></li><li class="chapter-item "><a href="advanced-concepts/index.html"><strong aria-hidden="true">5.</strong> Advanced concepts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="advanced-concepts/exploits.html"><strong aria-hidden="true">5.1.</strong> Exploits</a></li><li class="chapter-item "><a href="advanced-concepts/ir/index.html"><strong aria-hidden="true">5.2.</strong> Intermediate representation</a></li><li class="chapter-item "><a href="advanced-concepts/ir/simplification.html"><strong aria-hidden="true">5.3.</strong> Simplification</a></li><li class="chapter-item "><a href="advanced-concepts/minting/index.html"><strong aria-hidden="true">5.4.</strong> Minting native assets</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="advanced-concepts/minting/signature.html"><strong aria-hidden="true">5.4.1.</strong> Signature based minting</a></li><li class="chapter-item "><a href="advanced-concepts/minting/unique.html"><strong aria-hidden="true">5.4.2.</strong> Unique minting</a></li></ol></li><li class="chapter-item "><a href="advanced-concepts/vesting-contract.html"><strong aria-hidden="true">5.5.</strong> Vesting contract</a></li><li class="chapter-item "><a href="advanced-concepts/english-auction.html"><strong aria-hidden="true">5.6.</strong> English auction</a></li><li class="chapter-item "><a href="advanced-concepts/oracle-pools.html"><strong aria-hidden="true">5.7.</strong> Oracle pools</a></li><li class="chapter-item "><a href="advanced-concepts/dapps.html"><strong aria-hidden="true">5.8.</strong> dApp recommendations</a></li><li class="chapter-item "><a href="advanced-concepts/tx-finalization.html"><strong aria-hidden="true">5.9.</strong> Tx finalization</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Helios Smart Contract Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/hyperion-bt/helios-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction-to-helios"><a class="header" href="#introduction-to-helios">Introduction to Helios</a></h1>
<p><a href="https://github.com/Hyperion-BT/Helios">Helios</a> is a <a href="./lang/index.html">DSL</a> (Domain Specific Language) for writing smart contracts for the <a href="https://www.cardano.org">Cardano</a> blockchain.</p>
<p>The <a href="https://github.com/Hyperion-BT/Helios">Helios library</a> is written in Javascript/Typescript and has an <a href="./api/index.html">API</a> for:</p>
<ul>
<li>compiling Helios sources into <a href="https://github.com/input-output-hk/plutus">Plutus-Core</a></li>
<li>building and submitting transactions to the Cardano blockchain</li>
</ul>
<h2 id="code-sample"><a class="header" href="#code-sample">Code sample</a></h2>
<pre><code class="language-helios">// all Helios programs begin with a script purpose
spending always_true 

// the 'main' function contains the core validator logic
// returns true if a given UTxO is allowed to be spent
func main(_, _, _) -&gt; Bool {
    // Helios is an expression based language
    true
}

// Note: the datum, redeemer, and scriptcontext are ignored by the underscores
</code></pre>
<h2 id="structure-of-this-book"><a class="header" href="#structure-of-this-book">Structure of this book</a></h2>
<p>Before starting to use Helios to create smart contracts and build dApps it is important to understand Cardano's eUTxO model very well. If you don't yet, we recommend you read the <a href="./understanding-eutxos.html">Understanding eUTxOs</a> preface first.</p>
<p><a href="./lang/index.html">Chapter 1</a> covers the language itself, including a complete reference of the Helios builtins.</p>
<p><a href="./api/index.html">Chapter 2</a> covers setting up the Helios library, compiling smart contracts, and building and submitting smart contract transactions, using only Javascript/Typescript.</p>
<p><a href="./cli/index.html">Chapter 3</a> covers how to use Helios smart contracts with <em>cardano-cli</em>.</p>
<p><a href="./advanced-concepts/index.html">Chapter 4</a> covers minting policies, exploits to be aware of, some more complex scripts, and some recommendations for building dApps.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-the-eutxo-model"><a class="header" href="#understanding-the-eutxo-model">Understanding the eUTxO model</a></h1>
<p>Before we get into any coding we first need to understand how smart contracts work on Cardano and how Cardano differs from the more conventional account-based model.</p>
<blockquote>
<p><strong>Note</strong>: eUTxO is an abbreviation of <em>extended Unspent Transaction Outputs</em></p>
</blockquote>
<h2 id="account-based-model-vs-eutxo-model"><a class="header" href="#account-based-model-vs-eutxo-model">Account-based model vs eUTxO model</a></h2>
<p>Smart contracts on Cardano are quite different from those on Ethereum.</p>
<h3 id="ethereum-style-smart-contracts-account-based"><a class="header" href="#ethereum-style-smart-contracts-account-based">Ethereum-style smart contracts (account-based)</a></h3>
<p>When a transaction occurs on an account-based blockchain, the balance of the sender's account is directly decremented and that of the recipient is incremented, similar to how conventional bank accounts work.</p>
<p>Contracts interact with these balances and run via the EVM (Ethereum Virtual Machine). The EVM can be thought of as a global on-chain computer on which smart contracts take turns running, before their results are added to the chain.</p>
<blockquote>
<p><strong>Note</strong>: the data of all accounts on Ethereum are stored in a <a href="https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/"><strong>Merkle-Patricia trie</strong></a>, which is like a fancy hashmap. After all the transactions in a block are run, the root hash of the block trie is added to the chain.</p>
</blockquote>
<h3 id="the-eutxo-model"><a class="header" href="#the-eutxo-model">The eUTxO model</a></h3>
<p>In the eUTxO model tokens are stored in UTxOs. A UTxO is like (electronic)-cash where each individual bundle of bills (Ada and native-tokens) is stored separately.</p>
<p>A transaction in the UTxO model takes one or more UTxOs as <strong>transaction inputs</strong>, which are destroyed, and creates one or more UTxOs as <strong>transaction outputs</strong>.</p>
<p>Transactions in an account-based model mutate the data-points storing the total balances. This is very risky (regular banks are insured against this, and also have paper backups in case of mistakes, but blockchains have no such fallbacks). In the UTxO model only the &quot;bills&quot; that participate in a given transaction can potentially be affected (which is bad, but not catastrophic).</p>
<p>Of course a UTxO chain can emulate account-based chains (by storing all tokens in a single UTxO) and account-based chains can emulate UTxO chains (by spreading a user's balance over many different accounts).</p>
<h2 id="components-of-a-utxo-on-cardano"><a class="header" href="#components-of-a-utxo-on-cardano">Components of a UTxO on Cardano</a></h2>
<p>UTxOs have 3 main components:</p>
<ul>
<li>an address</li>
<li>tokens (Ada and other native assets)</li>
<li>a datum</li>
</ul>
<h3 id="address"><a class="header" href="#address">Address</a></h3>
<p>The address of a UTxO determines the owner (i.e. who has the right to spend it).</p>
<p>A user's balance is calculated by summing all UTxOs sitting at addresses <em>owned</em> by that user.</p>
<p>An address can either be derived from the hash of a user's public key (<a href="./lang/builtins/pubkeyhash.html"><code>PubKeyHash</code></a> in Helios), or the hash of a validator script (<a href="./lang/builtins/validatorhash.html"><code>ValidatorHash</code></a> in Helios). In the latter case the script effectively becomes the owner of the UTxO.</p>
<h3 id="tokens"><a class="header" href="#tokens">Tokens</a></h3>
<p>Each UTxO contains some tokens, which represent value on the blockchain. Tokens have positive value due to scarcity (tokens can't be duplicated) and utility (eg. Ada being used to pay transaction fees).</p>
<h3 id="datum"><a class="header" href="#datum">Datum</a></h3>
<p>The <em>datum</em> is data that is attached to UTxOs. A datum represents the state of a smart contract, and is immutable (smart contract state can change though, by spending old UTxOs and creating new ones).</p>
<p>The 'e' (<em>extended</em>) in eUTxO comes from the datum. The Bitcoin UTxO model doesn't have datums, giving Bitcoin scripts very limited capabilities. <em>Extending</em> the UTxO model, as done by Cardano and Ergo, gives an eUTxO model the same capabilities as an account-based model, while benefitting from a much safer approach to transactions (because a global state isn't being accessed/mutated).</p>
<h2 id="validator-scripts"><a class="header" href="#validator-scripts">Validator scripts</a></h2>
<p>A validator script is a function that is evaluated when a transaction attempts to spend a UTxO locked at that script's address. This function takes 3 arguments:</p>
<ul>
<li>the datum attached to the UTxO</li>
<li>some data provided by the user who created the transaction (the <em>redeemer</em>)</li>
<li>details about the transaction (the <em>script context</em>)</li>
</ul>
<p>The validator script then calculates whether or not the UTxO is allowed to be spent (essentially returning a boolean result).</p>
<p>Separating the validation logic from the transaction building/submitting logic makes it much easier to audit the trusted part of eUTxO dApps.</p>
<p>Helios is all about writing these validator scripts.</p>
<blockquote>
<p><strong>Note</strong>: a UTxO can only be spent once. In every transaction all input UTxOs are destroyed, and new output UTxOs are created.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: a valid transaction must satisfy the following conditions:</p>
<ul>
<li>the transaction must be balanced: the total amount of tokens in the transaction inputs must be equal to those in the transaction outputs (minus the fees, plus the minted tokens).</li>
<li>the validators for all the transaction inputs must evaluate to <code>true</code>.</li>
</ul>
</blockquote>
<h2 id="pros-and-cons-of-the-eutxo-model"><a class="header" href="#pros-and-cons-of-the-eutxo-model">Pros and cons of the eUTxO Model</a></h2>
<h3 id="pros"><a class="header" href="#pros">Pros</a></h3>
<ul>
<li>
<h4 id="deterministic-transaction-fees"><a class="header" href="#deterministic-transaction-fees">Deterministic transaction fees</a></h4>
<p>eUTxO smart contract evaluation is deterministic. This means that you can calculate the resource usage of a transaction before posting it to the blockchain. The transaction fees for a transaction can thus be calculated deterministically off-chain.</p>
<p>The transaction fees of account-based blockchains depend on network load, and can vary a lot.</p>
</li>
<li>
<h4 id="transaction-fees-not-charged-upon-failure"><a class="header" href="#transaction-fees-not-charged-upon-failure">Transaction fees not charged upon failure</a></h4>
<p>The determinism of the eUTxO model means that transaction success can be determined before posting. Transaction failure is still possible due to contention, but this is a very cheap check, and no fee is charged.</p>
<p>Transaction failure on account-based blockchains results in losing the fee, as significant processing power might've been used before encountering the failure condition.</p>
</li>
<li>
<h4 id="easier-to-audit"><a class="header" href="#easier-to-audit">Easier to audit</a></h4>
<p>Auditing of eUTxO smart contracts is much easier because only the validation function needs to be audited, which has a very <strong>locally-scoped</strong> nature.</p>
</li>
<li>
<h4 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h4>
<p>Due to monetary value being naturally spread over many UTxOs, a UTxO blockchain can be compared to an extremely sharded account-based blockchain (some smart contracts might require a centralized data-point though, and won't allow concurrent interactions, see <a href="understanding-eutxos.html#contention">contention</a>).</p>
</li>
<li>
<h4 id="better-for-layer-2"><a class="header" href="#better-for-layer-2">Better for layer 2</a></h4>
<p>The local nature of UTxOs allows reusing validation logic in layer 2 scaling solutions
such as state channels (see <a href="https://iohk.io/en/blog/posts/2021/09/17/hydra-cardano-s-solution-for-ultimate-scalability/">hydra</a>). </p>
</li>
<li>
<h4 id="simpler"><a class="header" href="#simpler">Simpler</a></h4>
<p>Though not immediately obvious, eUTxO smart contracts are often much simpler than an equivalent Solidity smart contract (this will become apparant when you start to use Helios).</p>
</li>
</ul>
<h3 id="cons"><a class="header" href="#cons">Cons</a></h3>
<ul>
<li>
<h4 id="contention"><a class="header" href="#contention">Contention</a></h4>
<p>If eUTxO contracts aren't designed properly they can encounter <em>contention</em> problems. Contention occurs when two or more transactions try to spend the same UTxO. If this happens only one of the transactions will succeed, and the others will fail (resulting in an unpleasant user experience).</p>
<p>This is usually not an issue on Ethereum because the EVM handles ordering smart contract calls.</p>
<blockquote>
<p><strong>Note</strong>: there are ways to avoid contention, by for example taking advantage of the parallel nature of UTxOs (see SundaeSwap's <a href="https://sundaeswap.finance/posts/sundaeswap-scalability">scooper model</a>)</p>
</blockquote>
</li>
</ul>
<h2 id="further-reading"><a class="header" href="#further-reading">Further reading</a></h2>
<p>If you feel like you still don't fully understand the eUTxO model, we recommend you keep reading:</p>
<ul>
<li><a href="https://dav009.medium.com/learning-ergo-101-blockchain-paradigm-eutxo-c90b0274cf5e">Learning Ergo 101 : eUTXO explained for human beings</a>, a great blog post by <a href="https://github.com/dav009">David Pryzbilla</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<p>This page documents breaking changes and major features of major version releases</p>
<h2 id="v013"><a class="header" href="#v013">v0.13</a></h2>
<h3 id="language"><a class="header" href="#language">Language</a></h3>
<ul>
<li><a href="./lang/automatic-methods.html#copy"><code>copy</code></a> automatically defined on user structs and enum-variants</li>
<li>variable arguments in <code>main</code> deprecated</li>
<li>function <a href="./lang/functions/optional_arguments.html">optional arguments</a> with default values</li>
<li>function calls with <a href="./lang/functions/named_arguments.html">named arguments</a></li>
</ul>
<h3 id="api"><a class="header" href="#api">API</a></h3>
<ul>
<li><code>helios.Int</code> renamed to <code>helios.HInt</code></li>
<li><code>helios.HeliosString</code> renamed to <code>helios.HString</code></li>
<li><code>helios.HeliosMap</code> renamed to <code>helios.HMap</code></li>
<li><code>helios.List</code> renamed to <code>helios.HList</code></li>
<li><code>program.changeParam()</code> deprecated</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="helios-language-reference"><a class="header" href="#helios-language-reference">Helios language reference</a></h1>
<p>The Helios language is a purely functional programming language, with a simple curly braces syntax. It is inspired by <a href="https://go.dev">Go</a> and <a href="https://www.rust-lang.org">Rust</a>.</p>
<h2 id="tenets"><a class="header" href="#tenets">Tenets</a></h2>
<ul>
<li>Helios should be readable by as many programmers as possible, readability is more important than writeability</li>
<li>Helios is opionated, there should be only one obvious way of doing things</li>
<li>Helios is safe, it should be easy to spot malicious code</li>
</ul>
<h2 id="structure-of-this-chapter"><a class="header" href="#structure-of-this-chapter">Structure of this chapter</a></h2>
<p>This chapter starts by explaining the basic syntax of Helios, and then moves onto higher level concepts like <a href="lang/./functions.html">functions</a>, <a href="lang/./structs.html">structs</a> and <a href="lang/./enums.html">enums</a>.</p>
<p>This chapter ends with a complete reference of the <a href="lang/./builtins/index.html">Helios builtins</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments"><a class="header" href="#comments">Comments</a></h1>
<p>Helios comments are C-like. </p>
<h2 id="single-line-comments"><a class="header" href="#single-line-comments">Single-line comments</a></h2>
<p>Single-line comments use two forward slashes (<code>//</code>):</p>
<pre><code class="language-helios">func main(_, _, _) -&gt; Bool {
	// This is a comment.
	true
}
</code></pre>
<h2 id="multi-line-and-inline-comments"><a class="header" href="#multi-line-and-inline-comments">Multi-line and inline comments</a></h2>
<p>Multi-line and inline comments use <code>/* ... */</code>:</p>
<pre><code class="language-helios">func main(_, _, _ /* inline comment */) -&gt; Bool {
	/*
		This is a multi-line comment.
	*/
	true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>Helios doesn't really have variables as it is a purely functional programming language, and nothing can be mutated after definition. It is more accurate to think of <em>variables</em> in Helios as <em>binding values to names</em>.</p>
<h2 id="assignment"><a class="header" href="#assignment">Assignment</a></h2>
<p>Inside a function body, values can be bound to names using assignment expressions:</p>
<pre><code class="language-helios">my_number: Int = 42; ...
</code></pre>
<p>Here <code>my_number</code> has value <code>42</code>, and has type <a href="lang/./builtins/int.html"><code>Int</code></a>. <code>my_number</code> cannot be mutated after its definition.</p>
<p>Assignment expressions must be followed by another expression, separated by a semicolon (<code>;</code>). The assignment expression above should be seen as syntactic sugar for the following anonymous function call: <code>((my_number: Int) -&gt; {...})(42)</code>.</p>
<blockquote>
<p><strong>Note</strong>: <a href="lang/./builtins/int.html"><code>Int</code></a> is Helios' only number type, and represents an unbounded integer.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: an assignment expression can alternatively be seen as a ternary operator: <code>... = ... ; ...</code></p>
</blockquote>
<h2 id="const-statements"><a class="header" href="#const-statements"><code>const</code> statements</a></h2>
<p>Values can also be bound to names at the <em>top-level</em> of a script, or inside <code>struct</code> or <code>enum</code> blocks. This is done with the <code>const</code> keyword:</p>
<pre><code class="language-helios">const AGE: Int = 123
</code></pre>
<p>Top-level <code>const</code> statements can be <a href="lang/../api/reference/program.html#changeparam"><code>re-bound</code></a> using the Helios API to form a new, distinct contract with a different address (see <a href="lang/./parameterized.html"><code>parameterized contracts</code></a>).</p>
<blockquote>
<p><strong>Note</strong>: the right-hand side of <code>const</code> can contain complex expressions and even function calls. The compiler is smart enough to evaluate these at compile-time.</p>
</blockquote>
<h2 id="type-annotations"><a class="header" href="#type-annotations">Type annotations</a></h2>
<p>Assignment expressions and <code>const</code> statements usually include  a <em>type annotation</em>. For literal right-hand sides <em>type annotations</em> are optional:</p>
<pre><code class="language-helios">list_of_ints = []Int{1, 1, 2, 3, 5}; ...

// instead of the more verbose:

list_of_ints: []Int = []Int{1, 1, 2, 3, 5}; ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitive-types"><a class="header" href="#primitive-types">Primitive types</a></h1>
<p>Helios has 5 <strong>primitive</strong> types:</p>
<ul>
<li><code>Int</code> (an unbounded integer)</li>
<li><code>Real</code> (a fixed point real number)</li>
<li><code>Bool</code> (<code>true</code> or <code>false</code>)</li>
<li><code>ByteArray</code> (array of uint8)</li>
<li><code>String</code> (utf-8 text)</li>
</ul>
<h2 id="int"><a class="header" href="#int"><code>Int</code></a></h2>
<p>Helios' <code>Int</code> type represents an unbounded integer (like Haskell's <code>Integer</code> type).</p>
<pre><code class="language-helios">// Helios supports typical integer literals:
my_decimal = 17;
my_binary  = 0b10001;
my_hex     = 0x11;
my_octal   = 0o121; ...
</code></pre>
<p>Large <code>Int</code>s can be delimited with underscores at power-of-3 positions to improve readability:</p>
<pre><code class="language-helios">my_large_decimal = 1_000_000; ...
</code></pre>
<p>More information about the <code>Int</code> type can be found <a href="lang/./builtins/int.html">here</a>.</p>
<h2 id="real"><a class="header" href="#real"><code>Real</code></a></h2>
<p>Helios' <code>Real</code> type represents a fixed point real number with 6 decimal places. <code>Real</code> is designed for use in calculations involving relative fees.</p>
<pre><code class="language-helios">fee = 0.0001 // 0.01%
</code></pre>
<p>Similar to <code>Int</code>, underscores can be used at power-of-3 positions to improve readability:</p>
<pre><code class="language-helios">fee = 0.000_1 // 0.01%
</code></pre>
<p>More information about the <code>Real</code> type can be found <a href="lang/./builtins/real.html">here</a>.</p>
<h2 id="bool"><a class="header" href="#bool"><code>Bool</code></a></h2>
<p>The <code>Bool</code> type has two possible literal values: <code>true</code> or <code>false</code>.</p>
<p>Booleans are used throughout validator scripts, and the return type of validator scripts is a boolean. The simplest validator script body is just a literal boolean:</p>
<pre><code class="language-helios">func main(_, _, _) -&gt; Bool {
    true
}
</code></pre>
<p>The <code>==</code> and <code>!=</code> operators, returning boolean results, are defined on all builtin and user types:</p>
<pre><code class="language-helios">func main(_, _, ctx: ScriptContext) -&gt; Bool {
    ctx == ctx // always true
}
</code></pre>
<p>More information about the <code>Bool</code> type can be found <a href="lang/./builtins/bool.html">here</a>.</p>
<h2 id="bytearray"><a class="header" href="#bytearray"><code>ByteArray</code></a></h2>
<p>The <code>ByteArray</code> type, as you've likely guessed, represents an array of bytes. A literal <code>ByteArray</code> is a hexadecimal sequence prefixed by <code>#</code>:</p>
<pre><code class="language-helios">my_bytes = #af2e221a; ... // 
</code></pre>
<p>All builtin and user types can be converted into a <code>ByteArray</code> using the builtin <a href="lang/./automatic-methods.html#serialize"><code>serialize</code></a> method:</p>
<pre><code class="language-helios">cbor_bytes: ByteArray = 123.serialize(); ... // cbor encoding of 123
</code></pre>
<p>More information about the <code>ByteArray</code> type can be found <a href="lang/./builtins/bytearray.html">here</a>.</p>
<blockquote>
<p><strong>Note</strong>: a <code>ByteArray</code> can be empty, so the following is valid syntax: <code>my_bytes = #; ...</code></p>
</blockquote>
<h2 id="string"><a class="header" href="#string"><code>String</code></a></h2>
<p>A literal Helios string uses double quotes (<code>&quot;...&quot;</code>):</p>
<pre><code class="language-helios">my_message = &quot;hello world&quot;; ...
</code></pre>
<p>Similar to all other values in Helios, strings are immutable and have a fixed length. </p>
<p>Strings cannot <em>grow</em> after definition. Concatenating two strings creates a new string:</p>
<pre><code class="language-helios">string_1 = &quot;Hel&quot;;
string_2 = &quot;ios&quot;;
result: String = string_1 + string_2; ... // &quot;Helios&quot;
</code></pre>
<p>More information about the <code>String</code> type can be found <a href="lang/./builtins/string.html">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="container-types"><a class="header" href="#container-types">Container types</a></h1>
<p>Helios has 3 <strong>container</strong> types:</p>
<ul>
<li>List (linked list)</li>
<li><code>Map</code> (association list of key-value pairs)</li>
<li><code>Option</code> (equivalent to <code>Maybe</code> in Haskell)</li>
</ul>
<h2 id="list"><a class="header" href="#list">List</a></h2>
<p>Helios has a builtin linked list type, similar to Haskell's <code>List</code>. The syntax for a list type is <code>[]ItemType</code> where <code>ItemType</code> is a parameter type that represents the type of the contained items. The <code>ItemType</code> can be any type except a function type.</p>
<p>List literals have a syntax similar to Go:</p>
<pre><code class="language-helios">my_ints = []Int{1, 2, 3, 4, 5};

x: Int = some_ints.get(2); ...   // x == 3
</code></pre>
<blockquote>
<p><strong>Note</strong>: lists aren't indexed with <code>[...]</code>. Instead the <a href="lang/./builtins/list.html#methods"><code>get</code></a> method can be used. Indices are 0-based.</p>
</blockquote>
<p>More information about lists can be found <a href="lang/./builtins/list.html">here</a>.</p>
<h2 id="map"><a class="header" href="#map"><code>Map</code></a></h2>
<p>A <code>Map</code> in Helios is internally represented as a list of key-value pairs. Both key and value can have any type except a function type. Uniqueness of keys isn't guaranteed.</p>
<p>A <code>Map</code> has a type syntax and a literal syntax similar to Go:</p>
<pre><code class="language-helios">// either side of the colon can be an arbitrary expression 
//  that evaluates to the correct type
my_map = Map[String]Int{
    &quot;zero&quot;: 0,
    &quot;one&quot;:  1,
    &quot;two&quot;:  2
}; ... 

print(my_map.get(&quot;zero&quot;).show()); ... // prints '0'
</code></pre>
<p>More information about maps can be found <a href="lang/./builtins/map.html">here</a>.</p>
<h2 id="option"><a class="header" href="#option"><code>Option</code></a></h2>
<p>The <code>Option</code> type is a builtin enum with type syntax <code>Option[</code><em><code>SomeType</code></em><code>]</code>. It is internally defined as:</p>
<pre><code class="language-helios">enum Option[SomeType] {
    Some { some: SomeType }
    None
}
</code></pre>
<p>An <code>Option</code> is instantiated like any other enum:</p>
<pre><code class="language-helios">some_int = Option[Int]::Some{42};

none_int = Option[Int]::None; ...
</code></pre>
<p>If you expect <code>Some</code>, you can assign, and even destructure, using the correct type annotation. Helios will automatically turn the assignment into a runtime type assertion (any <a href="lang/./enums.html"><code>enum</code></a> can take advantage of this):</p>
<pre><code class="language-helios">Option[Int]::Some{my_int} = option; ...
</code></pre>
<p>More information about <code>Option</code> can be found <a href="lang/./builtins/option.html">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="branching"><a class="header" href="#branching">Branching</a></h1>
<p>Helios has conventional <code>if-else</code> syntax for branching:</p>
<pre><code class="language-helios">if (tag == 0) {
    23
} else if (tag == 1) {
    42
} else {
	0
}
</code></pre>
<p>The last expression in each branch block is implicitly returned (much like Rust).</p>
<p>The following is valid syntax:</p>
<pre><code class="language-helios">x: Int = 
	if (true) {
		42
	} else {
		24
	}; ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="print-error-assert"><a class="header" href="#print-error-assert"><code>print</code>, <code>error</code>, <code>assert</code></a></h1>
<p>There are three builtin void functions. These can be used to define higher level <a href="lang/./functions/void.html">user-defined void functions</a>.</p>
<p>Void functions can't be used in assignments.</p>
<h2 id="print"><a class="header" href="#print"><code>print</code></a></h2>
<p>For debugging purposes, Helios has a special <code>print</code> expression. <code>print(...)</code> takes a <a href="lang/./builtins/string.html"><code>String</code></a> argument:</p>
<pre><code class="language-helios">func main() -&gt; Bool {
	print(&quot;Hello world&quot;);
	true
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: <code>print</code> expressions are useful when debugging scripts. They are however eliminated by the compiler when compiling scripts optimized for production.</p>
</blockquote>
<h2 id="error"><a class="header" href="#error"><code>error</code></a></h2>
<p>Helios has a special <code>error</code> builtin, which can be used to throw errors inside branches of <a href="lang/./branching.html"><code>if-else</code></a> expressions, and cases of <a href="lang/./enums.html#switch"><code>switch</code></a> expressions. At least one branch or case must be non-error-throwing for the <code>if-else</code> or <code>switch</code> expression to return a non-void value.</p>
<pre><code class="language-helios">if (cond) {
    true
} else {
    error(&quot;my error message&quot;)
}
</code></pre>
<pre><code class="language-helios">x.switch{
    Buy =&gt; true,
    Sell =&gt; error(&quot;my error message&quot;)
}
</code></pre>
<h2 id="assert"><a class="header" href="#assert"><code>assert</code></a></h2>
<p>The builtin <code>assert</code> function throws an error if a given expression evaluates to false.</p>
<pre><code class="language-helios">assert(condition, &quot;should be true&quot;); ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions are a core feature of Helios. All Helios functions are <em>pure</em>, which means they don't have side effects and always return the same result when given the same arguments.</p>
<p>Function statements are defined using the <code>func</code> keyword. Helios has no <code>return</code> statement, the last expression in a function is <em>implicitly returned</em> (like in Rust):</p>
<pre><code class="language-helios">func add(a: Int, b: Int) -&gt; Int {
    a + b 
}
</code></pre>
<p>A function can call itself recursively:</p>
<pre><code class="language-helios">func fib(n: Int) -&gt; Int {
    // the branches of an if/else expresion return values
    if (n &lt; 1) {
        1
    } else {
        fib(n - 1) + fib(n - 2)
    }
}
</code></pre>
<blockquote>
<p><strong>Note:</strong>: a function can only reference itself when recursing. Helios doesn't support hoisting, so mutual recursion by referring to functions defined after the current function isn't possible:</p>
<pre><code class="language-helios">01 func a(n: Int) -&gt; Int {
02     b(n)                   // ReferenceError: 'b' undefined
03 }
04
05 func b(n: Int) -&gt; Int {
06     a(n)                   // ok
07 }
</code></pre>
</blockquote>
<p>More detailed information can be found on the following pages:</p>
<ul>
<li><a href="lang/functions/./multiple_return_values.html">Multiple return values</a></li>
<li><a href="lang/functions/./void.html">Void functions</a></li>
<li><a href="lang/functions/./anonymous.html">Anonymous functions</a></li>
<li><a href="lang/functions/./unused_arguments.html">Unused arguments</a></li>
<li><a href="lang/functions/./optional_arguments.html">Optional arguments</a></li>
<li><a href="lang/functions/./named_arguments.html">Named arguments</a></li>
<li><a href="lang/functions/./values.html">Function values</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-return-values"><a class="header" href="#multiple-return-values">Multiple return values</a></h1>
<p>A Helios function can return multiple values:</p>
<pre><code class="language-helios">func swap(a: Int, b: Int) -&gt; (Int, Int) {
    (b, a)
}
</code></pre>
<p>You can assign to multiple return values:</p>
<pre><code class="language-helios">(a: Int, b: Int) = swap(10, 20); ... // a==20 &amp;&amp; b==10
</code></pre>
<p>Some of the multiple return values can be discarded with an underscore (<code>_</code>):</p>
<pre><code class="language-helios">(a: Int, _) = swap(10, 20); ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="void-functions"><a class="header" href="#void-functions">Void functions</a></h1>
<p>Functions that are composed of only <code>print</code>, <code>error</code>, <code>assert</code>, and <code>if-else</code>/<code>switch</code> expressions there-of, return void (<code>()</code>). These kinds of functions can't be called in assignments.</p>
<pre><code class="language-helios">func assert_even(n: Int) -&gt; () {
    assert(n % 2 == 0, &quot;not even&quot;)
}
</code></pre>
<p>The syntax for calling user-defined void functions is the same as for <code>print</code>, <code>error</code> and <code>assert</code>:</p>
<pre><code class="language-helios">func main(ctx: ScriptContext) -&gt; Bool {
    assert_even(ctx.outputs.length);
    ...
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anonymous-functions"><a class="header" href="#anonymous-functions">Anonymous functions</a></h1>
<p>Helios also supports anonymous function expressions. Anonymous function expressions are basically function statements without the <code>func</code> keyword: </p>
<pre><code class="language-helios">// type of 'is_even' can be inferred
is_even = (n: Int) -&gt; Bool { n % 2 == 0 }; ...
</code></pre>
<p>The return type of anonymous functions is optional:</p>
<pre><code class="language-helios">is_even = (n: Int) -&gt; { n % 2 == 0 }; ...
</code></pre>
<blockquote>
<p><strong>Note:</strong> function statements can be referenced by their name, returning a function value. This should be preferred to using anonymous functions, as it is more readable.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unused-arguments"><a class="header" href="#unused-arguments">Unused arguments</a></h1>
<p>All named function arguments must be used in the function definition. This can be inconvenient when defining callbacks where you want to ignore some of the arguments. For this situation you can use an underscore (<code>_</code>):</p>
<pre><code class="language-helios">// sort a map by only comparing the keys
map.sort((a_key: ByteArray, _, b_key: ByteArray, _) -&gt; Bool {
    a_key &lt; b_key
})
</code></pre>
<p>Underscores are most commonly used to ignore either the datum, redeemer, or the <code>ScriptContext</code>, in the <code>main</code> function of a validator script.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optional-arguments"><a class="header" href="#optional-arguments">Optional arguments</a></h1>
<p>Some function arguments can be made optional by specifying default values:</p>
<pre><code class="language-helios">func incr(x: Int, by: Int = 1) -&gt; Int {
    x + by
}
</code></pre>
<p>Optional arguments must come after non-optional arguments.</p>
<p>The type signature of a function with optional arguments differs from a regular function:</p>
<pre><code class="language-helios">fn: (Int, ?Int) -&gt; Int = incr
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="named-arguments"><a class="header" href="#named-arguments">Named arguments</a></h1>
<p>Similar to literal constructor fields, function arguments can be named in a call:</p>
<pre><code class="language-helios">func sub(a: Int, b: Int) -&gt; Int {
    a - b
}

sub(b: 1, a: 2) // == 1
</code></pre>
<p>Named arguments can't be mixed with positional arguments.</p>
<p>Named arguments are mostly used when calling the <a href="lang/functions/../automatic-methods.html#copy"><code>copy()</code></a> method.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-values"><a class="header" href="#function-values">Function values</a></h1>
<p>Functions are first-class citizens in Helios and can be used as values. This means:</p>
<h3 id="1-functions-can-be-passed-as-arguments"><a class="header" href="#1-functions-can-be-passed-as-arguments">1. Functions can be passed as arguments</a></h3>
<pre><code class="language-helios">even_numbers: []Int = ([]Int{1, 2, 3, 4, 5, 6}).filter(is_even); ... // [2, 4, 6]; 
</code></pre>
<h3 id="2-functions-can-be-returned"><a class="header" href="#2-functions-can-be-returned">2. Functions can be returned</a></h3>
<pre><code class="language-helios">add_a = (a: Int) -&gt; (Int) -&gt; Int { (b: Int) -&gt; {a + b} }; ...
</code></pre>
<blockquote>
<p><strong>Note</strong>: functions aren't entirely first-class to be precise. Functions can't be stored in containers, nor in structs/enums.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>The following is a more involved example of a function in Helios.</p>
<h1 id="example-collatz-sequence"><a class="header" href="#example-collatz-sequence">Example: Collatz sequence</a></h1>
<p>One of my favorite things in maths is the Collatz sequence. A Collatz sequence starts with a given number, <code>n</code>, and calculates the next number in the sequence using the following rules:</p>
<ol>
<li>if <code>n == 1</code> the sequence ends</li>
<li>if <code>n</code> is even the next number is <code>n / 2</code></li>
<li>if <code>n</code> is odd the next number is <code>(n * 3) + 1</code></li>
</ol>
<p>Curiously the Collatz sequence always converges to <code>1</code>, regardless the starting number.</p>
<p>The following function generates the Collatz sequence as a (reversed) list of integers:</p>
<pre><code class="language-helios">// eg. collatz(10, []Int{}) == []Int{10, 5, 16, 8, 4, 2, 1}
func collatz(n: Int, sequence: []Int) -&gt; []Int {
	updated_sequence: []Int = sequence.prepend(n);

    // Rule (1)
    if (n == 1) {
		updated_sequence

    // Rule (2)
    } else if (n % 2 == 0) {
        collatz(n / 2, updated_sequence)

    // Rule (3)
    } else {
        collatz(n * 3 + 1, updated_sequence)
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operators"><a class="header" href="#operators">Operators</a></h1>
<p>The following operators are defined on many of the <a href="lang/./builtins/index.html">builtins</a>:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Operator</th><th style="text-align: left">Precedence</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>-</code>(unary)</td><td style="text-align: left">7</td></tr>
<tr><td style="text-align: left"><code>+</code>(unary)</td><td style="text-align: left">7</td></tr>
<tr><td style="text-align: left"><code>!</code>(unary)</td><td style="text-align: left">7</td></tr>
<tr><td style="text-align: left"><code>%</code></td><td style="text-align: left">6</td></tr>
<tr><td style="text-align: left"><code>/</code></td><td style="text-align: left">6</td></tr>
<tr><td style="text-align: left"><code>*</code></td><td style="text-align: left">6</td></tr>
<tr><td style="text-align: left"><code>-</code> (binary)</td><td style="text-align: left">5</td></tr>
<tr><td style="text-align: left"><code>+</code> (binary)</td><td style="text-align: left">5</td></tr>
<tr><td style="text-align: left"><code>&gt;=</code></td><td style="text-align: left">4</td></tr>
<tr><td style="text-align: left"><code>&gt;</code></td><td style="text-align: left">4</td></tr>
<tr><td style="text-align: left"><code>&lt;=</code></td><td style="text-align: left">4</td></tr>
<tr><td style="text-align: left"><code>&lt;</code></td><td style="text-align: left">4</td></tr>
<tr><td style="text-align: left"><code>!=</code></td><td style="text-align: left">3</td></tr>
<tr><td style="text-align: left"><code>==</code></td><td style="text-align: left">3</td></tr>
<tr><td style="text-align: left"><code>&amp;&amp;</code></td><td style="text-align: left">2</td></tr>
<tr><td style="text-align: left"><code>||</code></td><td style="text-align: left">1</td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>Note</strong>: all unary operators have right-to-left associativity. All binary operators have left-to-right associativity.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: <code>==</code> and <code>!=</code> do a deep comparison and are defined automatically on all user-defined and builtin types.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<p>A struct in Helios is a named grouping of types (sometimes called a <a href="https://en.wikipedia.org/wiki/Product_type"><em>product type</em></a>). They are similar to structs in other languages (e.g. C, Go and Rust):</p>
<pre><code class="language-helios">// example of a Rational (fractional type)
struct Rational {
    top:    Int
    bottom: Int
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: a struct can't be empty and must have at least one field.</p>
</blockquote>
<h2 id="instantiating-a-struct"><a class="header" href="#instantiating-a-struct">Instantiating a struct</a></h2>
<p>A struct can be instantiated using the following literal syntax:</p>
<pre><code class="language-helios">const x = Rational { 1, 3 } // type of 'x' is inferred
</code></pre>
<p>The fields can also be named:</p>
<pre><code class="language-helios">const x = Rational { bottom: 3, top: 1 }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<p>Enums are used to represent types that have multiple variants (sometimes called <a href="https://en.wikipedia.org/wiki/Tagged_union"><em>tagged unions</em> or <em>sum types</em></a>). These are useful for datums and redeemers.</p>
<p>Example of an enum:</p>
<pre><code class="language-helios">enum Redeemer {
	Cancel
	Buy { buyer: PubKeyHash }
}

// instantiating an enum:
const my_redeemer = Redeemer::Buy { PubKeyHash::new(#...) } 
// type of 'my_redeemer' is inferred
</code></pre>
<blockquote>
<p><strong>Note</strong>: the OOP analogy of an enum is an abstract class, and the enum variants can be thought of as concrete implementations (i.e. child classes).</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: enum variants without fields don't use braces.</p>
</blockquote>
<h2 id="switch"><a class="header" href="#switch"><code>switch</code></a></h2>
<p>A <code>switch</code> expression is used to perform different actions depending on the enum variant. It is similar to a <code>switch</code> statement in C or Go (and dissimilar to a <code>match</code> expression in Rust, as Helios doesn't support pattern-matching):</p>
<pre><code class="language-helios">enum Datum {
	// each variant has a syntax similar to a struct
    Submission{...} 
    Queue{...}
    Post{...}
}

func main(datum: Datum) -&gt; Bool {
	datum.switch {
		x: Submission =&gt; { 
			... // expression must use x
		},
		Queue =&gt; {
			... // x not used, so can't be declared
		},
		_ =&gt; true // default must come last if all sub-types of Datum aren't handled explicitely
		// braces surrounding the cases are optional
	}
}
</code></pre>
<h2 id="data"><a class="header" href="#data"><code>Data</code></a></h2>
<p><a href="lang/./builtins/data.html"><code>Data</code></a> can be thought of as a special builtin enum with 5 members:</p>
<ul>
<li><a href="lang/./builtins/int.html"><code>Int</code></a></li>
<li><a href="lang/./builtins/bytearray.html"><code>ByteArray</code></a></li>
<li><a href="lang/./builtins/list.html"><code>[]Data</code></a></li>
<li><a href="lang/./builtins/map.html"><code>Map[Data]Data</code></a></li>
<li>any user-defined enum, or <code>(Int, []Data)</code></li>
</ul>
<p>A <code>switch</code> expression over <code>Data</code> can use any of these as case types:</p>
<pre><code class="language-helios">data.switch{
	i: Int =&gt; ...,
	b: ByteArray =&gt; ...,
	l: []Data =&gt; ...,
	m: Map[Data]Data =&gt; ...,
	e: MyEnum =&gt; ... 
}
</code></pre>
<p>or </p>
<pre><code class="language-helios">data.switch{
	i: Int =&gt; ...,
	b: ByteArray =&gt; ...,
	l: []Data =&gt; ...,
	m: Map[Data]Data =&gt; ...,
	(index: Int, fields: []Data) =&gt; ... 
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: the default <code>_</code> case can also be used as a substitute for any of these cases.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: besides the builtin types only one enum type can be used in a <code>Data</code> <code>switch</code>, and structs/enum-members <strong>can't</strong> be used. If an enum is used then <code>(Int, []Data)</code> can't be used.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="destructuring"><a class="header" href="#destructuring">Destructuring</a></h1>
<p><a href="lang/./enums.html#switch">Switch cases</a> and <a href="lang/./variables.html#assignment">assignments</a> have special syntax for destructuring user-defined <a href="lang/./structs.html">structs</a> and <a href="lang/./enums.html">enum</a> members.</p>
<p>Destructuring in Helios has the following properties:</p>
<ul>
<li>can be arbitrarily nested</li>
<li>is positional (names of the fields don't matter)</li>
</ul>
<blockquote>
<p><strong>Note</strong>: destructuring is <strong>not</strong> pattern matching.</p>
</blockquote>
<h2 id="destructuring-assignment"><a class="header" href="#destructuring-assignment">Destructuring assignment</a></h2>
<pre><code class="language-helios">testing destructure_pair

struct Pair {
    first:  Int
    second: Int
}

func main() -&gt; Bool {
    p = Pair{1, 2};
    Pair{a, _} = p;
    a == 1
}
</code></pre>
<p>You can also assign a name to any intermediate value when destructuring:</p>
<pre><code class="language-helios">pair: Pair{a, _} = p; ...
</code></pre>
<p>Optionally you can include the type when destructuring a field:</p>
<pre><code class="language-helios">pair: Pair{a: Int, _} = p; ...
</code></pre>
<p>Destructuring an enum instance into an enum variant will create a runtime type assertion:</p>
<pre><code class="language-helios">Option[Int]::Some{a} = option; ... // throws runtime error if option is None
</code></pre>
<h2 id="destructuring-an-enum-member-in-a-switch-case"><a class="header" href="#destructuring-an-enum-member-in-a-switch-case">Destructuring an enum member in a <code>switch</code> case</a></h2>
<p>The same syntax as above can be used in <a href="lang/./enums.html#switch"><code>switch</code></a> cases. Destructuring some builtin enums is also possible (WiP).</p>
<pre><code class="language-helios">option.switch{
    None =&gt; ...,
    Some{item} =&gt; doSomething(item)
}
</code></pre>
<h2 id="nested-destructuring"><a class="header" href="#nested-destructuring">Nested destructuring</a></h2>
<p>Nested destructuring requires the type of the nested struct to be specified.</p>
<pre><code class="language-helios">spending my_validator

struct Rational {
    top: Int
    bottom: Int
}

enum Redeemer {
    Sell{price: Rational}
    Buy{price: Rational}
}

...

func main(_, r: Redeemer, _) -&gt; Bool {
    r.switch{
        Sell{Rational{top, bottom}} =&gt; doSomething(top, bottom),
        Buy{Rational{top, _}} =&gt; doSomething2(top)
    }
}
</code></pre>
<p>Nested destructuring is also possible in assignments.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methods"><a class="header" href="#methods">Methods</a></h1>
<p>You can define methods for structs and enums. The syntax for this is similar to many OOP languages: methods are defined by placing <code>func</code> statements inside a <code>struct</code> or <code>enum</code> block:</p>
<pre><code class="language-helios">struct Rational {
    top:    Int
    bottom: Int

    // 'self' implicitely has type 'Rational'
    func add(self, rhs: Rational) -&gt; Rational {
        top:    Int = (self.top * rhs.bottom) + (rhs.top * self.bottom);
        bottom: Int = self.bottom * rhs.bottom;

        Rational { top, bottom }
    }
}

const example_rational = Rational { 7, 21 }

const result: Rational = example_rational.add(example_rational)
</code></pre>
<p>Methods are accessed using a <code>.</code> (i.e. a dot). Methods cannot modify <code>self</code> as all Helios values are immutable (instead they should return new instantations of the own type).</p>
<blockquote>
<p><strong>Note:</strong> <code>self</code> is a reserved word and can only be used for the first argument of a method. The <code>self</code> argument can't have a type annotation and is always implicitely typed.</p>
</blockquote>
<h2 id="methods-can-be-used-as-values"><a class="header" href="#methods-can-be-used-as-values">Methods can be used as values</a></h2>
<p>A method is syntactic sugar for a <strong>curried function</strong> (a function that returns a function) that takes <code>self</code> as it's first argument:</p>
<pre><code class="language-helios">// the following:
rational_1.add(rational_2); ...
// desugars into: __user__Rational_add(rational_1)(rational_2)
//  of type (Rational) -&gt; (Rational) -&gt; Rational
</code></pre>
<p>A method value is a function, and can be seen as a closure over <code>self</code>:</p>
<pre><code class="language-helios">// 'rational_1.add' returns a function of type ((Rational) -&gt; Rational) 
//   which can be used just like any other function value
add_to_rational_1: (Rational) -&gt; Rational = rational_1.add; ...

// Note: add_to_rational_1(rational_2) == rational_1.add(rational_2)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="associated-functions-and-constants"><a class="header" href="#associated-functions-and-constants">Associated functions and constants</a></h1>
<p>Associated functions (aka <em>static methods</em>) and constants are just like regular functions or constants but are also namespaced by a type, for example <code>Rational::new(top, bottom)</code>.</p>
<h2 id="defining-associated-functions-and-constants"><a class="header" href="#defining-associated-functions-and-constants">Defining associated functions and constants</a></h2>
<p>Associated functions are defined just like methods but without the <code>self</code> argument. Associated constants are simply <code>const</code> statements inside a <code>struct</code> or <code>enum</code> block:</p>
<pre><code class="language-helios">struct Rational {
    top:    Int
    bottom: Int

	// associated const
	const PI = Rational { 355, 113 }

	// associated function
	func new(top: Int, bottom: Int) -&gt; Rational {
		Rational { top, bottom }
	}
}
</code></pre>
<h2 id="using-associated-functions-and-constants"><a class="header" href="#using-associated-functions-and-constants">Using associated functions and constants</a></h2>
<p>Associated functions and constants are <em>namespaced</em> by the type they are associated with
and can be referenced using a double colon (<code>::</code>) just like in Rust.
For example:</p>
<pre><code class="language-helios">half: Rational = Rational::new(1, 2); ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="automatic-methods"><a class="header" href="#automatic-methods">Automatic methods</a></h1>
<p>The following (associated) methods and operators are automatically defined on all user and builtin types (except function types).</p>
<h2 id="-"><a class="header" href="#-"><code>==</code>, <code>!=</code></a></h2>
<p>The equality and inequality operators are automatically defined on every type (except function types).</p>
<h2 id="copy"><a class="header" href="#copy"><code>copy</code></a></h2>
<p>Instantiates a copy of the underlying value, with some of the fields changed.</p>
<p>This method has the same number of arguments as the number of fields in the user-defined <code>struct</code> or <code>enum</code>-variant. Each argument of <code>copy</code> has the same name as the corresponding field and is optional (see <a href="lang/./functions/named_arguments.html">named arguments</a>).</p>
<pre><code class="language-helios">struct Pair {
    first:  Int
    second: Int
}

...

pair = Pair{1, 2};

pair.copy(second: 3) // == Pair{1, 3}
</code></pre>
<h2 id="from_data"><a class="header" href="#from_data"><code>from_data</code></a></h2>
<p><code>from_data</code> is an <a href="lang/./associated-functions-and-constants.html">associated function</a> that is automatically defined on every user-type, and thus <code>from_data</code> is a reserved name that can't be used for other methods.</p>
<p><code>from_data</code> converts a typeless <code>Data</code> into something typed.</p>
<pre><code class="language-helios">MyType::from_data(data: Data) -&gt; MyType
</code></pre>
<h2 id="serialize"><a class="header" href="#serialize"><code>serialize</code></a></h2>
<p>The <code>serialize</code> method is automatically defined on every user-type, and thus <code>serialize</code> is a reserved name that can't be used for other methods.</p>
<p><code>serialize</code> serializes the underlying data using cbor encoding.</p>
<pre><code class="language-helios">my_instance.serialize() -&gt; ByteArray
</code></pre>
<blockquote>
<p><strong>Note</strong>: when debugging you can inspect the output of <code>print(my_data.serialize().show())</code> using <a href="https://cbor.nemo157.com">this cbor tool</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>The following is a complete example of a struct with both associated functions and regular methods.</p>
<h1 id="example-rational"><a class="header" href="#example-rational">Example: <code>Rational</code></a></h1>
<pre><code class="language-helios">struct Rational {
    top:    Int
    bottom: Int

    // associated const
    const PI = Rational{ 355, 113 }

    // associated function
    func new(top: Int, bottom: Int) -&gt; Rational {
        Rational { top, bottom }
    }

    // regular method
    func add(self, rhs: Rational) -&gt; Rational {
        top:    Int = (self.top * rhs.bottom) + (rhs.top * self.bottom);
        bottom: Int = self.bottom * rhs.bottom;

        Rational { top, bottom }
    }

}

const rational_1 = Rational::PI // 355/113 or 3.14159...
const rational_2 = Rational::new(1, 2) // 1/2 or 0.5
const rational_3: Rational = rational_1.add(rational_2) // 823/226 or 3.64159...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structure-of-a-script"><a class="header" href="#structure-of-a-script">Structure of a script</a></h1>
<p>Helios validator scripts have a function called <code>main</code> that returns a boolean (<code>true</code>  or <code>false</code>) when validating the spending of a UTxO. </p>
<p>For a spending validator, <code>main</code> takes three arguments:</p>
<ul>
<li><code>Datum</code>: data stored on-chain that is linked to the locked UTxO (not avaiable for minting/staking scripts)</li>
<li><code>Redeemer</code>: data specified by the user attempting to spend the locked UTxO</li>
<li><a href="lang/./builtins/scriptcontext.html"><code>ScriptContext</code></a>: information about the transaction spending the locked UTxO</li>
</ul>
<p><code>Datum</code> and <code>Redeemer</code> are user-defined but <a href="lang/./builtins/scriptcontext.html"><code>ScriptContext</code></a> is a builtin type.</p>
<p>The structure of a validator script looks as follows:</p>
<pre><code class="language-helios">// --- (1) ---
spending my_validator       

// --- (2) ---
struct Datum {..}           

// --- (3) ---
enum Redeemer {..}          
                            
// --- (4) ---
func main(datum: Datum, redeemer: Redeemer, ctx: ScriptContext) -&gt; Bool {
    ...                  
}

// --- (5) ---
const MY_DATUM = Datum {...}
</code></pre>
<h2 id="script-purpose-1"><a class="header" href="#script-purpose-1">Script purpose (1)</a></h2>
<p>In Helios all scripts start with a  <strong>script purpose</strong>, followed by the name of the script. There are 5 script purposes:</p>
<ul>
<li><strong>spending</strong></li>
<li><strong>minting</strong></li>
<li><strong>staking</strong></li>
<li><strong>testing</strong></li>
<li><strong>module</strong></li>
</ul>
<p>On this page we are only concerned with the <code>spending</code> script purpose:</p>
<pre><code class="language-helios">spending my_validator

...
</code></pre>
<p><code>module</code> is covered in the <a href="lang/./modules.html">next section</a>.</p>
<p><code>minting</code>, <code>staking</code> and <code>testing</code> will be covered in the <a href="lang/./advanced-concepts/index.html">advanced concepts</a> chapter.</p>
<blockquote>
<p><strong>Note</strong>: the name of each Helios source is registered in the global scope, so these names can't be used by statements, nor for the lhs of assignments. So eg. the entrypoint script can't be named <code>main</code> as that would conflict with the entrypoint function.</p>
</blockquote>
<h2 id="datum-2"><a class="header" href="#datum-2">Datum (2)</a></h2>
<p>Each UTxO locked at a script address will also have an associated datum. The script can choose to use the datum as part of the spending validation, or it can choose to ignore the datum if it is irrelevant.</p>
<p>If the script uses the datum then a <code>struct</code> or <code>enum</code> must be defined above <code>main</code> that is named <code>Datum</code>.</p>
<h2 id="redeemer-3"><a class="header" href="#redeemer-3">Redeemer (3)</a></h2>
<p>Each UTxO used as an input for a transaction also has a redeemer attached. This is data specified by the user attempting to spend that UTxO. The script can again choose to use or ignore the redeemer during validation.</p>
<p>If the script uses the redeemer then a <code>struct</code> or <code>enum</code> must be defined above <code>main</code> that is named <code>Redeemer</code>.</p>
<h2 id="main-function-4"><a class="header" href="#main-function-4"><code>main</code> function (4)</a></h2>
<p>The <code>main</code> function (4) of a validator script accepts up to three optional arguments and returns a <code>Bool</code>:</p>
<ul>
<li><strong>datum (2)</strong></li>
<li><strong>redeemer (3)</strong></li>
<li><strong>script context</strong></li>
</ul>
<p>Each <code>main</code> argument must appear in that order, but can be ignored with an underscore (<code>_</code>).</p>
<pre><code class="language-helios">spending my_validator

...

// redeemer is ignored
func main(datum: Datum, _, context: ScriptContext) -&gt; Bool {
    ...
}

...
</code></pre>
<p>Most of the data needed for writing useful validators is contained in the <a href="lang/./builtins/scriptcontext.html"><code>ScriptContext</code></a>.</p>
<blockquote>
<p><strong>Note</strong>: The datum and the redeemer are user-defined types (structs or enums) that currently <strong>must</strong> be named <code>Datum</code> and <code>Redeemer</code>.</p>
</blockquote>
<h2 id="data-generators-and-test-functions-5"><a class="header" href="#data-generators-and-test-functions-5">Data generators and test functions (5)</a></h2>
<p>After the <code>main</code> function you can define functions and constants for:</p>
<ul>
<li>generating data structures (eg. datums or redeemers)</li>
<li>testing the <code>main</code> function</li>
</ul>
<p>The <a href="lang/../api/index.html">API</a> has special functionality for working with these:</p>
<ul>
<li><a href="lang/../api/reference/program.html#parameters"><code>program.parameters</code></a> an object that evaluates/sets any top-level constant in a Helios source</li>
</ul>
<p>Some compiler restrictions are lifted in this part of the script:</p>
<ul>
<li>not all names need to be used (relevant for function arguments and assignments)</li>
<li>structs can be empty</li>
</ul>
<p>Special constructors, that aren't available in <code>main</code>, become available in this part of the script:</p>
<ul>
<li><a href="lang/./builtins/scriptcontext.html#new_certifying"><code>ScriptContext::new_certifying</code></a></li>
<li><a href="lang/./builtins/scriptcontext.html#new_minting"><code>ScriptContext::new_minting</code></a></li>
<li><a href="lang/./builtins/scriptcontext.html#new_rewarding"><code>ScriptContext::new_rewarding</code></a></li>
<li><a href="lang/./builtins/scriptcontext.html#new_spending"><code>ScriptContext::new_spending</code></a></li>
<li><a href="lang/./builtins/tx.html#new"><code>Tx::new</code></a></li>
<li><a href="lang/./builtins/txinput.html#new"><code>TxInput::new</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>The following example is the most trivial possible script.</p>
<h2 id="example-always_succeeds"><a class="header" href="#example-always_succeeds">Example: <code>always_succeeds</code></a></h2>
<p>This basic script allows locked UTxOs to be spent any way the user wants:</p>
<pre><code class="language-helios">spending always_succeeds

func main(_, _, _) -&gt; Bool {
    true
}
</code></pre>
<p>You must use an underscore (<code>_</code>) for unused arguments. In this case all three arguments of <code>main</code> are ignored by using an underscore.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parameterized-contracts"><a class="header" href="#parameterized-contracts">Parameterized Contracts</a></h1>
<p>Parameterizing contracts allows dApp developers to create separate instances of a Helios program.</p>
<p>In Helios, this is done by <a href="lang/../api/reference/program.html#parameters-1"><code>re-binding</code></a> one or more top-level <code>const PARAM_NAME = ...</code> declarations.</p>
<p>After re-binding any const parameters to a different value, the resulting program will have a <strong>different contract address</strong>.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>In this example <code>OWNER</code> is a parameter.</p>
<pre><code class="language-helios">spending my_validator

const OWNER = PubKeyHash::new(#)

func main(_, _, ctx: ScriptContext) -&gt; Bool {
    ctx.tx.is_signed_by(OWNER)
}
</code></pre>
<p>The parameter can be changed before compiling to the final Uplc format:</p>
<pre><code class="language-ts">const program = helios.Program.new(src);

program.parameters.OWNER = new helios.PubKeyHash(&quot;...&quot;);

const uplcProgram = program.compile();
</code></pre>
<p><a href="lang/../api/reference/heliosdata.html">Many Helios API types</a> can be used when rebinding the parameters. Also the user-defined types are available through <a href="lang/../api/reference/program.html#types"><code>program.types</code></a>. Besides using Helios API types, Javascript primitive objects (i.e. JSON-like) can be used to re-bind a parameter in some cases.</p>
<h2 id="contrast-with-datum"><a class="header" href="#contrast-with-datum">Contrast with Datum</a></h2>
<p>Attaching Datum data structures to specific UTxOs is another way that a validator or other program can have varying behavior.</p>
<p>Using Datum causes those explicit details to be included in UTxOs (and/or in transactions consuming them). Transactions spending the UTxOs held at the same script address can each access and use those various Datum details. Noteably, any interested party can trivially query to discover all the various UTxOs held at a single contract address.</p>
<p>By contrast, two different instances of a parameterized contract, otherwise identical, will have separate addresses where UTxOs can be held.  <strong>UTxO's don't need to explicitly contain the parameter values</strong>.</p>
<p>Querying for UTxO's in separate instances of a parameterized contract is also possible, but requires the interested party to have sufficient knowledge of those separate instance addresses, or other publicly-visible attributes of the target transactions.</p>
<p>Note that any parameterized contract can <strong>also</strong> use per-UTxO Datum values, as needed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>Helios top-level statements can be placed in modules and can then be imported by other Helios sources. Modules can be made available during compile-time by including them in a list as the second argument of the <a href="lang/../api/reference/program.html"><code>Program</code> constructor</a>.</p>
<h2 id="import"><a class="header" href="#import"><code>import</code></a></h2>
<p><code>import</code> statements in Helios are similar to Javascript/Typescript:</p>
<pre><code class="language-helios">import { 
    ImportedName1 as NewName1,
    ImportedName2
} from MyModule
</code></pre>
<p>The imported names act as if the original statements were defined in the source where they are imported.</p>
<blockquote>
<p><strong>Note</strong>: currently every top-level statement is public and exported by default, including other <code>import</code> statements.</p>
</blockquote>
<h3 id="namespace-import"><a class="header" href="#namespace-import">Namespace import</a></h3>
<p>Entire modules can also be imported directly as a namespace.</p>
<pre><code class="language-helios">import MyModule

...

MyModule::MyStruct{...}
</code></pre>
<p>Namespaces can be nested:</p>
<pre><code class="language-helios">import MyModule

...

MyModule::MySubModule::MyStruct{...}
</code></pre>
<p>The <code>import {...} from ...</code> syntax can also be used to unwrap submodules:</p>
<pre><code class="language-helios">import { MySubModule as RenamedSubModule } from MyModule

...

RenamedSubModule::MyStruct{...}
</code></pre>
<h3 id="webpack"><a class="header" href="#webpack">Webpack</a></h3>
<p>When using the <a href="lang/../integrations/webpack.html">Webpack loader</a> you must use relative paths instead of module names when importing:</p>
<pre><code class="language-helios">import { 
    ImportedName1 as NewName1,
    ImportedName2
} from &quot;&lt;rel-path-to-module&gt;.hl&quot;
</code></pre>
<p>The Webpack loader currently doesn't support importing namespaces using relative paths (WiP).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builtins"><a class="header" href="#builtins">Builtins</a></h1>
<p>This section contains a reference of all the Helios builtins.</p>
<h2 id="primitive-types-1"><a class="header" href="#primitive-types-1">Primitive types</a></h2>
<ul>
<li><a href="lang/builtins/./bool.html">Bool</a></li>
<li><a href="lang/builtins/./bytearray.html">ByteArray</a></li>
<li><a href="lang/builtins/./int.html">Int</a></li>
<li><a href="lang/builtins/./real.html">Real</a></li>
<li><a href="lang/builtins/./string.html">String</a></li>
</ul>
<h2 id="container-types-1"><a class="header" href="#container-types-1">Container types</a></h2>
<ul>
<li><a href="lang/builtins/./list.html">List</a></li>
<li><a href="lang/builtins/./map.html">Map</a></li>
<li><a href="lang/builtins/./option.html">Option</a></li>
</ul>
<h2 id="money-types"><a class="header" href="#money-types">Money types</a></h2>
<ul>
<li><a href="lang/builtins/./assetclass.html">AssetClass</a> (i.e. the kind of 'currency')</li>
<li><a href="lang/builtins/./value.html">Value</a></li>
</ul>
<h2 id="time-types"><a class="header" href="#time-types">Time types</a></h2>
<ul>
<li><a href="lang/builtins/./duration.html">Duration</a> (i.e. the difference of two <code>Time</code> instances)</li>
<li><a href="lang/builtins/./time.html">Time</a></li>
<li><a href="lang/builtins/./timerange.html">TimeRange</a> (i.e. a period bound by two <code>Time</code> instances)</li>
</ul>
<h2 id="hash-and-cryptography-types"><a class="header" href="#hash-and-cryptography-types">Hash and cryptography types</a></h2>
<ul>
<li><a href="lang/builtins/./datumhash.html">DatumHash</a></li>
<li><a href="lang/builtins/./mintingpolicyhash.html">MintingPolicyHash</a></li>
<li><a href="lang/builtins/./pubkey.html">PubKey</a></li>
<li><a href="lang/builtins/./pubkeyhash.html">PubKeyHash</a></li>
<li><a href="lang/builtins/./scripthash.html">ScriptHash</a></li>
<li><a href="lang/builtins/./stakekeyhash.html">StakeKeyHash</a></li>
<li><a href="lang/builtins/./stakingvalidatorhash.html">StakingValidatorHash</a></li>
<li><a href="lang/builtins/./validatorhash.html">ValidatorHash</a></li>
</ul>
<h2 id="transaction-types"><a class="header" href="#transaction-types">Transaction types</a></h2>
<ul>
<li><a href="lang/builtins/./address.html">Address</a></li>
<li><a href="lang/builtins/./credential.html">Credential</a></li>
<li><a href="lang/builtins/./dcert.html">DCert</a></li>
<li><a href="lang/builtins/./outputdatum.html">OutputDatum</a></li>
<li><a href="lang/builtins/./scriptcontext.html">ScriptContext</a></li>
<li><a href="lang/builtins/./scriptpurpose.html">ScriptPurpose</a></li>
<li><a href="lang/builtins/./stakingcredential.html">StakingCredential</a></li>
<li><a href="lang/builtins/./stakinghash.html">StakingHash</a></li>
<li><a href="lang/builtins/./stakingpurpose.html">StakingPurpose</a></li>
<li><a href="lang/builtins/./tx.html">Tx</a></li>
<li><a href="lang/builtins/./txid.html">TxId</a></li>
<li><a href="lang/builtins/./txinput.html">TxInput</a></li>
<li><a href="lang/builtins/./txoutput.html">TxOutput</a></li>
<li><a href="lang/builtins/./txoutputid.html">TxOutputId</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="address-1"><a class="header" href="#address-1"><code>Address</code></a></h1>
<p>Represents a Cardano address.</p>
<h2 id="associated-functions"><a class="header" href="#associated-functions">Associated functions</a></h2>
<h3 id="new"><a class="header" href="#new"><code>new</code></a></h3>
<p>Construct a new <code>Address</code> from a <a href="lang/builtins/./credential.html"><code>Credential</code></a> and an optional <a href="lang/builtins/./stakingcredential.html"><code>StakingCredential</code></a>:</p>
<pre><code class="language-helios">Address::new(
    credential: Credential, 
    staking_credential: Option[StakingCredential]
) -&gt; Address
</code></pre>
<h3 id="from_data-1"><a class="header" href="#from_data-1"><code>from_data</code></a></h3>
<pre><code class="language-helios">Address::from_data(data: Data) -&gt; Address
</code></pre>
<h2 id="getters"><a class="header" href="#getters">Getters</a></h2>
<h3 id="credential"><a class="header" href="#credential"><code>credential</code></a></h3>
<p>Get the payment <a href="lang/builtins/./credential.html"><code>Credential</code></a> of an <code>Address</code>:</p>
<pre><code class="language-helios">address.credential -&gt; Credential
</code></pre>
<h3 id="staking_credential"><a class="header" href="#staking_credential"><code>staking_credential</code></a></h3>
<p>Get the <a href="lang/builtins/./stakingcredential.html"><code>StakingCredential</code></a> of an <code>Address</code>:</p>
<pre><code class="language-helios">address.staking_credential -&gt; Option[StakingCredential]
</code></pre>
<h2 id="operators-1"><a class="header" href="#operators-1">Operators</a></h2>
<h3 id=""><a class="header" href="#"><code>==</code></a></h3>
<pre><code class="language-helios">Address == Address -&gt; Bool
</code></pre>
<h3 id="-1"><a class="header" href="#-1"><code>!=</code></a></h3>
<pre><code class="language-helios">Address != Address -&gt; Bool
</code></pre>
<h2 id="methods-1"><a class="header" href="#methods-1">Methods</a></h2>
<h3 id="serialize-1"><a class="header" href="#serialize-1"><code>serialize</code></a></h3>
<pre><code class="language-helios">address.serialize() -&gt; ByteArray
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assetclass"><a class="header" href="#assetclass"><code>AssetClass</code></a></h1>
<p>Represents a unique token on the blockchain using its <a href="lang/builtins/./mintingpolicyhash.html"><code>MintingPolicyHash</code></a> and its token name (as a <a href="lang/builtins/./bytearray.html"><code>ByteArray</code></a>).</p>
<h2 id="associated-functions-and-constants-1"><a class="header" href="#associated-functions-and-constants-1">Associated functions and constants</a></h2>
<h3 id="ada"><a class="header" href="#ada"><code>ADA</code></a></h3>
<p>Lovelace <code>AssetClass</code> (empty <a href="lang/builtins/./mintingpolicyhash.html"><code>MintingPolicyHash</code></a> and empty token name <a href="lang/builtins/./bytearray.html"><code>ByteArray</code></a>):</p>
<pre><code class="language-helios">AssetClass::ADA -&gt; AssetClass
</code></pre>
<h3 id="new-1"><a class="header" href="#new-1"><code>new</code></a></h3>
<p>Constructs a new <code>AssetClass</code> using a <a href="lang/builtins/./mintingpolicyhash.html"><code>MintingPolicyHash</code></a> and a token name <a href="lang/builtins/./bytearray.html"><code>ByteArray</code></a>:</p>
<pre><code class="language-helios">AssetClass::new(
    mph: MintingPolicyHash, 
    token_name: ByteArray
) -&gt; AssetClass
</code></pre>
<h3 id="from_data-2"><a class="header" href="#from_data-2"><code>from_data</code></a></h3>
<pre><code class="language-helios">AssetClass::from_data(data: Data) -&gt; AssetClass
</code></pre>
<h2 id="getters-1"><a class="header" href="#getters-1">Getters</a></h2>
<h3 id="mph"><a class="header" href="#mph"><code>mph</code></a></h3>
<pre><code class="language-helios">asset_class.mph -&gt; MintingPolicyHash
</code></pre>
<h3 id="token_name"><a class="header" href="#token_name"><code>token_name</code></a></h3>
<pre><code class="language-helios">asset_class.token_name -&gt; ByteArray
</code></pre>
<h2 id="operators-2"><a class="header" href="#operators-2">Operators</a></h2>
<h3 id="-2"><a class="header" href="#-2"><code>==</code></a></h3>
<pre><code class="language-helios">AssetClass == AssetClass -&gt; Bool
</code></pre>
<h3 id="-3"><a class="header" href="#-3"><code>!=</code></a></h3>
<pre><code class="language-helios">AssetClass != AssetClass -&gt; Bool
</code></pre>
<h2 id="methods-2"><a class="header" href="#methods-2">Methods</a></h2>
<h3 id="serialize-2"><a class="header" href="#serialize-2"><code>serialize</code></a></h3>
<pre><code class="language-helios">asset_class.serialize() -&gt; ByteArray
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bool-1"><a class="header" href="#bool-1"><code>Bool</code></a></h1>
<p>Represents a boolean value (<code>true</code>/<code>false</code>).</p>
<pre><code class="language-helios">bool_true  = true;
bool_false = false; ...
</code></pre>
<h2 id="associated-functions-1"><a class="header" href="#associated-functions-1">Associated functions</a></h2>
<h3 id="and"><a class="header" href="#and"><code>and</code></a></h3>
<p>Doesn't evaluate the second argument if the first argument evaluates to <code>false</code>.</p>
<pre><code class="language-helios">Bool::and(fn_a: () -&gt; Bool, fn_b: () -&gt; Bool) -&gt; Bool
</code></pre>
<h3 id="or"><a class="header" href="#or"><code>or</code></a></h3>
<p>Doesn't evaluate the second argument if the first argument evaluates to <code>true</code>.</p>
<pre><code class="language-helios">Bool::or(fn_a: () -&gt; Bool, fn_b: () -&gt; Bool) -&gt; Bool
</code></pre>
<h3 id="from_data-3"><a class="header" href="#from_data-3"><code>from_data</code></a></h3>
<pre><code class="language-helios">Bool::from_data(data: Data) -&gt; Bool
</code></pre>
<h2 id="operators-3"><a class="header" href="#operators-3">Operators</a></h2>
<h3 id="-4"><a class="header" href="#-4"><code>!</code></a></h3>
<p>Boolean <strong>not</strong> operator.</p>
<pre><code class="language-helios">!Bool -&gt; Bool
</code></pre>
<h3 id="-5"><a class="header" href="#-5"><code>==</code></a></h3>
<pre><code class="language-helios">Bool == Bool -&gt; Bool
</code></pre>
<h3 id="-6"><a class="header" href="#-6"><code>!=</code></a></h3>
<p>The boolean inequality operator can also be used as an <strong>xor</strong> operator.</p>
<pre><code class="language-helios">Bool != Bool -&gt; Bool
</code></pre>
<h3 id="-7"><a class="header" href="#-7"><code>&amp;&amp;</code></a></h3>
<p>Boolean <strong>and</strong> operator. Right argument is only evaluated if left argument is <code>true</code>.</p>
<p>Internally left and right arguments are wrapped with anonymous functions and <code>Bool::and</code> is called.</p>
<pre><code class="language-helios">Bool &amp;&amp; Bool -&gt; Bool
</code></pre>
<h3 id="-8"><a class="header" href="#-8"><code>||</code></a></h3>
<p>Boolean <strong>or</strong> operator. Right argument is only evaluated if left argument is <code>false</code>.</p>
<p>Internally left and right arguments are wrapped with anonymous functions and <code>Bool::or</code> is called.</p>
<pre><code class="language-helios">Bool || Bool -&gt; Bool
</code></pre>
<h2 id="methods-3"><a class="header" href="#methods-3">Methods</a></h2>
<h3 id="serialize-3"><a class="header" href="#serialize-3"><code>serialize</code></a></h3>
<pre><code class="language-helios">bool.serialize() -&gt; ByteArray
</code></pre>
<h3 id="show"><a class="header" href="#show"><code>show</code></a></h3>
<p><code>false</code> is turned into <code>&quot;false&quot;</code>, and <code>true</code> is turned into <code>&quot;true&quot;</code>.</p>
<pre><code class="language-helios">bool.show() -&gt; String
</code></pre>
<h3 id="to_int"><a class="header" href="#to_int"><code>to_int</code></a></h3>
<p><code>false</code> is turned into <code>0</code>, and <code>true</code> is turned into <code>1</code>.</p>
<pre><code class="language-helios">bool.to_int() -&gt; Int
</code></pre>
<h3 id="trace"><a class="header" href="#trace"><code>trace</code></a></h3>
<p>Prints a message while returning the <code>Bool</code> value itself. This can be convenient when debugging the outcome of a script.</p>
<pre><code class="language-helios">bool.trace(msg: String) -&gt; Bool
</code></pre>
<p>The <code>msg</code> is prefixed to either <code>&quot;true&quot;</code> or <code>&quot;false&quot;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytearray-1"><a class="header" href="#bytearray-1"><code>ByteArray</code></a></h1>
<p>Represents an array of bytes (i.e. an array of uint8 numbers).</p>
<pre><code class="language-helios">byte_array = #213212; ...
</code></pre>
<blockquote>
<p><strong>Note</strong>: in Haskell/Plutus this is called a <code>ByteString</code>, but we thought that that was too ambiguous, so we chose <code>ByteArray</code> instead.</p>
</blockquote>
<h2 id="associated-functions-2"><a class="header" href="#associated-functions-2">Associated functions</a></h2>
<h3 id="from_data-4"><a class="header" href="#from_data-4"><code>from_data</code></a></h3>
<pre><code class="language-helios">ByteArray::from_data(data: Data) -&gt; ByteArray
</code></pre>
<h2 id="getters-2"><a class="header" href="#getters-2">Getters</a></h2>
<h3 id="length"><a class="header" href="#length"><code>length</code></a></h3>
<p>Returns the number of bytes in the <code>ByteArray</code>.</p>
<pre><code class="language-helios">byte_array.length -&gt; Int 
</code></pre>
<h2 id="operators-4"><a class="header" href="#operators-4">Operators</a></h2>
<h3 id="-9"><a class="header" href="#-9"><code>==</code></a></h3>
<pre><code class="language-helios">ByteArray == ByteArray -&gt; Bool
</code></pre>
<h3 id="-10"><a class="header" href="#-10"><code>!=</code></a></h3>
<pre><code class="language-helios">ByteArray != ByteArray -&gt; Bool
</code></pre>
<h3 id="-11"><a class="header" href="#-11"><code>&gt;=</code></a></h3>
<pre><code class="language-helios">ByteArray &gt;= ByteArray -&gt; Bool
</code></pre>
<h3 id="-12"><a class="header" href="#-12"><code>&gt;</code></a></h3>
<p>The lhs is greater-than the rhs if the first rhs byte, that isn't equal to the corresponding lhs byte, is smaller than that byte. Returns true if all common bytes are equal, but the rhs is shorter than the lhs.</p>
<pre><code class="language-helios">ByteArray &gt; ByteArray -&gt; Bool
</code></pre>
<h3 id="-13"><a class="header" href="#-13"><code>&lt;=</code></a></h3>
<pre><code class="language-helios">ByteArray &lt;= ByteArray -&gt; Bool
</code></pre>
<h3 id="-14"><a class="header" href="#-14"><code>&lt;</code></a></h3>
<p>The lhs is less-than the rhs if the first rhs byte, that isn't equal to the corresponding lhs byte, is greater than that byte. Returns false if the rhs is empty.</p>
<pre><code class="language-helios">ByteArray &lt; ByteArray -&gt; Bool
</code></pre>
<h3 id="-15"><a class="header" href="#-15"><code>+</code></a></h3>
<p>Concatenation of two <code>ByteArray</code>s.</p>
<pre><code class="language-helios">ByteArray + ByteArray -&gt; ByteArray
</code></pre>
<h2 id="methods-4"><a class="header" href="#methods-4">Methods</a></h2>
<h3 id="blake2b"><a class="header" href="#blake2b"><code>blake2b</code></a></h3>
<p>Calculates the blake2b-256 hash of a <code>ByteArray</code>. The result is 32 bytes long.</p>
<pre><code class="language-helios">byte_array.blake2b() -&gt; ByteArray
</code></pre>
<h3 id="decode_utf8"><a class="header" href="#decode_utf8"><code>decode_utf8</code></a></h3>
<p>Turns a valid sequence of utf-8 bytes into a <code>String</code>. Throws an error if the <code>ByteArray</code> isn't valid utf-8.</p>
<pre><code class="language-helios">byte_array.decode_utf8() -&gt; String
</code></pre>
<h3 id="ends_with"><a class="header" href="#ends_with"><code>ends_with</code></a></h3>
<p>Checks if a <code>ByteArray</code> ends with a given suffix.</p>
<pre><code class="language-helios">byte_array.ends_with(suffix: ByteArray) -&gt; Bool
</code></pre>
<h3 id="prepend"><a class="header" href="#prepend"><code>prepend</code></a></h3>
<p>Prepends an <code>Int</code> byte, returning a new <code>ByteArray</code>.</p>
<p>Modulo 256 is applied internally to the byte before prepending.</p>
<pre><code class="language-helios">byte_array.prepend(byte: Int) -&gt; ByteArray
</code></pre>
<h3 id="serialize-4"><a class="header" href="#serialize-4"><code>serialize</code></a></h3>
<pre><code class="language-helios">byte_array.serialize() -&gt; ByteArray
</code></pre>
<h3 id="sha2"><a class="header" href="#sha2"><code>sha2</code></a></h3>
<p>Calculates the sha2-256 hash of a <code>ByteArray</code>. The result is 32 bytes long.</p>
<pre><code class="language-helios">byte_array.sha2() -&gt; ByteArray
</code></pre>
<h3 id="sha3"><a class="header" href="#sha3"><code>sha3</code></a></h3>
<p>Calculates the sha3-256 hash of a <code>ByteArray</code>. The result is 32 bytes long.</p>
<pre><code class="language-helios">byte_array.sha3() -&gt; ByteArray
</code></pre>
<h3 id="show-1"><a class="header" href="#show-1"><code>show</code></a></h3>
<p>Converts a <code>ByteArray</code> into its hexadecimal representation.</p>
<pre><code class="language-helios">byte_array.show() -&gt; String
</code></pre>
<h3 id="slice"><a class="header" href="#slice"><code>slice</code></a></h3>
<pre><code class="language-helios">byte_array.slice(start: Int, end: Int) -&gt; ByteArray
</code></pre>
<h3 id="starts_with"><a class="header" href="#starts_with"><code>starts_with</code></a></h3>
<p>Checks if a <code>ByteArray</code> starts with a given prefix.</p>
<pre><code class="language-helios">byte_array.starts_with(prefix: ByteArray) -&gt; Bool
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="credential-1"><a class="header" href="#credential-1"><code>Credential</code></a></h1>
<p>Represents the non-staking part of an <a href="lang/builtins/./address.html"><code>Address</code></a>. Internally represented as an enum with two variants: </p>
<ul>
<li><code>PubKey</code> (wraps <a href="lang/builtins/./pubkeyhash.html"><code>PubKeyHash</code></a>) </li>
<li><code>Validator</code> (wraps <a href="lang/builtins/./validatorhash.html"><code>ValidatorHash</code></a>)</li>
</ul>
<br/>
<p>Example instantiation:</p>
<pre><code class="language-helios">pubkey_credential: Credential::PubKey = Credential::new_pubkey(PubKeyHash::new(#...));

validator_credential: Credential::Validator = Credential::new_validator(ValidatorHash::new(#...)); ...
</code></pre>
<h2 id="associated-functions-3"><a class="header" href="#associated-functions-3">Associated functions</a></h2>
<h3 id="new_pubkey"><a class="header" href="#new_pubkey"><code>new_pubkey</code></a></h3>
<pre><code class="language-helios">Credential::new_pubkey(pkh: PubKeyHash) -&gt; Credential::PubKey
</code></pre>
<h3 id="new_validator"><a class="header" href="#new_validator"><code>new_validator</code></a></h3>
<pre><code class="language-helios">Credential::new_validator(vh: ValidatorHash) -&gt; Credential::Validator
</code></pre>
<h3 id="from_data-5"><a class="header" href="#from_data-5"><code>from_data</code></a></h3>
<pre><code class="language-helios">Credential::from_data(data: Data) -&gt; Credential
</code></pre>
<h2 id="getters-3"><a class="header" href="#getters-3">Getters</a></h2>
<h3 id="hash"><a class="header" href="#hash"><code>hash</code></a></h3>
<p>Get the underlying hash.</p>
<pre><code class="language-helios">pubkey_credential.hash -&gt; PubKeyHash

validator_credential.hash -&gt; ValidatorHash
</code></pre>
<h2 id="operators-5"><a class="header" href="#operators-5">Operators</a></h2>
<h3 id="-16"><a class="header" href="#-16"><code>==</code></a></h3>
<pre><code class="language-helios">Credential == Credential -&gt; Bool
</code></pre>
<h3 id="-17"><a class="header" href="#-17"><code>!=</code></a></h3>
<pre><code class="language-helios">Credential != Credential -&gt; Bool
</code></pre>
<h2 id="methods-5"><a class="header" href="#methods-5">Methods</a></h2>
<h3 id="serialize-5"><a class="header" href="#serialize-5"><code>serialize</code></a></h3>
<pre><code class="language-helios">credential.serialize() -&gt; ByteArray
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-1"><a class="header" href="#data-1"><code>Data</code></a></h1>
<p>Represents type-less data, as returned by the <a href="lang/builtins/./outputdatum.html#inline"><code>OutputDatum::Inline inline</code></a> getter. Can be cast directly into any other type using <code>from_data</code>, or indirectly using <a href="lang/builtins/../enums.html#data"><code>switch</code></a>.</p>
<h2 id="getters-4"><a class="header" href="#getters-4">Getters</a></h2>
<h3 id="tag"><a class="header" href="#tag"><code>tag</code></a></h3>
<p>Gets tag index of <code>ConstrData</code>. Throws an error if not <code>ConstrData</code>.</p>
<pre><code class="language-helios">data.tag -&gt; Int
</code></pre>
<h2 id="operators-6"><a class="header" href="#operators-6">Operators</a></h2>
<h3 id="-18"><a class="header" href="#-18"><code>==</code></a></h3>
<pre><code class="language-helios">Data == Data -&gt; Bool
</code></pre>
<h3 id="-19"><a class="header" href="#-19"><code>!=</code></a></h3>
<pre><code class="language-helios">Data != Data -&gt; Bool
</code></pre>
<h2 id="methods-6"><a class="header" href="#methods-6">Methods</a></h2>
<h3 id="serialize-6"><a class="header" href="#serialize-6"><code>serialize</code></a></h3>
<pre><code class="language-helios">data.serialize() -&gt; ByteArray
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="datumhash"><a class="header" href="#datumhash"><code>DatumHash</code></a></h1>
<p><a href="https://en.wikipedia.org/wiki/Opaque_data_type">Opaque</a> <a href="lang/builtins/./bytearray.html"><code>ByteArray</code></a> that represents the hash of a datum.</p>
<h2 id="associated-functions-4"><a class="header" href="#associated-functions-4">Associated functions</a></h2>
<h3 id="new-2"><a class="header" href="#new-2"><code>new</code></a></h3>
<pre><code class="language-helios">DatumHash::new(bytes: ByteArray) -&gt; DatumHash
</code></pre>
<h3 id="from_data-6"><a class="header" href="#from_data-6"><code>from_data</code></a></h3>
<pre><code class="language-helios">DatumHash::from_data(data: Data) -&gt; DatumHash
</code></pre>
<h2 id="operators-7"><a class="header" href="#operators-7">Operators</a></h2>
<h3 id="-20"><a class="header" href="#-20"><code>==</code></a></h3>
<pre><code class="language-helios">DatumHash == DatumHash -&gt; Bool
</code></pre>
<h3 id="-21"><a class="header" href="#-21"><code>!=</code></a></h3>
<pre><code class="language-helios">DatumHash != DatumHash -&gt; Bool
</code></pre>
<h3 id="-22"><a class="header" href="#-22"><code>&gt;=</code></a></h3>
<pre><code class="language-helios">DatumHash &gt;= DatumHash -&gt; Bool
</code></pre>
<h3 id="-23"><a class="header" href="#-23"><code>&gt;</code></a></h3>
<pre><code class="language-helios">DatumHash &gt; DatumHash -&gt; Bool
</code></pre>
<h3 id="-24"><a class="header" href="#-24"><code>&lt;=</code></a></h3>
<pre><code class="language-helios">DatumHash &lt;= DatumHash -&gt; Bool
</code></pre>
<h3 id="-25"><a class="header" href="#-25"><code>&lt;</code></a></h3>
<pre><code class="language-helios">DatumHash &lt; DatumHash -&gt; Bool
</code></pre>
<h2 id="methods-7"><a class="header" href="#methods-7">Methods</a></h2>
<h3 id="serialize-7"><a class="header" href="#serialize-7"><code>serialize</code></a></h3>
<pre><code class="language-helios">datum_hash.serialize() -&gt; ByteArray
</code></pre>
<h3 id="show-2"><a class="header" href="#show-2"><code>show</code></a></h3>
<p>Hexadecimal representation of a <code>DatumHash</code>.</p>
<pre><code class="language-helios">datum_hash.show() -&gt; String
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dcert"><a class="header" href="#dcert"><code>DCert</code></a></h1>
<p>Represents an enum of staking related actions:</p>
<ul>
<li><code>Register</code>: register a <code>StakingCredential</code></li>
<li><code>Deregister</code>: deregister a <code>StakingCredential</code></li>
<li><code>Delegate</code>: delegate a <code>StakingCredential</code> to a pool</li>
<li><code>RegisterPool</code>: register a pool</li>
<li><code>RetirePool</code>: deregister a pool</li>
</ul>
<h2 id="associated-functions-5"><a class="header" href="#associated-functions-5">Associated functions</a></h2>
<h3 id="from_data-7"><a class="header" href="#from_data-7"><code>from_data</code></a></h3>
<pre><code class="language-helios">DCert::from_data(data: Data) -&gt; DCert
</code></pre>
<h3 id="new_register"><a class="header" href="#new_register"><code>new_register</code></a></h3>
<pre><code class="language-helios">DCert::new_register(credential: StakingCredential) -&gt; DCert::Register
</code></pre>
<h3 id="new_deregister"><a class="header" href="#new_deregister"><code>new_deregister</code></a></h3>
<pre><code class="language-helios">DCert::new_deregister(credential: StakingCredential) -&gt; DCert::Deregister
</code></pre>
<h3 id="new_delegate"><a class="header" href="#new_delegate"><code>new_delegate</code></a></h3>
<pre><code class="language-helios">DCert::new_delegate(
	delegator: StakingCredential, 
	pool_id: PubKeyHash
) -&gt; DCert::Delegate
</code></pre>
<h3 id="new_register_pool"><a class="header" href="#new_register_pool"><code>new_register_pool</code></a></h3>
<pre><code class="language-helios">DCert::new_register_pool(
	pool_id: PubKeyHash, 
	pool_vfr: PubKeyHash
) -&gt; DCert::RegisterPool
</code></pre>
<h3 id="new_retire_pool"><a class="header" href="#new_retire_pool"><code>new_retire_pool</code></a></h3>
<pre><code class="language-helios">DCert::new_retire_pool(
	pool_id: PubKeyHash, 
	epoch: Int
) -&gt; DCert::RetirePool
</code></pre>
<h2 id="getters-5"><a class="header" href="#getters-5">Getters</a></h2>
<h3 id="dcertregister"><a class="header" href="#dcertregister"><code>DCert::Register</code></a></h3>
<h4 id="credential-2"><a class="header" href="#credential-2"><code>credential</code></a></h4>
<pre><code class="language-helios">register_dcert.credential -&gt; StakingCredential
</code></pre>
<h3 id="dcertderegister"><a class="header" href="#dcertderegister"><code>DCert::Deregister</code></a></h3>
<h4 id="credential-3"><a class="header" href="#credential-3"><code>credential</code></a></h4>
<pre><code class="language-helios">deregister_dcert.credential -&gt; StakingCredential
</code></pre>
<h3 id="dcertdelegate"><a class="header" href="#dcertdelegate"><code>DCert::Delegate</code></a></h3>
<h4 id="delegator"><a class="header" href="#delegator"><code>delegator</code></a></h4>
<pre><code class="language-helios">delegate_dcert.delegator -&gt; StakingCredential
</code></pre>
<h4 id="pool_id"><a class="header" href="#pool_id"><code>pool_id</code></a></h4>
<pre><code class="language-helios">delegate_dcert.pool_id -&gt; PubKeyHash
</code></pre>
<h3 id="dcertregisterpool"><a class="header" href="#dcertregisterpool"><code>DCert::RegisterPool</code></a></h3>
<h4 id="pool_id-1"><a class="header" href="#pool_id-1"><code>pool_id</code></a></h4>
<pre><code class="language-helios">register_pool_dcert.pool_id -&gt; PubKeyHash
</code></pre>
<h4 id="pool_vrf"><a class="header" href="#pool_vrf"><code>pool_vrf</code></a></h4>
<pre><code class="language-helios">register_pool_dcert.pool_vrf -&gt; PubKeyHash
</code></pre>
<h3 id="dcertretirepool"><a class="header" href="#dcertretirepool"><code>DCert::RetirePool</code></a></h3>
<h4 id="pool_id-2"><a class="header" href="#pool_id-2"><code>pool_id</code></a></h4>
<pre><code class="language-helios">retire_pool_dcert.pool_id -&gt; PubKeyHash
</code></pre>
<h4 id="epoch"><a class="header" href="#epoch"><code>epoch</code></a></h4>
<pre><code class="language-helios">retire_pool_dcert.epoch -&gt; Int
</code></pre>
<h2 id="operators-8"><a class="header" href="#operators-8">Operators</a></h2>
<h3 id="-26"><a class="header" href="#-26"><code>==</code></a></h3>
<pre><code class="language-helios">DCert == DCert -&gt; Bool
</code></pre>
<h3 id="-27"><a class="header" href="#-27"><code>!=</code></a></h3>
<pre><code class="language-helios">DCert != DCert -&gt; Bool
</code></pre>
<h2 id="methods-8"><a class="header" href="#methods-8">Methods</a></h2>
<h3 id="serialize-8"><a class="header" href="#serialize-8"><code>serialize</code></a></h3>
<pre><code class="language-helios">dcert.serialize() -&gt; ByteArray
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="duration"><a class="header" href="#duration"><code>Duration</code></a></h1>
<p>The difference of two <a href="lang/builtins/./time.html"><code>Time</code></a> values is a <code>Duration</code> value. Only a <code>Duration</code> can be added to a <a href="lang/builtins/./time.html"><code>Time</code></a> (two <a href="lang/builtins/./time.html"><code>Time</code></a> values can't be added).</p>
<h2 id="associated-functions-and-constants-2"><a class="header" href="#associated-functions-and-constants-2">Associated functions and constants</a></h2>
<h3 id="new-3"><a class="header" href="#new-3"><code>new</code></a></h3>
<p>Instantiate a <code>Duration</code> from a number of milliseconds.</p>
<pre><code class="language-helios">Duration::new(milliseconds: Int) -&gt; Duration
</code></pre>
<h3 id="from_data-8"><a class="header" href="#from_data-8"><code>from_data</code></a></h3>
<pre><code class="language-helios">Duration::from_data(data: Data) -&gt; Duration
</code></pre>
<h3 id="second"><a class="header" href="#second"><code>SECOND</code></a></h3>
<p>1000 milliseconds.</p>
<pre><code class="language-helios">Duration::SECOND -&gt; Duration
</code></pre>
<h3 id="minute"><a class="header" href="#minute"><code>MINUTE</code></a></h3>
<p>60000 milliseconds.</p>
<pre><code class="language-helios">Duration::MINUTE -&gt; Duration
</code></pre>
<h3 id="hour"><a class="header" href="#hour"><code>HOUR</code></a></h3>
<p>3600000 milliseconds.</p>
<pre><code class="language-helios">Duration::HOUR -&gt; Duration
</code></pre>
<h3 id="day"><a class="header" href="#day"><code>DAY</code></a></h3>
<p>86400000 milliseconds.</p>
<pre><code class="language-helios">Duration::DAY -&gt; Duration
</code></pre>
<h3 id="week"><a class="header" href="#week"><code>WEEK</code></a></h3>
<p>604800000 milliseconds.</p>
<pre><code class="language-helios">Duration::WEEK -&gt; Duration
</code></pre>
<h2 id="operators-9"><a class="header" href="#operators-9">Operators</a></h2>
<h3 id="-28"><a class="header" href="#-28"><code>==</code></a></h3>
<pre><code class="language-helios">Duration == Duration -&gt; Bool
</code></pre>
<h3 id="-29"><a class="header" href="#-29"><code>!=</code></a></h3>
<pre><code class="language-helios">Duration != Duration -&gt; Bool
</code></pre>
<h3 id="-30"><a class="header" href="#-30"><code>&gt;=</code></a></h3>
<pre><code class="language-helios">Duration &gt;= Duration -&gt; Bool
</code></pre>
<h3 id="-31"><a class="header" href="#-31"><code>&gt;</code></a></h3>
<pre><code class="language-helios">Duration &gt; Duration -&gt; Bool
</code></pre>
<h3 id="-32"><a class="header" href="#-32"><code>&lt;=</code></a></h3>
<pre><code class="language-helios">Duration &lt;= Duration -&gt; Bool
</code></pre>
<h3 id="-33"><a class="header" href="#-33"><code>&lt;</code></a></h3>
<pre><code class="language-helios">Duration &lt; Duration -&gt; Bool
</code></pre>
<h3 id="-34"><a class="header" href="#-34"><code>+</code></a></h3>
<pre><code class="language-helios">Duration + Duration -&gt; Duration
</code></pre>
<h3 id="--1"><a class="header" href="#--1"><code>-</code></a></h3>
<pre><code class="language-helios">Duration - Duration -&gt; Duration
</code></pre>
<h3 id="-35"><a class="header" href="#-35"><code>*</code></a></h3>
<pre><code class="language-helios">Duration * Int -&gt; Duration
</code></pre>
<h3 id="-36"><a class="header" href="#-36"><code>/</code></a></h3>
<p>A <code>Duration</code> divided by a <code>Duration</code> is an <a href="lang/builtins/./int.html"><code>Int</code></a>.</p>
<pre><code class="language-helios">Duration / Duration -&gt; Int
</code></pre>
<p>A <code>Duration</code> divided by an <a href="lang/builtins/./int.html"><code>Int</code></a> is a <code>Duration</code>.</p>
<pre><code class="language-helios">Duration / Int -&gt; Duration
</code></pre>
<h3 id="-37"><a class="header" href="#-37"><code>%</code></a></h3>
<p>Modulo operator that calculates remainder upon division.</p>
<pre><code class="language-helios">Duration % Duration -&gt; Duration
</code></pre>
<h2 id="methods-9"><a class="header" href="#methods-9">Methods</a></h2>
<h3 id="serialize-9"><a class="header" href="#serialize-9"><code>serialize</code></a></h3>
<pre><code class="language-helios">duration.serialize() -&gt; ByteArray
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="int-1"><a class="header" href="#int-1"><code>Int</code></a></h1>
<p>This is an unbounded integer (like Haskell's <code>Integer</code> type).</p>
<h2 id="associated-functions-6"><a class="header" href="#associated-functions-6">Associated functions</a></h2>
<h3 id="from_base58"><a class="header" href="#from_base58"><code>from_base58</code></a></h3>
<p>Decodes a <a href="lang/builtins/./string.html"><code>String</code></a> representing a <a href="https://en.wikipedia.org/wiki/Binary-to-text_encoding#Base58">base58</a> encoded <code>Int</code>.</p>
<p>Throws an error if the string contains an invalid character.</p>
<pre><code class="language-helios">Int::from_base58(encoded: String) -&gt; Int
</code></pre>
<h3 id="from_big_endian"><a class="header" href="#from_big_endian"><code>from_big_endian</code></a></h3>
<p>Converts a <a href="lang/builtins/./bytearray.html"><code>ByteArray</code></a> into an <code>Int</code>. The last byte is multiplied by <code>1</code> before adding to the sum, the second-to-last byte is multiplied by <code>256</code> etc.</p>
<p>The returned <code>Int</code> is always positive.</p>
<pre><code class="language-helios">Int::from_big_endian(bytes: ByteArray) -&gt; Int
</code></pre>
<h3 id="from_data-9"><a class="header" href="#from_data-9"><code>from_data</code></a></h3>
<pre><code class="language-helios">Int::from_data(data: Data) -&gt; Int
</code></pre>
<h3 id="from_little_endian"><a class="header" href="#from_little_endian"><code>from_little_endian</code></a></h3>
<p>Converts a <a href="lang/builtins/./bytearray.html"><code>ByteArray</code></a> into an <code>Int</code>. The first byte is multiplied by <code>1</code> before adding to the sum, the second byte is multiplied by <code>256</code> etc.</p>
<p>The returned <code>Int</code> is always positive.</p>
<pre><code class="language-helios">Int::from_little_endian(bytes: ByteArray) -&gt; Int
</code></pre>
<h3 id="max"><a class="header" href="#max"><code>max</code></a></h3>
<p>Returns the greater of two numbers.</p>
<pre><code class="language-helios">Int::max(a: Int, b: Int) -&gt; Int
</code></pre>
<h3 id="min"><a class="header" href="#min"><code>min</code></a></h3>
<p>Returns the lesser of two numbers.</p>
<pre><code class="language-helios">Int::min(a: Int, b: Int) -&gt; Int
</code></pre>
<h3 id="parse"><a class="header" href="#parse"><code>parse</code></a></h3>
<p>Parses a string representation of an integer of the form <code>((-)?[1-9][0-9]*)|0</code> (i.e. a non zero-padded integer). Throws an error if the string representation of the integer doesn't respect this format. Note that <code>-0</code> isn't allowed, so zeros can only be represented by a single <code>0</code> digit.</p>
<pre><code class="language-helios">Int::parse(string: String) -&gt; Int
</code></pre>
<h3 id="sqrt"><a class="header" href="#sqrt"><code>sqrt</code></a></h3>
<p>Calculates the square root of an integer. The result is truncated if it can't be represented by a whole number. Throws an error if the input number is negative.</p>
<pre><code class="language-helios">Int::sqrt(a: Int) -&gt; Int
</code></pre>
<h2 id="operators-10"><a class="header" href="#operators-10">Operators</a></h2>
<h3 id="-38"><a class="header" href="#-38"><code>==</code></a></h3>
<pre><code class="language-helios">Int == Int -&gt; Bool
</code></pre>
<h3 id="-39"><a class="header" href="#-39"><code>!=</code></a></h3>
<pre><code class="language-helios">Int != Int -&gt; Bool
</code></pre>
<h3 id="-40"><a class="header" href="#-40"><code>&gt;=</code></a></h3>
<pre><code class="language-helios">Int &gt;= Int -&gt; Bool
</code></pre>
<h3 id="-41"><a class="header" href="#-41"><code>&gt;</code></a></h3>
<pre><code class="language-helios">Int &gt; Int -&gt; Bool
</code></pre>
<h3 id="-42"><a class="header" href="#-42"><code>&lt;=</code></a></h3>
<pre><code class="language-helios">Int &lt;= Int -&gt; Bool
</code></pre>
<h3 id="-43"><a class="header" href="#-43"><code>&lt;</code></a></h3>
<pre><code class="language-helios">Int &lt; Int -&gt; Bool
</code></pre>
<h3 id="-44"><a class="header" href="#-44"><code>+</code></a></h3>
<pre><code class="language-helios">Int + Int -&gt; Int
</code></pre>
<h3 id="--2"><a class="header" href="#--2"><code>-</code></a></h3>
<pre><code class="language-helios">Int - Int -&gt; Int
</code></pre>
<h3 id="-45"><a class="header" href="#-45"><code>*</code></a></h3>
<pre><code class="language-helios">Int * Int -&gt; Int
</code></pre>
<h3 id="-46"><a class="header" href="#-46"><code>/</code></a></h3>
<pre><code class="language-helios">Int / Int -&gt; Int
</code></pre>
<h3 id="-47"><a class="header" href="#-47"><code>%</code></a></h3>
<p>Modulo operator that returns the remainder after division.</p>
<pre><code class="language-helios">Int % Int -&gt; Int
</code></pre>
<h2 id="methods-10"><a class="header" href="#methods-10">Methods</a></h2>
<h3 id="abs"><a class="header" href="#abs"><code>abs</code></a></h3>
<p>Removes the sign, returning a positive <code>Int</code>.</p>
<pre><code class="language-helios">int.abs() -&gt; Int
</code></pre>
<h3 id="bound"><a class="header" href="#bound"><code>bound</code></a></h3>
<p>Bounds an <code>Int</code> if it falls outside a range. This builtin function doesn't check if the range is sensible.</p>
<pre><code class="language-helios">int.bound(low: Int, high: Int) -&gt; Int
</code></pre>
<h3 id="bound_min"><a class="header" href="#bound_min"><code>bound_min</code></a></h3>
<p>Bounds an <code>Int</code> to be greater or equals to a given minimum value.</p>
<pre><code class="language-helios">int.bound_min(low: Int) -&gt; Int
</code></pre>
<h3 id="bound_max"><a class="header" href="#bound_max"><code>bound_max</code></a></h3>
<p>Bounds an <code>Int</code> to be less or equals to a given maximum value.</p>
<pre><code class="language-helios">int.bound_max(high: Int) -&gt; Int
</code></pre>
<h3 id="decode_zigzag"><a class="header" href="#decode_zigzag"><code>decode_zigzag</code></a></h3>
<p>Decodes a <a href="https://en.wikipedia.org/wiki/Variable-length_quantity#Zigzag_encoding">zigzag encoded</a> <code>Int</code>. Throws an error if the <code>Int</code> is negative.</p>
<pre><code class="language-helios">unsigned_int.decode_zigzag() -&gt; Int
</code></pre>
<h3 id="encode_zigzag"><a class="header" href="#encode_zigzag"><code>encode_zigzag</code></a></h3>
<p>Applies <a href="https://en.wikipedia.org/wiki/Variable-length_quantity#Zigzag_encoding">zigzag encoding</a> to the <code>Int</code>, returning a positive <code>Int</code>.</p>
<pre><code class="language-helios">signed_int.encode_zigzag() -&gt; Int
</code></pre>
<h3 id="serialize-10"><a class="header" href="#serialize-10"><code>serialize</code></a></h3>
<pre><code class="language-helios">int.serialize() -&gt; ByteArray
</code></pre>
<h3 id="show-3"><a class="header" href="#show-3"><code>show</code></a></h3>
<p>Returns decimal representation of integer.</p>
<pre><code class="language-helios">int.show() -&gt; String
</code></pre>
<h3 id="to_base58"><a class="header" href="#to_base58"><code>to_base58</code></a></h3>
<p>Encodes the <code>Int</code> as a <a href="https://en.wikipedia.org/wiki/Binary-to-text_encoding#Base58">base58</a> <a href="lang/builtins/./string.html"><code>String</code></a>.</p>
<p>Throws an error if the <code>Int</code> is negative.</p>
<pre><code class="language-helios">int.to_base58() -&gt; String
</code></pre>
<h3 id="to_big_endian"><a class="header" href="#to_big_endian"><code>to_big_endian</code></a></h3>
<p>Encodes the <code>Int</code> as a <a href="https://en.wikipedia.org/wiki/Endianness">big endian</a> <a href="lang/builtins/./bytearray.html"><code>ByteArray</code></a>.</p>
<p>Throws an error if the <code>Int</code> is negative.</p>
<pre><code class="language-helios">int.to_big_endian() -&gt; ByteArray
</code></pre>
<h3 id="to_bool"><a class="header" href="#to_bool"><code>to_bool</code></a></h3>
<p>Turns <code>0</code> into <code>false</code>, and any other integer into <code>true</code>.</p>
<pre><code class="language-helios">int.to_bool() -&gt; Bool
</code></pre>
<h3 id="to_little_endian"><a class="header" href="#to_little_endian"><code>to_little_endian</code></a></h3>
<p>Encodes the <code>Int</code> as a <a href="https://en.wikipedia.org/wiki/Endianness">little endian</a> <a href="lang/builtins/./bytearray.html"><code>ByteArray</code></a>.</p>
<p>Throws an error if the <code>Int</code> is negative.</p>
<pre><code class="language-helios">int.to_little_endian() -&gt; ByteArray
</code></pre>
<h3 id="to_hex"><a class="header" href="#to_hex"><code>to_hex</code></a></h3>
<p>Returns the hexadecimal representation of the <code>Int</code>.</p>
<pre><code class="language-helios">int.to_hex() -&gt; String
</code></pre>
<h3 id="to_real"><a class="header" href="#to_real"><code>to_real</code></a></h3>
<p>Converts the <code>Int</code> to the fixed point <a href="lang/builtins/./real.html"><code>Real</code></a> representation.</p>
<pre><code class="language-helios">int.to_real() -&gt; Real
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list-1"><a class="header" href="#list-1">List</a></h1>
<p>Helios linked-list type.</p>
<p>The syntax for a list type uses empty brackets followed by a type parameter: <code>[]ItemType</code>.</p>
<p>Example:</p>
<pre><code class="language-helios">example: []Int = []Int{1, 2, 3, 4, 5}; ...
</code></pre>
<p>Looping over multiple lists at once can be done with a recursive function call:</p>
<pre><code class="language-helios">func add_element_wise(a: []Int, b: []Int) -&gt; []Int {
    if (a.is_empty()) {
        []Int{}
    } else {
        add_element_wise(a.tail, b.tail).prepend(a.head + b.head)
    }
}
</code></pre>
<h2 id="associated-functions-7"><a class="header" href="#associated-functions-7">Associated functions</a></h2>
<h3 id="from_data-10"><a class="header" href="#from_data-10"><code>from_data</code></a></h3>
<pre><code class="language-helios">[]ItemType::from_data(data: Data) -&gt; []ItemType
</code></pre>
<h3 id="new-4"><a class="header" href="#new-4"><code>new</code></a></h3>
<p>Creates a new list of length <code>n</code>, where every contained item is determined by <code>fn(i: Int)</code> (<code>i</code> is the 0-based index of the item).</p>
<pre><code class="language-helios">[]ItemType::new(n: Int, fn: (i: Int) -&gt; ItemType) -&gt; []ItemType
</code></pre>
<h3 id="new_const"><a class="header" href="#new_const"><code>new_const</code></a></h3>
<p>Creates a new list of length <code>n</code>, where very contained item is the same.</p>
<pre><code class="language-helios">[]ItemType::new_const(n: Int, item: ItemType) -&gt; []ItemType
</code></pre>
<h2 id="getters-6"><a class="header" href="#getters-6">Getters</a></h2>
<h3 id="length-1"><a class="header" href="#length-1"><code>length</code></a></h3>
<p>Returns the length of a list.</p>
<pre><code class="language-helios">list.length -&gt; Int
</code></pre>
<h3 id="head"><a class="header" href="#head"><code>head</code></a></h3>
<p>Returns the first item in a list. Throws an error if the list is empty.</p>
<pre><code class="language-helios">list.head -&gt; ItemType
</code></pre>
<h3 id="tail"><a class="header" href="#tail"><code>tail</code></a></h3>
<p>Returns the list items following the first item. Throws an error if the list is empty.</p>
<pre><code class="language-helios">list.tail -&gt; []ItemType
</code></pre>
<blockquote>
<p><strong>Note</strong>: <code>tail</code> doesn't return the last item in a list but returns everything after <code>head</code> as a new list.</p>
</blockquote>
<h2 id="operators-11"><a class="header" href="#operators-11">Operators</a></h2>
<h3 id="-48"><a class="header" href="#-48"><code>==</code></a></h3>
<pre><code class="language-helios">[]ItemType == []ItemType -&gt; Bool
</code></pre>
<h3 id="-49"><a class="header" href="#-49"><code>!=</code></a></h3>
<pre><code class="language-helios">[]ItemType != []ItemType -&gt; Bool
</code></pre>
<h3 id="-50"><a class="header" href="#-50"><code>+</code></a></h3>
<p>List concatenation</p>
<pre><code class="language-helios">[]ItemType + []ItemType -&gt; []ItemType
</code></pre>
<h2 id="methods-11"><a class="header" href="#methods-11">Methods</a></h2>
<h3 id="all"><a class="header" href="#all"><code>all</code></a></h3>
<p>Returns <code>true</code> if all of the items in the list satisfy the predicate.</p>
<pre><code class="language-helios">list.all(predicate: (ItemType) -&gt; Bool) -&gt; Bool
</code></pre>
<h3 id="any"><a class="header" href="#any"><code>any</code></a></h3>
<p>Returns <code>true</code> if any of the items in the list satisfy the predicate.</p>
<pre><code class="language-helios">list.any(predicate: (ItemType) -&gt; Bool) -&gt; Bool
</code></pre>
<h3 id="drop"><a class="header" href="#drop"><code>drop</code></a></h3>
<p>Drops list items counting from the beginning, returning the rest of the list. Throws an error if <code>n</code> is negative or larger than the length of the list.</p>
<pre><code class="language-helios">list.drop(n: Int) -&gt; []ItemType
</code></pre>
<h3 id="drop_end"><a class="header" href="#drop_end"><code>drop_end</code></a></h3>
<p>Drops list items counting from the end, returning the non-dropped part of the list. Throws an error if <code>n</code> is negative or larger than the length of the list.</p>
<p>This method is more efficient than calling <code>list.take(list.length - n)</code> (if the list length isn't already known).</p>
<pre><code class="language-helios">list.drop_end(n: Int) -&gt; []ItemType
</code></pre>
<h3 id="filter"><a class="header" href="#filter"><code>filter</code></a></h3>
<p>Returns a list of all the items in the old list that satisfy the predicate.</p>
<pre><code class="language-helios">list.filter(predicate: (ItemType) -&gt; Bool) -&gt; []ItemType
</code></pre>
<h3 id="find"><a class="header" href="#find"><code>find</code></a></h3>
<p>Returns the first item in the list that satisfies the predicate. Throws an error if no item satisfies the predicate.</p>
<pre><code class="language-helios">list.find(predicate: (ItemType) -&gt; Bool) -&gt; ItemType
</code></pre>
<h3 id="find_safe"><a class="header" href="#find_safe"><code>find_safe</code></a></h3>
<p>Returns the first item in the list that satisfies the predicate, wrapped in an <a href="lang/builtins/./option.html"><code>Option</code></a>. Returns a <code>Option[ItemType]::None</code> if no items match the predicate.</p>
<pre><code class="language-helios">list.find_safe(predicate: (ItemType) -&gt; Bool) -&gt; Option[ItemType]
</code></pre>
<h3 id="fold"><a class="header" href="#fold"><code>fold</code></a></h3>
<p>Folds a list into a single value by continuosly applying the binary function to the items of the list. The result type is a type parameter of this method: <code>ReducedType</code>.</p>
<pre><code class="language-helios">list.fold(
    reducer: (ReducedType, ItemType) -&gt; ReducedType, 
    init: ReducedType
) -&gt; ReducedType
</code></pre>
<h3 id="fold_lazy"><a class="header" href="#fold_lazy"><code>fold_lazy</code></a></h3>
<p>Fold that allows breaking the loop before reaching the end of the list. Can also be used to fold from the last to the first entry of the list instead of the other way around.</p>
<pre><code class="language-helios">list.fold_lazy(
    reducer: (item: ItemType, next: () -&gt; ReducedType) -&gt; ReducedType,
    final: ReducedType
) -&gt; ReducedType
</code></pre>
<h3 id="for_each"><a class="header" href="#for_each"><code>for_each</code></a></h3>
<p>Print or assert something for each item. Returns void.</p>
<pre><code class="language-helios">list.for_each(fn: (item: ItemType) -&gt; ()) -&gt; ()
</code></pre>
<h3 id="get"><a class="header" href="#get"><code>get</code></a></h3>
<p>Returns the item at the given position in the list (0-based index). Throws an error if the index is out of range.</p>
<pre><code class="language-helios">list.get(index: Int) -&gt; ItemType
</code></pre>
<blockquote>
<p><strong>Note</strong>: <code>get(n)</code> has to iterate until it encounters the <code>n</code>-th item, so this method is <strong>O(n)</strong> and <strong>not</strong> O(1).</p>
</blockquote>
<h3 id="get_singleton"><a class="header" href="#get_singleton"><code>get_singleton</code></a></h3>
<p>Asserts that the list contains precisely one item, and returns that item.</p>
<pre><code class="language-helios">list.get_singleton() -&gt; ItemType
</code></pre>
<h3 id="is_empty"><a class="header" href="#is_empty"><code>is_empty</code></a></h3>
<p>Returns <code>true</code> if the list is empty.</p>
<pre><code class="language-helios">list.is_empty() -&gt; Bool
</code></pre>
<h3 id="map-1"><a class="header" href="#map-1"><code>map</code></a></h3>
<p>Transforms each item of a list. The resulting list item type is a type parameter of this method: <code>NewItemType</code>.</p>
<pre><code class="language-helios">list.map(mapper: (ItemType) -&gt; NewItemType) -&gt; []NewItemType
</code></pre>
<h3 id="prepend-1"><a class="header" href="#prepend-1"><code>prepend</code></a></h3>
<p>Creates a new list by prepending an item to the old list.</p>
<pre><code class="language-helios">list.prepend(item: ItemType) -&gt; []ItemType
</code></pre>
<h3 id="serialize-11"><a class="header" href="#serialize-11"><code>serialize</code></a></h3>
<pre><code class="language-helios">list.serialize() -&gt; ByteArray
</code></pre>
<h3 id="sort"><a class="header" href="#sort"><code>sort</code></a></h3>
<p>Sorts the list using insertion sort.</p>
<pre><code class="language-helios">list.sort((a: ItemType, b: ItemType) -&gt; Bool) -&gt; []ItemType
</code></pre>
<h3 id="take"><a class="header" href="#take"><code>take</code></a></h3>
<p>Takes the first <code>n</code> items from the list. Throws an error if <code>n</code> is negative or larger than the length of the list.</p>
<pre><code class="language-helios">list.take(n: Int) -&gt; []ItemType
</code></pre>
<h3 id="take_end"><a class="header" href="#take_end"><code>take_end</code></a></h3>
<p>Takes the last <code>n</code> items from the list. Throws an error if <code>n</code> is negative or larger than the length of the list.</p>
<p>This method is more efficient than calling <code>list.drop(list.length - n)</code> (if the list length isn't already known).</p>
<pre><code class="language-helios">list.take_end(n: Int) -&gt; []ItemType
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="map-2"><a class="header" href="#map-2"><code>Map</code></a></h1>
<p>List of key-value pairs. The insertion order of the key-value pairs matters.</p>
<blockquote>
<p><strong>Note</strong>: a <code>Map</code> is internally not implemented as a hash-table, so keys aren't guaranteed to be unique.</p>
</blockquote>
<p>The map type syntax takes two type parameters: <code>Map[</code><em><code>KeyType</code></em><code>]</code><em><code>ValueType</code></em>.</p>
<p>Example:</p>
<pre><code class="language-helios">my_map = Map[String]Int{&quot;zero&quot;: 0, &quot;one&quot;: 1, &quot;two&quot;: 2};
print(my_map.get(&quot;zero&quot;).show()); ... // prints &quot;0&quot;
</code></pre>
<h2 id="associated-functions-8"><a class="header" href="#associated-functions-8">Associated functions</a></h2>
<h3 id="from_data-11"><a class="header" href="#from_data-11"><code>from_data</code></a></h3>
<pre><code class="language-helios">Map[KeyType]ValueType::from_data(data: Data) -&gt; Map[KeyType]ValueType
</code></pre>
<h2 id="getters-7"><a class="header" href="#getters-7">Getters</a></h2>
<h3 id="head_key"><a class="header" href="#head_key"><code>head_key</code></a></h3>
<p>Returns the key of the first entry in the <code>Map</code>. Throws an error if the <code>Map</code> is empty.</p>
<pre><code class="language-helios">map.head_key -&gt; KeyType
</code></pre>
<h3 id="head_value"><a class="header" href="#head_value"><code>head_value</code></a></h3>
<p>Returns the value of the first entry in the <code>Map</code>. Throws an error if the <code>Map</code> is empty.</p>
<pre><code class="language-helios">map.head_value -&gt; ValueType
</code></pre>
<h3 id="length-2"><a class="header" href="#length-2"><code>length</code></a></h3>
<p>Returns the number of items in a map.</p>
<pre><code class="language-helios">map.length -&gt; Int
</code></pre>
<h3 id="tail-1"><a class="header" href="#tail-1"><code>tail</code></a></h3>
<p>Returns the entries after the first entry as a new <code>Map</code>. Throws an error if the <code>Map</code> is empty.</p>
<pre><code class="language-helios">map.tail -&gt; Map[KeyType]ValueType
</code></pre>
<h2 id="operators-12"><a class="header" href="#operators-12">Operators</a></h2>
<h3 id="-51"><a class="header" href="#-51"><code>==</code></a></h3>
<pre><code class="language-helios">Map[KeyType]ValueType == Map[KeyType]ValueType -&gt; Bool
</code></pre>
<blockquote>
<p><strong>Note</strong>: because Plutus-Core handles <code>Map</code> as a list, the entries must be in the same order for <code>==</code> to return <code>true</code>.</p>
</blockquote>
<h3 id="-52"><a class="header" href="#-52"><code>!=</code></a></h3>
<pre><code class="language-helios">Map[KeyType]ValueType != Map[KeyType]ValueType -&gt; Bool
</code></pre>
<h3 id="-53"><a class="header" href="#-53"><code>+</code></a></h3>
<p>Concatenation of two maps.</p>
<pre><code class="language-helios">Map[KeyType]ValueType + Map[KeyType]ValueType -&gt; Map[KeyType]ValueType
</code></pre>
<h2 id="methods-12"><a class="header" href="#methods-12">Methods</a></h2>
<h3 id="all-1"><a class="header" href="#all-1"><code>all</code></a></h3>
<p>Returns <code>true</code> if all map entries satisfy the predicate.</p>
<pre><code class="language-helios">map.all(predicate: (KeyType, ValueType) -&gt; Bool) -&gt; Bool
</code></pre>
<h3 id="any-1"><a class="header" href="#any-1"><code>any</code></a></h3>
<p>Returns <code>true</code> if any map entry satisfies the predicate.</p>
<pre><code class="language-helios">map.any(predicate: (KeyType, ValueType) -&gt; Bool) -&gt; Bool
</code></pre>
<h3 id="delete"><a class="header" href="#delete"><code>delete</code></a></h3>
<p>Removes all entries with the given key. Doesn't throw an error if the key isn't found.</p>
<pre><code class="language-helios">map.delete(key: KeyType) -&gt; Map[KeyType]ValueType
</code></pre>
<h3 id="filter-1"><a class="header" href="#filter-1"><code>filter</code></a></h3>
<pre><code class="language-helios">map.filter(predicate: (KeyType, ValueType) -&gt; Bool) -&gt; Map[KeyType]ValueType
</code></pre>
<h3 id="find-1"><a class="header" href="#find-1"><code>find</code></a></h3>
<p>Returns the key and value of the first entry that matches the predicate. Throws an error if none found.</p>
<pre><code class="language-helios">map.find(predicate: (KeyType, ValueType) -&gt; Bool) -&gt; (KeyType, ValueType)
</code></pre>
<h3 id="find_safe-1"><a class="header" href="#find_safe-1"><code>find_safe</code></a></h3>
<p>Returns a callback (that returns the found key-value pair) and a <code>Bool</code>. Calling the callback if the returned <code>Bool</code> is <code>false</code> throws an error.</p>
<pre><code class="language-helios">map.find_safe(
    predicate: (KeyType, ValueType) -&gt; Bool
) -&gt; (() -&gt; (KeyType, ValueType), Bool)
</code></pre>
<h3 id="find_key"><a class="header" href="#find_key"><code>find_key</code></a></h3>
<p>Returns the first key that matches the predicate. Throws an error if none found.</p>
<pre><code class="language-helios">map.find_key(predicate: (KeyType) -&gt; Bool) -&gt; KeyType
</code></pre>
<h3 id="find_key_safe"><a class="header" href="#find_key_safe"><code>find_key_safe</code></a></h3>
<p>Returns an <a href="lang/builtins/./option.html"><code>Option</code></a> containing the first key that matches the predicate, or <code>Option[KeyType]::None</code> if none found.</p>
<pre><code class="language-helios">map.find_key_safe(predicate: (KeyType) -&gt; Bool) -&gt; Option[KeyType]
</code></pre>
<h3 id="find_value"><a class="header" href="#find_value"><code>find_value</code></a></h3>
<p>Returns the first value that matches the predicate. Throws an error if none found.</p>
<pre><code class="language-helios">map.find_value(predicate: (ValueType) -&gt; Bool) -&gt; ValueType
</code></pre>
<h3 id="find_value_safe"><a class="header" href="#find_value_safe"><code>find_value_safe</code></a></h3>
<p>Returns an <a href="lang/builtins/./option.html"><code>Option</code></a> containing the first value that matches the predicate, or <code>Option[ValueType]::None</code> if none found.</p>
<pre><code class="language-helios">map.find_value_safe(predicate: (ValueType) -&gt; Bool) -&gt; Option[ValueType]
</code></pre>
<h3 id="fold-1"><a class="header" href="#fold-1"><code>fold</code></a></h3>
<pre><code class="language-helios">map.fold(
    reducer: (ReducedType, KeyType, ValueType) -&gt; ReducedType, 
    init: ReducedType
) -&gt; ReducedType
</code></pre>
<h3 id="fold_lazy-1"><a class="header" href="#fold_lazy-1"><code>fold_lazy</code></a></h3>
<p>Fold that allows breaking the loop before reaching the end of the map. Can also be used to fold from the last to the first entry of the <code>Map</code> instead of the other way around.</p>
<pre><code class="language-helios">map.fold_lazy(
    reducer: (KeyType, ValueType, next: () -&gt; ReducedType) -&gt; ReducedType,
    final: ReducedType
) -&gt; ReducedType
</code></pre>
<h3 id="for_each-1"><a class="header" href="#for_each-1"><code>for_each</code></a></h3>
<p>Print or assert something for each map entry. Returns void.</p>
<pre><code class="language-helios">map.for_each(fn: (key: KeyType, value: ValueType) -&gt; ()) -&gt; ()
</code></pre>
<h3 id="get-1"><a class="header" href="#get-1"><code>get</code></a></h3>
<p>Returns the value of the first entry in the map that matches the given key. Throws an error of the key isn't found.</p>
<pre><code class="language-helios">map.get(key: KeyType) -&gt; ValueType
</code></pre>
<h3 id="get_safe"><a class="header" href="#get_safe"><code>get_safe</code></a></h3>
<p>Returns the value of the first entry in the map that matches the given key (wrapped in an option). Returns <code>Option[ValueType]::None</code> if the key isn't found.</p>
<pre><code class="language-helios">map.get_safe(key: KeyType) -&gt; Option[ValueType]
</code></pre>
<h3 id="head-1"><a class="header" href="#head-1"><code>head</code></a></h3>
<p>Get the key and the value of the first entry.</p>
<pre><code class="language-helios">map.head() -&gt; (KeyType, ValueType)
</code></pre>
<h3 id="is_empty-1"><a class="header" href="#is_empty-1"><code>is_empty</code></a></h3>
<p>Returns <code>true</code> if the <code>Map</code> is empty.</p>
<pre><code class="language-helios">map.is_empty() -&gt; Bool
</code></pre>
<h3 id="map-3"><a class="header" href="#map-3"><code>map</code></a></h3>
<p>Creates a new <code>Map</code> by transforming the <code>Map</code> keys and values.</p>
<pre><code class="language-helios">map.map(
    mapper: (KeyType, ValueType) -&gt; (NewKeyType, NewValueType)
) -&gt; Map[NewKeyType]NewValueType
</code></pre>
<h3 id="prepend-2"><a class="header" href="#prepend-2"><code>prepend</code></a></h3>
<p>Prepends a key-value pair to the beginning of the <code>Map</code>, creating a new <code>Map</code>.</p>
<pre><code class="language-helios">map.prepend(key: KeyType, value: ValueType) -&gt; Map[KeyType][ValueType]
</code></pre>
<h3 id="serialize-12"><a class="header" href="#serialize-12"><code>serialize</code></a></h3>
<pre><code class="language-helios">map.serialize() -&gt; ByteArray
</code></pre>
<h3 id="set"><a class="header" href="#set"><code>set</code></a></h3>
<p>Sets the first entry with given key to a new value. This entry is appended to end of the <code>Map</code> if the key isn't found.</p>
<pre><code class="language-helios">map.set(key: KeyType, value: ValueType) -&gt; Map[KeyType]ValueType
</code></pre>
<h3 id="sort-1"><a class="header" href="#sort-1"><code>sort</code></a></h3>
<p>Sorts the map using insertion sort. The comparison function should return <code>true</code> if <code>a</code> and <code>b</code> are in the correct order.</p>
<pre><code class="language-helios">map.sort(
    compare: (
        key_a: KeyType, value_a: ValueType, 
        key_b: KeyType, value_b: ValueType
    ) -&gt; Bool
) -&gt; Map[KeyType]ValueType
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mintingpolicyhash"><a class="header" href="#mintingpolicyhash"><code>MintingPolicyHash</code></a></h1>
<p><a href="https://en.wikipedia.org/wiki/Opaque_data_type">Opaque</a> <a href="lang/builtins/./bytearray.html"><code>ByteArray</code></a> that represents the hash of a minting policy script.</p>
<p>Example:</p>
<pre><code class="language-helios">mph = MintingPolicyHash::new(#...); ...
</code></pre>
<h2 id="associated-functions-9"><a class="header" href="#associated-functions-9">Associated functions</a></h2>
<h3 id="new-5"><a class="header" href="#new-5"><code>new</code></a></h3>
<pre><code class="language-helios">MintingPolicyHash::new(bytes: ByteArray) -&gt; MintingPolicyHash
</code></pre>
<h3 id="from_data-12"><a class="header" href="#from_data-12"><code>from_data</code></a></h3>
<pre><code class="language-helios">MintingPolicyHash::from_data(data: Data) -&gt; MintingPolicyHash
</code></pre>
<h3 id="from_script_hash"><a class="header" href="#from_script_hash"><code>from_script_hash</code></a></h3>
<p>Casts the generic <a href="lang/builtins/./scripthash.html"><code>ScriptHash</code></a> type into <code>MintingPolicyHash</code>.</p>
<pre><code class="language-helios">MintingPolicyHash::from_script_hash(hash: ScriptHash) -&gt; MintingPolicyHash
</code></pre>
<h2 id="operators-13"><a class="header" href="#operators-13">Operators</a></h2>
<h3 id="-54"><a class="header" href="#-54"><code>==</code></a></h3>
<pre><code class="language-helios">MintingPolicyHash == MintingPolicyHash -&gt; Bool
</code></pre>
<h3 id="-55"><a class="header" href="#-55"><code>!=</code></a></h3>
<pre><code class="language-helios">MintingPolicyHash != MintingPolicyHash -&gt; Bool
</code></pre>
<h3 id="-56"><a class="header" href="#-56"><code>&gt;=</code></a></h3>
<pre><code class="language-helios">MintingPolicyHash &gt;= MintingPolicyHash -&gt; Bool
</code></pre>
<h3 id="-57"><a class="header" href="#-57"><code>&gt;</code></a></h3>
<pre><code class="language-helios">MintingPolicyHash &gt; MintingPolicyHash -&gt; Bool
</code></pre>
<h3 id="-58"><a class="header" href="#-58"><code>&lt;=</code></a></h3>
<pre><code class="language-helios">MintingPolicyHash &lt;= MintingPolicyHash -&gt; Bool
</code></pre>
<h3 id="-59"><a class="header" href="#-59"><code>&lt;</code></a></h3>
<pre><code class="language-helios">MintingPolicyHash &lt; MintingPolicyHash -&gt; Bool
</code></pre>
<h2 id="methods-13"><a class="header" href="#methods-13">Methods</a></h2>
<h3 id="serialize-13"><a class="header" href="#serialize-13"><code>serialize</code></a></h3>
<pre><code class="language-helios">mph.serialize() -&gt; ByteArray
</code></pre>
<h3 id="show-4"><a class="header" href="#show-4"><code>show</code></a></h3>
<p>Hexadecimal representation of <code>MintingPolicyHash</code>.</p>
<pre><code class="language-helios">mph.show() -&gt; String
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option-1"><a class="header" href="#option-1"><code>Option</code></a></h1>
<p><code>Option[</code><em><code>SomeType</code></em><code>]</code> is an enum used to represent an optional value. Its type syntax takes one type parameter. An option has two variants:</p>
<ul>
<li><code>Some</code></li>
<li><code>None</code></li>
</ul>
<br/>
<p>Example:</p>
<pre><code class="language-helios">option_some: Option[Int] = Option[Int]::Some{42};
option_none: Option[Int] = Option[Int]::None; ...
</code></pre>
<h2 id="associated-functions-10"><a class="header" href="#associated-functions-10">Associated functions</a></h2>
<h3 id="from_data-13"><a class="header" href="#from_data-13"><code>from_data</code></a></h3>
<pre><code class="language-helios">Option[SomeType]::from_data(data: Data) -&gt; Option[SomeType]
</code></pre>
<h2 id="getters-8"><a class="header" href="#getters-8">Getters</a></h2>
<h3 id="optionsometypesome"><a class="header" href="#optionsometypesome"><code>Option[SomeType]::Some</code></a></h3>
<h4 id="some"><a class="header" href="#some"><code>some</code></a></h4>
<p>Returns content of <code>Option[</code><em><code>SomeType</code></em><code>]::Some</code>.</p>
<pre><code class="language-helios">option_some.some -&gt; SomeType
</code></pre>
<blockquote>
<p><strong>Note</strong>: this getter doesn't exist on <code>Option[</code><em><code>SomeType</code></em><code>]::None</code>.</p>
</blockquote>
<h2 id="operators-14"><a class="header" href="#operators-14">Operators</a></h2>
<h3 id="-60"><a class="header" href="#-60"><code>==</code></a></h3>
<pre><code class="language-helios">Option[SomeType] == Option[SomeType] -&gt; Bool
</code></pre>
<h3 id="-61"><a class="header" href="#-61"><code>!=</code></a></h3>
<pre><code class="language-helios">Option[SomeType] != Option[SomeType] -&gt; Bool
</code></pre>
<h2 id="methods-14"><a class="header" href="#methods-14">Methods</a></h2>
<h3 id="map-4"><a class="header" href="#map-4"><code>map</code></a></h3>
<p>Maps <code>None</code> to <code>None</code> and <code>Some</code> to <code>Some</code>.</p>
<pre><code class="language-helios">option.map(fn: (some: OldSomeType) -&gt; NewSomeType) -&gt; Option[NewSomeType]
</code></pre>
<h3 id="serialize-14"><a class="header" href="#serialize-14"><code>serialize</code></a></h3>
<pre><code class="language-helios">option.serialize() -&gt; ByteArray
</code></pre>
<h3 id="unwrap"><a class="header" href="#unwrap"><code>unwrap</code></a></h3>
<p>Returns the value wrapped by <code>Some</code>. Throws an error if <code>None</code>.</p>
<pre><code class="language-helios">option.unwrap() -&gt; SomeType
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="outputdatum"><a class="header" href="#outputdatum"><code>OutputDatum</code></a></h1>
<p>Represents that datum data of a <a href="lang/builtins/./txoutput.html"><code>TxOutput</code></a> instance.</p>
<p><code>OutputDatum</code> is an enum with 3 variants:</p>
<ul>
<li><code>None</code></li>
<li><code>Hash</code></li>
<li><code>Inline</code></li>
</ul>
<h2 id="associated-functions-11"><a class="header" href="#associated-functions-11">Associated functions</a></h2>
<h3 id="from_data-14"><a class="header" href="#from_data-14"><code>from_data</code></a></h3>
<pre><code class="language-helios">OutputDatum::from_data(data: Data) -&gt; OutputDatum
</code></pre>
<h3 id="new_hash"><a class="header" href="#new_hash"><code>new_hash</code></a></h3>
<p>Construct a new <code>OutputDatum::Hash</code> instance.</p>
<pre><code class="language-helios">OutputDatum::new_hash(datum_hash: DatumHash) -&gt; OutputDatum::Hash
</code></pre>
<h3 id="new_inline"><a class="header" href="#new_inline"><code>new_inline</code></a></h3>
<p>Construct a new <code>OutputDatum::Inline</code> instance from any value that is not a function.</p>
<pre><code class="language-helios">OutputDatum::new_inline(any: AnyType) -&gt; OutputDatum::Inline
</code></pre>
<h3 id="new_none"><a class="header" href="#new_none"><code>new_none</code></a></h3>
<p>Construct a new <code>OutputDatum::None</code> instance.</p>
<pre><code class="language-helios">OutputDatum::new_none() -&gt; OutputDatum::None
</code></pre>
<h2 id="getters-9"><a class="header" href="#getters-9">Getters</a></h2>
<h3 id="outputdatum-1"><a class="header" href="#outputdatum-1"><code>OutputDatum</code></a></h3>
<h4 id="get_inline_data"><a class="header" href="#get_inline_data"><code>get_inline_data</code></a></h4>
<p>Short-hand for <code>output_datum.switch{inline: Inline =&gt; inline.data, _ =&gt; error(&quot;not an inline datum&quot;)}</code>:</p>
<pre><code class="language-helios">output_datum.get_inline_data() -&gt; Data
</code></pre>
<h3 id="outputdatumhash"><a class="header" href="#outputdatumhash"><code>OutputDatum::Hash</code></a></h3>
<h4 id="hash-1"><a class="header" href="#hash-1"><code>hash</code></a></h4>
<pre><code class="language-helios">hash_output_datum.hash -&gt; DatumHash
</code></pre>
<h3 id="outputdatuminline"><a class="header" href="#outputdatuminline"><code>OutputDatum::Inline</code></a></h3>
<h4 id="data-2"><a class="header" href="#data-2"><code>data</code></a></h4>
<pre><code class="language-helios">inline_output_datum.data -&gt; Data
</code></pre>
<p>Use the <code>from_data</code> associated function, which is automatically defined on every type, to turn <code>Data</code> into another type.</p>
<h2 id="operators-15"><a class="header" href="#operators-15">Operators</a></h2>
<h3 id="-62"><a class="header" href="#-62"><code>==</code></a></h3>
<pre><code class="language-helios">OutputDatum == OutputDatum -&gt; Bool
</code></pre>
<h3 id="-63"><a class="header" href="#-63"><code>!=</code></a></h3>
<pre><code class="language-helios">OutputDatum != OutputDatum -&gt; Bool
</code></pre>
<h2 id="methods-15"><a class="header" href="#methods-15">Methods</a></h2>
<h3 id="serialize-15"><a class="header" href="#serialize-15"><code>serialize</code></a></h3>
<pre><code class="language-helios">output_datum.serialize() -&gt; ByteArray
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pubkey"><a class="header" href="#pubkey"><code>PubKey</code></a></h1>
<p><a href="https://en.wikipedia.org/wiki/Opaque_data_type">Opaque</a> <a href="lang/builtins/./bytearray.html"><code>ByteArray</code></a> that represents a Ed25519 public key.</p>
<p>A <code>PubKey</code> is 32 bytes long. A <a href="lang/builtins/./pubkeyhash.html"><code>PubKeyHash</code></a> is the blake2b-224 hash of a <code>PubKey</code>. Sadly there is no on-chain way of calculating the <a href="lang/builtins/./pubkeyhash.html"><code>PubKeyHash</code></a> from a <code>PubKey</code> (only blake2b-256 is available on-chain).</p>
<p>Example instantiation:</p>
<pre><code class="language-helios">pub_key: PubKey = PubKey::new(#...); ...
</code></pre>
<h2 id="associated-functions-12"><a class="header" href="#associated-functions-12">Associated functions</a></h2>
<h3 id="new-6"><a class="header" href="#new-6"><code>new</code></a></h3>
<pre><code class="language-helios">PubKey::new(bytes: ByteArray) -&gt; PubKey
</code></pre>
<h3 id="from_data-15"><a class="header" href="#from_data-15"><code>from_data</code></a></h3>
<pre><code class="language-helios">PubKey::from_data(data: Data) -&gt; PubKey
</code></pre>
<h2 id="operators-16"><a class="header" href="#operators-16">Operators</a></h2>
<h3 id="-64"><a class="header" href="#-64"><code>==</code></a></h3>
<pre><code class="language-helios">PubKey == PubKey -&gt; Bool
</code></pre>
<h3 id="-65"><a class="header" href="#-65"><code>!=</code></a></h3>
<pre><code class="language-helios">PubKey != PubKey -&gt; Bool
</code></pre>
<h2 id="methods-16"><a class="header" href="#methods-16">Methods</a></h2>
<h3 id="serialize-16"><a class="header" href="#serialize-16"><code>serialize</code></a></h3>
<pre><code class="language-helios">pub_key.serialize() -&gt; ByteArray
</code></pre>
<h3 id="show-5"><a class="header" href="#show-5"><code>show</code></a></h3>
<p>Hexadecimal representation of a <code>PubKey</code>.</p>
<pre><code class="language-helios">pub_key.show() -&gt; String
</code></pre>
<h3 id="verify"><a class="header" href="#verify"><code>verify</code></a></h3>
<p>Verify the signature of a message (using Ed25519).</p>
<pre><code class="language-helios">pub_key.verify(message: ByteArray, signature: ByteArray) -&gt; Bool
</code></pre>
<p>The signature is expected to be 64 bytes long.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pubkeyhash"><a class="header" href="#pubkeyhash"><code>PubKeyHash</code></a></h1>
<p><a href="https://en.wikipedia.org/wiki/Opaque_data_type">Opaque</a> <a href="lang/builtins/./bytearray.html"><code>ByteArray</code></a> that represents the hash of a <a href="lang/builtins/./pubkey.html"><code>PubKey</code></a>. </p>
<p>The first part of a regular payment address (i.e. not witnessed by a script) is a <code>PubKeyHash</code>.</p>
<p>Example instantiation:</p>
<pre><code class="language-helios">pkh: PubKeyHash = PubKeyHash::new(#...); ...
</code></pre>
<h2 id="associated-functions-13"><a class="header" href="#associated-functions-13">Associated functions</a></h2>
<h3 id="new-7"><a class="header" href="#new-7"><code>new</code></a></h3>
<pre><code class="language-helios">PubKeyHash::new(bytes: ByteArray) -&gt; PubKeyHash
</code></pre>
<h3 id="from_data-16"><a class="header" href="#from_data-16"><code>from_data</code></a></h3>
<pre><code class="language-helios">PubKeyHash::from_data(data: Data) -&gt; PubKeyHash
</code></pre>
<h2 id="operators-17"><a class="header" href="#operators-17">Operators</a></h2>
<h3 id="-66"><a class="header" href="#-66"><code>==</code></a></h3>
<pre><code class="language-helios">PubKeyHash == PubKeyHash -&gt; Bool
</code></pre>
<h3 id="-67"><a class="header" href="#-67"><code>!=</code></a></h3>
<pre><code class="language-helios">PubKeyHash != PubKeyHash -&gt; Bool
</code></pre>
<h3 id="-68"><a class="header" href="#-68"><code>&gt;=</code></a></h3>
<pre><code class="language-helios">PubKeyHash &gt;= PubKeyHash -&gt; Bool
</code></pre>
<h3 id="-69"><a class="header" href="#-69"><code>&gt;</code></a></h3>
<pre><code class="language-helios">PubKeyHash &gt; PubKeyHash -&gt; Bool
</code></pre>
<h3 id="-70"><a class="header" href="#-70"><code>&lt;=</code></a></h3>
<pre><code class="language-helios">PubKeyHash &lt;= PubKeyHash -&gt; Bool
</code></pre>
<h3 id="-71"><a class="header" href="#-71"><code>&lt;</code></a></h3>
<pre><code class="language-helios">PubKeyHash &lt; PubKeyHash -&gt; Bool
</code></pre>
<h2 id="methods-17"><a class="header" href="#methods-17">Methods</a></h2>
<h3 id="serialize-17"><a class="header" href="#serialize-17"><code>serialize</code></a></h3>
<pre><code class="language-helios">pkh.serialize() -&gt; ByteArray
</code></pre>
<h3 id="show-6"><a class="header" href="#show-6"><code>show</code></a></h3>
<p>Hexadecimal representation of a <code>PubKeyHash</code>.</p>
<pre><code class="language-helios">pkh.show() -&gt; String
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="real-1"><a class="header" href="#real-1"><code>Real</code></a></h1>
<p>This is a fixed point real number type with 6 decimal places. <code>Real</code> is designed for use in calculations involving relative fees.</p>
<pre><code class="language-helios">real = 0.001 // 0.1%
</code></pre>
<h2 id="associated-functions-14"><a class="header" href="#associated-functions-14">Associated functions</a></h2>
<h3 id="from_data-17"><a class="header" href="#from_data-17"><code>from_data</code></a></h3>
<pre><code class="language-helios">Real::from_data(data: Data) -&gt; Real
</code></pre>
<h3 id="sqrt-1"><a class="header" href="#sqrt-1"><code>sqrt</code></a></h3>
<p>Calculates the square root of a <code>Real</code> number. The result has a maximal error of <code>0.000001</code>. Throws an error if the input number is negative.</p>
<pre><code class="language-helios">Real::sqrt(a: Real) -&gt; Real
</code></pre>
<h2 id="operators-18"><a class="header" href="#operators-18">Operators</a></h2>
<blockquote>
<p><strong>Note</strong>: any binary operator defined for <code>Real</code> can use <code>Int</code> as either the lhs or rhs.</p>
</blockquote>
<h3 id="-72"><a class="header" href="#-72"><code>==</code></a></h3>
<pre><code class="language-helios">Real == Real -&gt; Bool
</code></pre>
<h3 id="-73"><a class="header" href="#-73"><code>!=</code></a></h3>
<pre><code class="language-helios">Real != Real -&gt; Bool
</code></pre>
<h3 id="-74"><a class="header" href="#-74"><code>&gt;=</code></a></h3>
<pre><code class="language-helios">Real &gt;= Real -&gt; Bool
</code></pre>
<h3 id="-75"><a class="header" href="#-75"><code>&gt;</code></a></h3>
<pre><code class="language-helios">Real &gt; Real -&gt; Bool
</code></pre>
<h3 id="-76"><a class="header" href="#-76"><code>&lt;=</code></a></h3>
<pre><code class="language-helios">Real &lt;= Real -&gt; Bool
</code></pre>
<h3 id="-77"><a class="header" href="#-77"><code>&lt;</code></a></h3>
<pre><code class="language-helios">Real &lt; Real -&gt; Bool
</code></pre>
<h3 id="-78"><a class="header" href="#-78"><code>+</code></a></h3>
<pre><code class="language-helios">Real + Real -&gt; Real
</code></pre>
<h3 id="--3"><a class="header" href="#--3"><code>-</code></a></h3>
<pre><code class="language-helios">Real - Real -&gt; Real
</code></pre>
<h3 id="-79"><a class="header" href="#-79"><code>*</code></a></h3>
<pre><code class="language-helios">Real * Real -&gt; Real
</code></pre>
<h3 id="-80"><a class="header" href="#-80"><code>/</code></a></h3>
<pre><code class="language-helios">Real / Real -&gt; Real
</code></pre>
<h2 id="methods-18"><a class="header" href="#methods-18">Methods</a></h2>
<h3 id="abs-1"><a class="header" href="#abs-1"><code>abs</code></a></h3>
<p>Returns the absolute value.</p>
<pre><code class="language-helios">Real.abs() -&gt; Real
</code></pre>
<h3 id="ceil"><a class="header" href="#ceil"><code>ceil</code></a></h3>
<p>Rounds up, returning an <a href="lang/builtins/./int.html"><code>Int</code></a>.</p>
<pre><code class="language-helios">real.ceil() -&gt; Int
</code></pre>
<h3 id="floor"><a class="header" href="#floor"><code>floor</code></a></h3>
<p>Rounds down, returning an <a href="lang/builtins/./int.html"><code>Int</code></a>.</p>
<pre><code class="language-helios">real.floor() -&gt; Int
</code></pre>
<h3 id="round"><a class="header" href="#round"><code>round</code></a></h3>
<p>Rounds towards nearest whole number, returning an <a href="lang/builtins/./int.html"><code>Int</code></a>.</p>
<pre><code class="language-helios">real.round() -&gt; Int
</code></pre>
<h3 id="trunc"><a class="header" href="#trunc"><code>trunc</code></a></h3>
<p>Rounds towards zero, returning an <a href="lang/builtins/./int.html"><code>Int</code></a>.</p>
<pre><code class="language-helios">real.trunc() -&gt; Int
</code></pre>
<h3 id="serialize-18"><a class="header" href="#serialize-18"><code>serialize</code></a></h3>
<pre><code class="language-helios">real.serialize() -&gt; ByteArray
</code></pre>
<h3 id="show-7"><a class="header" href="#show-7"><code>show</code></a></h3>
<pre><code class="language-helios">real.show() -&gt; String
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scriptcontext"><a class="header" href="#scriptcontext"><code>ScriptContext</code></a></h1>
<p>The <code>ScriptContext</code> contains all the metadata related to a signed Cardano transaction and is often an important argument of the validator script <code>main</code> function.</p>
<p>It wraps the <a href="lang/builtins/./tx.html"><code>Tx</code></a> type and provides some extra methods.</p>
<h2 id="associated-functions-15"><a class="header" href="#associated-functions-15">Associated functions</a></h2>
<h3 id="from_data-18"><a class="header" href="#from_data-18"><code>from_data</code></a></h3>
<pre><code class="language-helios">ScriptContext::from_data(data: Data) -&gt; ScriptContext
</code></pre>
<h3 id="new_certifying"><a class="header" href="#new_certifying"><code>new_certifying</code></a></h3>
<p>Construct a <code>ScriptContext</code> instance with a <code>staking</code>/<code>certifying</code> <a href="lang/builtins/./scriptpurpose.html"><code>ScriptPurpose</code></a>. <strong>Only available after <code>main</code></strong>, see <a href="lang/builtins/../script-structure.html#data-generators-and-test-functions-5">script structure</a>.</p>
<p>Throws an error if the current script purpose isn't <code>staking</code> or <code>testing</code>.</p>
<pre><code class="language-helios">ScriptContext::new_certifying(
    tx:    Tx,
    dcert: DCert
) -&gt; ScriptContext
</code></pre>
<h3 id="new_minting"><a class="header" href="#new_minting"><code>new_minting</code></a></h3>
<p>Construct a <code>ScriptContext</code> instance with a <code>minting</code> <a href="lang/builtins/./scriptpurpose.html"><code>ScriptPurpose</code></a>. <strong>Only available after <code>main</code></strong>, see <a href="lang/builtins/../script-structure.html#data-generators-and-test-functions-5">script structure</a>.</p>
<p>Throws an error if the current script purpose isn't <code>minting</code> or <code>testing</code>.</p>
<pre><code class="language-helios">ScriptContext::new_minting(
    tx:  Tx,
    mph: MintingPolicyHash
) -&gt; ScriptContext
</code></pre>
<h3 id="new_rewarding"><a class="header" href="#new_rewarding"><code>new_rewarding</code></a></h3>
<p>Construct a <code>ScriptContext</code> instance with a <code>staking</code>/<code>rewarding</code> <a href="lang/builtins/./scriptpurpose.html"><code>ScriptPurpose</code></a>. <strong>Only available after <code>main</code></strong>, see <a href="lang/builtins/../script-structure.html#data-generators-and-test-functions-5">script structure</a>.</p>
<p>Throws an error if the current script purpose isn't <code>staking</code> or <code>testing</code>.</p>
<pre><code class="language-helios">ScriptContext::new_rewarding(
    tx: Tx,
    sc: StakingCredential
) -&gt; ScriptContext
</code></pre>
<h3 id="new_spending"><a class="header" href="#new_spending"><code>new_spending</code></a></h3>
<p>Construct a <code>ScriptContext</code> instance with a <code>spending</code> <a href="lang/builtins/./scriptpurpose.html"><code>ScriptPurpose</code></a>. <strong>Only available after <code>main</code></strong>, see <a href="lang/builtins/../script-structure.html#data-generators-and-test-functions-5">script structure</a>.</p>
<p>Throws an error if the current script purpose isn't <code>spending</code> or <code>testing</code>.</p>
<pre><code class="language-helios">ScriptContext::new_spending(
    tx:        Tx,
    output_id: TxOutputId
) -&gt; ScriptContext
</code></pre>
<h2 id="getters-10"><a class="header" href="#getters-10">Getters</a></h2>
<h3 id="tx"><a class="header" href="#tx"><code>tx</code></a></h3>
<p>Get the <a href="lang/builtins/./tx.html"><code>Tx</code></a> data structure.</p>
<pre><code class="language-helios">ctx.tx -&gt; Tx
</code></pre>
<h2 id="operators-19"><a class="header" href="#operators-19">Operators</a></h2>
<h3 id="-81"><a class="header" href="#-81"><code>==</code></a></h3>
<pre><code class="language-helios">ScriptContext == ScriptContext -&gt; Bool
</code></pre>
<h3 id="-82"><a class="header" href="#-82"><code>!=</code></a></h3>
<pre><code class="language-helios">ScriptContext != ScriptContext -&gt; Bool
</code></pre>
<h2 id="methods-19"><a class="header" href="#methods-19">Methods</a></h2>
<h3 id="serialize-19"><a class="header" href="#serialize-19"><code>serialize</code></a></h3>
<p>Returns the cbor-serialization of the <code>ScriptContext</code>.</p>
<pre><code class="language-helios">ctx.serialize() -&gt; ByteArray
</code></pre>
<h3 id="get_spending_purpose_output_id"><a class="header" href="#get_spending_purpose_output_id"><code>get_spending_purpose_output_id</code></a></h3>
<p>Returns the <a href="lang/builtins/./txoutputid.html"><code>TxOutputId</code></a> of the current UTxO being spent.</p>
<p>Can only be called in <code>spending</code> purpose scripts, and throws an error otherwise.</p>
<pre><code class="language-helios">ctx.get_spending_purpose_output_id() -&gt; TxOutputId
</code></pre>
<h3 id="get_current_input"><a class="header" href="#get_current_input"><code>get_current_input</code></a></h3>
<p>Returns the current UTxO being spent as a <a href="lang/builtins/./txinput.html"><code>TxInput</code></a>.</p>
<p>Can only be called in <code>spending</code> purpose scripts, and throws an error otherwise.</p>
<pre><code class="language-helios">ctx.get_current_input() -&gt; TxInput
</code></pre>
<h3 id="get_cont_outputs"><a class="header" href="#get_cont_outputs"><code>get_cont_outputs</code></a></h3>
<p>Returns the <a href="lang/builtins/./txoutput.html"><code>outputs</code></a> sent back to the current validator script.</p>
<p>Can only be called in <code>spending</code> purpose scripts, and throws an error otherwise.</p>
<pre><code class="language-helios">ctx.get_cont_outputs() -&gt; []TxOutput
</code></pre>
<h3 id="get_current_validator_hash"><a class="header" href="#get_current_validator_hash"><code>get_current_validator_hash</code></a></h3>
<p>Returns the <a href="lang/builtins/./validatorhash.html"><code>ValidatorHash</code></a> of the current script.</p>
<p>Can only be called in <code>spending</code> purpose scripts, and throws an error otherwise.</p>
<pre><code class="language-helios">ctx.get_current_validator_hash() -&gt; ValidatorHash
</code></pre>
<h3 id="get_current_minting_policy_hash"><a class="header" href="#get_current_minting_policy_hash"><code>get_current_minting_policy_hash</code></a></h3>
<p>Returns the <a href="lang/builtins/./mintingpolicyhash.html"><code>MintingPolicyHash</code></a> of the minting policy being evaluated.</p>
<p>Can only be called in <code>minting</code> purpose scripts, and throws an error otherwise.</p>
<pre><code class="language-helios">ctx.get_current_minting_policy_hash() -&gt; MintingPolicyHash
</code></pre>
<h3 id="get_staking_purpose"><a class="header" href="#get_staking_purpose"><code>get_staking_purpose</code></a></h3>
<p>Returns the current <a href="lang/builtins/./stakingpurpose.html"><code>StakingPurpose</code></a> (<code>Rewarding</code> or <code>Certifying</code>).</p>
<p>Can only be called in <code>staking</code> purpose scripts, and throws an error otherwise.</p>
<pre><code class="language-helios">ctx.get_staking_purpose() -&gt; StakingPurpose
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scripthash"><a class="header" href="#scripthash"><code>ScriptHash</code></a></h1>
<p><a href="https://en.wikipedia.org/wiki/Opaque_data_type">Opaque</a> <a href="lang/builtins/./bytearray.html"><code>ByteArray</code></a> that represents either a <a href="lang/builtins/./validatorhash.html"><code>ValidatorHash</code></a>, a <a href="lang/builtins/./mintingpolicyhash.html"><code>MintingPolicyHash</code></a>, or a <a href="lang/builtins/./stakingvalidatorhash.html"><code>StakingValidatorHash</code></a>.</p>
<p>This is returned by the <a href="lang/builtins/./txoutput.html#ref_script_hash"><code>TxOutput.ref_script_hash</code></a> getter (a reference script can be any of the above script types).</p>
<h2 id="associated-functions-16"><a class="header" href="#associated-functions-16">Associated functions</a></h2>
<h3 id="from_data-19"><a class="header" href="#from_data-19"><code>from_data</code></a></h3>
<pre><code class="language-helios">ScriptHash::from_data(data: Data) -&gt; ScriptHash
</code></pre>
<h2 id="operators-20"><a class="header" href="#operators-20">Operators</a></h2>
<h3 id="-83"><a class="header" href="#-83"><code>==</code></a></h3>
<pre><code class="language-helios">ScriptHash == ScriptHash -&gt; Bool
</code></pre>
<h3 id="-84"><a class="header" href="#-84"><code>!=</code></a></h3>
<pre><code class="language-helios">ScriptHash != ScriptHash -&gt; Bool
</code></pre>
<h2 id="methods-20"><a class="header" href="#methods-20">Methods</a></h2>
<h3 id="serialize-20"><a class="header" href="#serialize-20"><code>serialize</code></a></h3>
<pre><code class="language-helios">script_hash.serialize() -&gt; ByteArray
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scriptpurpose"><a class="header" href="#scriptpurpose"><code>ScriptPurpose</code></a></h1>
<p>Each redemption in a transaction has a <code>ScriptPurpose</code> with the following 4 variants:</p>
<ul>
<li><code>Minting</code></li>
<li><code>Spending</code></li>
<li><code>Rewarding</code></li>
<li><code>Certifying</code></li>
</ul>
<p><code>ScriptPurpose::Rewarding</code> and <code>ScriptPurpose::Certifying</code> are identical to <a href="lang/builtins/./stakingpurpose.html"><code>StakingPurpose::Rewarding</code></a> and <a href="lang/builtins/./stakingpurpose.html"><code>StakingPurpose::Certifying</code></a> respectively, but the use cases are different. <code>StakingPurpose</code> is used for switching between rewarding and certifying within a given staking script. <code>ScriptPurpose</code> is used to see what other scripts are being used in the same transaction (see <a href="lang/builtins/./tx.html#redeemers"><code>tx.redeemers</code></a>).</p>
<h2 id="associated-functions-17"><a class="header" href="#associated-functions-17">Associated functions</a></h2>
<h3 id="from_data-20"><a class="header" href="#from_data-20"><code>from_data</code></a></h3>
<pre><code class="language-helios">ScriptPurpose::from_data(data: Data) -&gt; ScriptPurpose
</code></pre>
<h3 id="new_minting-1"><a class="header" href="#new_minting-1"><code>new_minting</code></a></h3>
<pre><code class="language-helios">ScriptPurpose::new_minting(mph: MintingPolicyHash) -&gt; ScriptPurpose::Minting
</code></pre>
<h3 id="new_spending-1"><a class="header" href="#new_spending-1"><code>new_spending</code></a></h3>
<pre><code class="language-helios">ScriptPurpose::new_spending(output_id: TxOutputId) -&gt; ScriptPurpose::Spending
</code></pre>
<h3 id="new_rewarding-1"><a class="header" href="#new_rewarding-1"><code>new_rewarding</code></a></h3>
<pre><code class="language-helios">ScriptPurpose::new_rewarding(staking_credential: StakingCredential) -&gt; ScriptPurpose::Rewarding
</code></pre>
<h3 id="new_certifying-1"><a class="header" href="#new_certifying-1"><code>new_certifying</code></a></h3>
<pre><code class="language-helios">ScriptPurpose::new_certifying(dcert: DCert) -&gt; ScriptPurpose::Certifying
</code></pre>
<h2 id="getters-11"><a class="header" href="#getters-11">Getters</a></h2>
<h3 id="scriptpurposeminting"><a class="header" href="#scriptpurposeminting"><code>ScriptPurpose::Minting</code></a></h3>
<h4 id="policy_hash"><a class="header" href="#policy_hash"><code>policy_hash</code></a></h4>
<p>Returnt the <a href="lang/builtins/./mintingpolicyhash.html"><code>MintingPolicyHash</code></a> of the UTxO whose minting or burning is being validated.</p>
<pre><code class="language-helios">minting_script_purpose.policy_hash -&gt; MintingPolicyHash
</code></pre>
<h3 id="scriptpurposespending"><a class="header" href="#scriptpurposespending"><code>ScriptPurpose::Spending</code></a></h3>
<h4 id="output_id"><a class="header" href="#output_id"><code>output_id</code></a></h4>
<p>Returns the <a href="lang/builtins/./txoutputid.html"><code>TxOutputId</code></a> of the UTxO whose spending is being validated.</p>
<pre><code class="language-helios">spending_script_purpose.output_id -&gt; TxOutputId
</code></pre>
<h3 id="scriptpurposerewarding"><a class="header" href="#scriptpurposerewarding"><code>ScriptPurpose::Rewarding</code></a></h3>
<h4 id="credential-4"><a class="header" href="#credential-4"><code>credential</code></a></h4>
<p>Returns the <a href="lang/builtins/./stakingcredential.html"><code>StakingCredential</code></a> for which rewards are being withdrawn.</p>
<pre><code class="language-helios">rewarding_script_purpose.credential -&gt; StakingCredential
</code></pre>
<h3 id="scriptpurposecertifying"><a class="header" href="#scriptpurposecertifying"><code>ScriptPurpose::Certifying</code></a></h3>
<h4 id="dcert-1"><a class="header" href="#dcert-1"><code>dcert</code></a></h4>
<p>Returns the current stake certifying action as a <a href="lang/builtins/./dcert.html"><code>DCert</code></a>.</p>
<pre><code class="language-helios">certifying_script_purpose.dcert -&gt; DCert
</code></pre>
<h2 id="operators-21"><a class="header" href="#operators-21">Operators</a></h2>
<h3 id="-85"><a class="header" href="#-85"><code>==</code></a></h3>
<pre><code class="language-helios">ScriptPurpose == ScriptPurpose -&gt; Bool
</code></pre>
<h3 id="-86"><a class="header" href="#-86"><code>!=</code></a></h3>
<pre><code class="language-helios">ScriptPurpose != ScriptPurpose -&gt; Bool
</code></pre>
<h2 id="methods-21"><a class="header" href="#methods-21">Methods</a></h2>
<h3 id="serialize-21"><a class="header" href="#serialize-21"><code>serialize</code></a></h3>
<pre><code class="language-helios">script_purpose.serialize() -&gt; ByteArray
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stakekeyhash"><a class="header" href="#stakekeyhash"><code>StakeKeyHash</code></a></h1>
<p><a href="https://en.wikipedia.org/wiki/Opaque_data_type">Opaque</a> <a href="lang/builtins/./bytearray.html"><code>ByteArray</code></a> that represents the hash of a staking key. </p>
<p>Example instantiation:</p>
<pre><code class="language-helios">skh: StakeKeyHash = StakeKeyHash::new(#...); ...
</code></pre>
<h2 id="associated-functions-18"><a class="header" href="#associated-functions-18">Associated functions</a></h2>
<h3 id="new-8"><a class="header" href="#new-8"><code>new</code></a></h3>
<pre><code class="language-helios">StakeKeyHash::new(bytes: ByteArray) -&gt; StakeKeyHash
</code></pre>
<h3 id="from_data-21"><a class="header" href="#from_data-21"><code>from_data</code></a></h3>
<pre><code class="language-helios">StakeKeyHash::from_data(data: Data) -&gt; StakeKeyHash
</code></pre>
<h2 id="operators-22"><a class="header" href="#operators-22">Operators</a></h2>
<h3 id="-87"><a class="header" href="#-87"><code>==</code></a></h3>
<pre><code class="language-helios">StakeKeyHash == StakeKeyHash -&gt; Bool
</code></pre>
<h3 id="-88"><a class="header" href="#-88"><code>!=</code></a></h3>
<pre><code class="language-helios">StakeKeyHash != StakeKeyHash -&gt; Bool
</code></pre>
<h3 id="-89"><a class="header" href="#-89"><code>&gt;=</code></a></h3>
<pre><code class="language-helios">StakeKeyHash &gt;= StakeKeyHash -&gt; Bool
</code></pre>
<h3 id="-90"><a class="header" href="#-90"><code>&gt;</code></a></h3>
<pre><code class="language-helios">StakeKeyHash &gt; StakeKeyHash -&gt; Bool
</code></pre>
<h3 id="-91"><a class="header" href="#-91"><code>&lt;=</code></a></h3>
<pre><code class="language-helios">StakeKeyHash &lt;= StakeKeyHash -&gt; Bool
</code></pre>
<h3 id="-92"><a class="header" href="#-92"><code>&lt;</code></a></h3>
<pre><code class="language-helios">StakeKeyHash &lt; StakeKeyHash -&gt; Bool
</code></pre>
<h2 id="methods-22"><a class="header" href="#methods-22">Methods</a></h2>
<h3 id="serialize-22"><a class="header" href="#serialize-22"><code>serialize</code></a></h3>
<pre><code class="language-helios">skh.serialize() -&gt; ByteArray
</code></pre>
<h3 id="show-8"><a class="header" href="#show-8"><code>show</code></a></h3>
<p>Hexadecimal representation of a <code>StakeKeyHash</code>.</p>
<pre><code class="language-helios">skh.show() -&gt; String
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stakingcredential"><a class="header" href="#stakingcredential"><code>StakingCredential</code></a></h1>
<p>Represents the staking part of an <a href="lang/builtins/./address.html"><code>Address</code></a>.</p>
<p><code>StakingCredential</code> is an enum with 2 variants:</p>
<ul>
<li><code>Hash</code></li>
<li><code>Ptr</code></li>
</ul>
<h2 id="associated-functions-19"><a class="header" href="#associated-functions-19">Associated functions</a></h2>
<h3 id="new_hash-1"><a class="header" href="#new_hash-1"><code>new_hash</code></a></h3>
<p>Constructs a new <code>StakingCredential</code> from <a href="lang/builtins/./stakinghash.html"><code>StakingHash</code></a> (which in turn is an enum that represents <code>StakeKeyHash</code>/<code>StakingValidatorHash</code>).</p>
<pre><code class="language-helios">StakingCredential::new_hash(staking_hash: StakingHash) -&gt; StakingCredential::Hash
</code></pre>
<h3 id="new_ptr"><a class="header" href="#new_ptr"><code>new_ptr</code></a></h3>
<pre><code class="language-helios">StakingCredential::new_ptr(a: Int, b: Int, c: Int) -&gt; StakingCredential::Ptr
</code></pre>
<h3 id="from_data-22"><a class="header" href="#from_data-22"><code>from_data</code></a></h3>
<pre><code class="language-helios">StakingCredential::from_data(data: Data) -&gt; StakingCredential
</code></pre>
<h2 id="getters-12"><a class="header" href="#getters-12">Getters</a></h2>
<h3 id="stakingcredentialhash"><a class="header" href="#stakingcredentialhash"><code>StakingCredential::Hash</code></a></h3>
<h4 id="hash-2"><a class="header" href="#hash-2"><code>hash</code></a></h4>
<p>Get the underlying <a href="lang/builtins/./stakinghash.html"><code>StakingHash</code></a>.</p>
<pre><code class="language-helios">staking_credential_hash.hash -&gt; StakingHash
</code></pre>
<p>The following example code can be used to extract the underlying <a href="lang/builtins/./stakingvalidatorhash.html"><code>StakingValidatorHash</code></a>:</p>
<pre><code class="language-helios">staking_credential.switch{
  h: Hash =&gt; h.hash.switch{
    v: Validator =&gt; v.hash,
    _ =&gt; error(&quot;not a StakingHash::Validator&quot;)
  }, 
  _ =&gt; error(&quot;not a StakingCredential::Hash&quot;)
}
</code></pre>
<h2 id="operators-23"><a class="header" href="#operators-23">Operators</a></h2>
<h3 id="-93"><a class="header" href="#-93"><code>==</code></a></h3>
<pre><code class="language-helios">StakingCredential == StakingCredential -&gt; Bool
</code></pre>
<h3 id="-94"><a class="header" href="#-94"><code>!=</code></a></h3>
<pre><code class="language-helios">StakingCredential != StakingCredential -&gt; Bool
</code></pre>
<h2 id="methods-23"><a class="header" href="#methods-23">Methods</a></h2>
<h3 id="serialize-23"><a class="header" href="#serialize-23"><code>serialize</code></a></h3>
<pre><code class="language-helios">staking_credential.serialize() -&gt; ByteArray
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stakinghash"><a class="header" href="#stakinghash"><code>StakingHash</code></a></h1>
<p>An enum with two variants: </p>
<ul>
<li><code>StakeKey</code> (wraps <a href="lang/builtins/./stakekeyhash.html"><code>StakeKeyHash</code></a>) </li>
<li><code>Validator</code> (wraps <a href="lang/builtins/./stakingvalidatorhash.html"><code>StakingValidatorHash</code></a>)</li>
</ul>
<br/>
<p>Example instantiation:</p>
<pre><code class="language-helios">stakekey_stakinghash: StakingHash::StakeKey = StakingHash::new_stakekey(StakeKeyHash::new(#...));

validator_stakinghash: StakingHash::Validator = StakingHash::new_validator(StakingValidatorHash::new(#...)); ...
</code></pre>
<h2 id="associated-functions-20"><a class="header" href="#associated-functions-20">Associated functions</a></h2>
<h3 id="new_stakekey"><a class="header" href="#new_stakekey"><code>new_stakekey</code></a></h3>
<pre><code class="language-helios">StakingHash::new_stakekey(skh: StakeKeyHash) -&gt; StakingHash::StakeKey
</code></pre>
<h3 id="new_validator-1"><a class="header" href="#new_validator-1"><code>new_validator</code></a></h3>
<pre><code class="language-helios">StakingHash::new_validator(svh: StakingValidatorHash) -&gt; StakingHash::Validator
</code></pre>
<h3 id="from_data-23"><a class="header" href="#from_data-23"><code>from_data</code></a></h3>
<pre><code class="language-helios">StakingHash::from_data(data: Data) -&gt; StakingHash
</code></pre>
<h2 id="getters-13"><a class="header" href="#getters-13">Getters</a></h2>
<h3 id="hash-3"><a class="header" href="#hash-3"><code>hash</code></a></h3>
<p>Get the underlying hash.</p>
<pre><code class="language-helios">stakekey_stakinghash.hash -&gt; StakeKeyHash

validator_stakinghash.hash -&gt; StakingValidatorHash
</code></pre>
<h2 id="operators-24"><a class="header" href="#operators-24">Operators</a></h2>
<h3 id="-95"><a class="header" href="#-95"><code>==</code></a></h3>
<pre><code class="language-helios">StakingHash == StakingHash -&gt; Bool
</code></pre>
<h3 id="-96"><a class="header" href="#-96"><code>!=</code></a></h3>
<pre><code class="language-helios">StakingHash != StakingHash -&gt; Bool
</code></pre>
<h2 id="methods-24"><a class="header" href="#methods-24">Methods</a></h2>
<h3 id="serialize-24"><a class="header" href="#serialize-24"><code>serialize</code></a></h3>
<pre><code class="language-helios">stakinghash.serialize() -&gt; ByteArray
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stakingpurpose"><a class="header" href="#stakingpurpose"><code>StakingPurpose</code></a></h1>
<p>A <code>staking</code> purpose script has a <code>StakingPurpose</code>, which is an enum with 2 variants:</p>
<ul>
<li><code>Rewarding</code></li>
<li><code>Certifying</code></li>
</ul>
<h2 id="associated-functions-21"><a class="header" href="#associated-functions-21">Associated functions</a></h2>
<h3 id="from_data-24"><a class="header" href="#from_data-24"><code>from_data</code></a></h3>
<pre><code class="language-helios">StakingPurpose::from_data(data: Data) -&gt; StakingPurpose
</code></pre>
<h2 id="getters-14"><a class="header" href="#getters-14">Getters</a></h2>
<h3 id="stakingpurposerewarding"><a class="header" href="#stakingpurposerewarding"><code>StakingPurpose::Rewarding</code></a></h3>
<h4 id="credential-5"><a class="header" href="#credential-5"><code>credential</code></a></h4>
<p>Returns the <a href="lang/builtins/./stakingcredential.html"><code>StakingCredential</code></a> for which rewards are being withdrawn.</p>
<pre><code class="language-helios">rewarding_staking_purpose.credential -&gt; StakingCredential
</code></pre>
<h3 id="stakingpurposecertifying"><a class="header" href="#stakingpurposecertifying"><code>StakingPurpose::Certifying</code></a></h3>
<h4 id="dcert-2"><a class="header" href="#dcert-2"><code>dcert</code></a></h4>
<p>Returns the current stake certifying action as a <a href="lang/builtins/./dcert.html"><code>DCert</code></a>.</p>
<pre><code class="language-helios">certifying_staking_purpose.dcert -&gt; DCert
</code></pre>
<h2 id="operators-25"><a class="header" href="#operators-25">Operators</a></h2>
<h3 id="-97"><a class="header" href="#-97"><code>==</code></a></h3>
<pre><code class="language-helios">StakingPurpose == StakingPurpose -&gt; Bool
</code></pre>
<h3 id="-98"><a class="header" href="#-98"><code>!=</code></a></h3>
<pre><code class="language-helios">StakingPurpose != StakingPurpose -&gt; Bool
</code></pre>
<h2 id="methods-25"><a class="header" href="#methods-25">Methods</a></h2>
<h3 id="serialize-25"><a class="header" href="#serialize-25"><code>serialize</code></a></h3>
<pre><code class="language-helios">staking_purpose.serialize() -&gt; ByteArray
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stakingvalidatorhash"><a class="header" href="#stakingvalidatorhash"><code>StakingValidatorHash</code></a></h1>
<p><a href="https://en.wikipedia.org/wiki/Opaque_data_type">Opaque</a> <a href="lang/builtins/./bytearray.html"><code>ByteArray</code></a> that represents the hash of a staking script.</p>
<h2 id="associated-functions-22"><a class="header" href="#associated-functions-22">Associated functions</a></h2>
<h3 id="new-9"><a class="header" href="#new-9"><code>new</code></a></h3>
<pre><code class="language-helios">StakingValidatorHash::new(bytes: ByteArray) -&gt; StakingValidatorHash
</code></pre>
<h3 id="from_data-25"><a class="header" href="#from_data-25"><code>from_data</code></a></h3>
<pre><code class="language-helios">StakingValidatorHash::from_data(data: Data) -&gt; StakingValidatorHash
</code></pre>
<h3 id="from_script_hash-1"><a class="header" href="#from_script_hash-1"><code>from_script_hash</code></a></h3>
<p>Casts the generic <a href="lang/builtins/./scripthash.html"><code>ScriptHash</code></a> type into <code>StakingValidatorHash</code>.</p>
<pre><code class="language-helios">StakingValidatorHash::from_script_hash(hash: ScriptHash) -&gt; StakingValidatorHash
</code></pre>
<h2 id="operators-26"><a class="header" href="#operators-26">Operators</a></h2>
<h3 id="-99"><a class="header" href="#-99"><code>==</code></a></h3>
<pre><code class="language-helios">StakingValidatorHash == StakingValidatorHash -&gt; Bool
</code></pre>
<h3 id="-100"><a class="header" href="#-100"><code>!=</code></a></h3>
<pre><code class="language-helios">StakingValidatorHash != StakingValidatorHash -&gt; Bool
</code></pre>
<h3 id="-101"><a class="header" href="#-101"><code>&gt;=</code></a></h3>
<pre><code class="language-helios">StakingValidatorHash &gt;= StakingValidatorHash -&gt; Bool
</code></pre>
<h3 id="-102"><a class="header" href="#-102"><code>&gt;</code></a></h3>
<pre><code class="language-helios">StakingValidatorHash &gt; StakingValidatorHash -&gt; Bool
</code></pre>
<h3 id="-103"><a class="header" href="#-103"><code>&lt;=</code></a></h3>
<pre><code class="language-helios">StakingValidatorHash &lt;= StakingValidatorHash -&gt; Bool
</code></pre>
<h3 id="-104"><a class="header" href="#-104"><code>&lt;</code></a></h3>
<pre><code class="language-helios">StakingValidatorHash &lt; StakingValidatorHash -&gt; Bool
</code></pre>
<h2 id="methods-26"><a class="header" href="#methods-26">Methods</a></h2>
<h3 id="serialize-26"><a class="header" href="#serialize-26"><code>serialize</code></a></h3>
<pre><code class="language-helios">staking_validator_hash.serialize() -&gt; ByteArray
</code></pre>
<h3 id="show-9"><a class="header" href="#show-9"><code>show</code></a></h3>
<p>Hexadecimal representation of the <code>StakingValidatorHash</code>.</p>
<pre><code class="language-helios">staking_validator_hash.show() -&gt; String
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-1"><a class="header" href="#string-1"><code>String</code></a></h1>
<p>Represents a piece of utf-8 text.</p>
<pre><code class="language-helios">string: String = &quot;Woah!&quot;; ...
</code></pre>
<h2 id="associated-functions-23"><a class="header" href="#associated-functions-23">Associated functions</a></h2>
<h3 id="from_data-26"><a class="header" href="#from_data-26"><code>from_data</code></a></h3>
<pre><code class="language-helios">String::from_data(data: Data) -&gt; String
</code></pre>
<h2 id="operators-27"><a class="header" href="#operators-27">Operators</a></h2>
<h3 id="-105"><a class="header" href="#-105"><code>==</code></a></h3>
<pre><code class="language-helios">String == String -&gt; Bool
</code></pre>
<h3 id="-106"><a class="header" href="#-106"><code>!=</code></a></h3>
<pre><code class="language-helios">String != String -&gt; Bool
</code></pre>
<h3 id="-107"><a class="header" href="#-107"><code>+</code></a></h3>
<p>String concatenation.</p>
<pre><code class="language-helios">String + String -&gt; String
</code></pre>
<h2 id="methods-27"><a class="header" href="#methods-27">Methods</a></h2>
<h3 id="serialize-27"><a class="header" href="#serialize-27"><code>serialize</code></a></h3>
<pre><code class="language-helios">string.serialize() -&gt; ByteArray
</code></pre>
<h3 id="encode_utf8"><a class="header" href="#encode_utf8"><code>encode_utf8</code></a></h3>
<p>Turns a <code>String</code> into a sequence of utf-8 bytes.</p>
<pre><code class="language-helios">string.encode_utf() -&gt; ByteArray
</code></pre>
<h3 id="starts_with-1"><a class="header" href="#starts_with-1"><code>starts_with</code></a></h3>
<p>Checks if a <code>String</code> starts with a given prefix.</p>
<pre><code class="language-helios">string.starts_with(prefix: String) -&gt; Bool
</code></pre>
<h3 id="ends_with-1"><a class="header" href="#ends_with-1"><code>ends_with</code></a></h3>
<p>Checks if a <code>String</code> ends with a given suffix.</p>
<pre><code class="language-helios">string.ends_with(suffix: String) -&gt; Bool
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time"><a class="header" href="#time"><code>Time</code></a></h1>
<p>Represents POSIX time in milliseconds (time since 1970/01/01 00:00:00 UTC).</p>
<h2 id="associated-functions-24"><a class="header" href="#associated-functions-24">Associated functions</a></h2>
<h3 id="new-10"><a class="header" href="#new-10"><code>new</code></a></h3>
<pre><code class="language-helios">Time::new(millis_since_1970: Int) -&gt; Time
</code></pre>
<h3 id="from_data-27"><a class="header" href="#from_data-27"><code>from_data</code></a></h3>
<pre><code class="language-helios">Time::from_data(data: Data) -&gt; Time
</code></pre>
<h2 id="operators-28"><a class="header" href="#operators-28">Operators</a></h2>
<h3 id="-108"><a class="header" href="#-108"><code>==</code></a></h3>
<pre><code class="language-helios">Time == Time -&gt; Bool
</code></pre>
<h3 id="-109"><a class="header" href="#-109"><code>!=</code></a></h3>
<pre><code class="language-helios">Time != Time -&gt; Bool
</code></pre>
<h3 id="-110"><a class="header" href="#-110"><code>&gt;=</code></a></h3>
<pre><code class="language-helios">Time &gt;= Time -&gt; Bool
</code></pre>
<h3 id="-111"><a class="header" href="#-111"><code>&gt;</code></a></h3>
<pre><code class="language-helios">Time &gt; Time -&gt; Bool
</code></pre>
<h3 id="-112"><a class="header" href="#-112"><code>&lt;=</code></a></h3>
<pre><code class="language-helios">Time &lt;= Time -&gt; Bool
</code></pre>
<h3 id="-113"><a class="header" href="#-113"><code>&lt;</code></a></h3>
<pre><code class="language-helios">Time &lt; Time -&gt; Bool
</code></pre>
<h3 id="-114"><a class="header" href="#-114"><code>+</code></a></h3>
<pre><code class="language-helios">Time + Duration -&gt; Time
</code></pre>
<h3 id="--4"><a class="header" href="#--4"><code>-</code></a></h3>
<p>Subtracting a <a href="lang/builtins/./duration.html"><code>Duration</code></a> from a <code>Time</code> is like adding a negative <a href="lang/builtins/./duration.html"><code>Duration</code></a>.</p>
<pre><code class="language-helios">Time - Duration -&gt; Time
</code></pre>
<p>The difference of two <code>Time</code> instances is a <a href="lang/builtins/./duration.html"><code>Duration</code></a>.</p>
<pre><code class="language-helios">Time - Time -&gt; Duration
</code></pre>
<h2 id="methods-28"><a class="header" href="#methods-28">Methods</a></h2>
<h3 id="serialize-28"><a class="header" href="#serialize-28"><code>serialize</code></a></h3>
<pre><code class="language-helios">time.serialize() -&gt; ByteArray
</code></pre>
<h3 id="show-10"><a class="header" href="#show-10"><code>show</code></a></h3>
<p>Decimal representation of the underlying raw <code>Int</code>.</p>
<pre><code class="language-helios">time.show() -&gt; String
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timerange"><a class="header" href="#timerange"><code>TimeRange</code></a></h1>
<p>This represents a range of time using a pair of <a href="lang/builtins/./time.html"><code>Time</code></a> values, or open ends.</p>
<h2 id="associated-functions-and-constants-3"><a class="header" href="#associated-functions-and-constants-3">Associated functions and constants</a></h2>
<h3 id="always"><a class="header" href="#always"><code>ALWAYS</code></a></h3>
<p>Represents a <code>TimeRange</code> going from negative to positive infinity, thus contains all possible <code>Time</code> values.</p>
<pre><code class="language-helios">TimeRange::ALWAYS -&gt; TimeRange
</code></pre>
<h3 id="never"><a class="header" href="#never"><code>NEVER</code></a></h3>
<p>Represents <code>TimeRange</code> going from positive to negative infinity. It contains nothing as it's an impossible range.</p>
<pre><code class="language-helios">TimeRange::NEVER -&gt; TimeRange
</code></pre>
<h3 id="from"><a class="header" href="#from"><code>from</code></a></h3>
<p>Returns a <code>TimeRange</code> that contains all <a href="lang/builtins/./time.html"><code>Time</code></a> values from <code>start</code> onwards.</p>
<pre><code class="language-helios">TimeRange::from(start: Time) -&gt; TimeRange
</code></pre>
<h3 id="to"><a class="header" href="#to"><code>to</code></a></h3>
<p>Returns a <code>TimeRange</code> that contains all <a href="lang/builtins/./time.html"><code>Time</code></a> values before <code>end</code>.</p>
<pre><code class="language-helios">TimeRange::to(end: Time) -&gt; TimeRange
</code></pre>
<h3 id="new-11"><a class="header" href="#new-11"><code>new</code></a></h3>
<p>Returns a <code>TimeRange</code> that contains all <a href="lang/builtins/./time.html"><code>Time</code></a> values between <code>start</code> and <code>end</code>.</p>
<pre><code class="language-helios">TimeRange::new(start: Time, end: Time) -&gt; TimeRange
</code></pre>
<h3 id="from_data-28"><a class="header" href="#from_data-28"><code>from_data</code></a></h3>
<pre><code class="language-helios">TimeRange::from_data(data: Data) -&gt; TimeRange
</code></pre>
<h2 id="getters-15"><a class="header" href="#getters-15">Getters</a></h2>
<h3 id="start"><a class="header" href="#start"><code>start</code></a></h3>
<p>Returns the start <a href="lang/builtins/./time.html"><code>Time</code></a> of a <code>TimeRange</code>. Throws an error if start is non-finite.</p>
<pre><code class="language-helios">time_range.start -&gt; Time
</code></pre>
<h3 id="end"><a class="header" href="#end"><code>end</code></a></h3>
<p>Returns the end <a href="lang/builtins/./time.html"><code>Time</code></a> of a <code>TimeRange</code>. Throws an error if end is non-finite.</p>
<pre><code class="language-helios">time_range.end -&gt; Time
</code></pre>
<h2 id="operators-29"><a class="header" href="#operators-29">Operators</a></h2>
<h3 id="-115"><a class="header" href="#-115"><code>==</code></a></h3>
<pre><code class="language-helios">TimeRange == TimeRange -&gt; Bool
</code></pre>
<h3 id="-116"><a class="header" href="#-116"><code>!=</code></a></h3>
<pre><code class="language-helios">TimeRange != TimeRange -&gt; Bool
</code></pre>
<h2 id="methods-29"><a class="header" href="#methods-29">Methods</a></h2>
<h3 id="serialize-29"><a class="header" href="#serialize-29"><code>serialize</code></a></h3>
<pre><code class="language-helios">time_range.serialize() -&gt; ByteArray
</code></pre>
<h3 id="contains"><a class="header" href="#contains"><code>contains</code></a></h3>
<p>Returns <code>true</code> if a <code>TimeRange</code> contains the given time.</p>
<pre><code class="language-helios">time_range.contains(time: Time) -&gt; Bool
</code></pre>
<h3 id="is_before"><a class="header" href="#is_before"><code>is_before</code></a></h3>
<p>Returns <code>true</code> if the end of a <code>TimeRange</code> is before the given time. Always returns <code>false</code> if the end of the <code>TimeRange</code> is positive infinity.</p>
<pre><code class="language-helios">time_range.is_before(time: Time) -&gt; Bool
</code></pre>
<h3 id="is_after"><a class="header" href="#is_after"><code>is_after</code></a></h3>
<p>Returns <code>true</code> if the start of a <code>TimeRange</code> is after the given time. Always returns <code>false</code> if the start of the <code>TimeRange</code> is negative infinity.</p>
<pre><code class="language-helios">time_range.is_after(time: Time) -&gt; Bool
</code></pre>
<h3 id="show-11"><a class="header" href="#show-11"><code>show</code></a></h3>
<pre><code class="language-helios">time_range.show() -&gt; String
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tx-1"><a class="header" href="#tx-1"><code>Tx</code></a></h1>
<p>Represents a balanced transaction.</p>
<h2 id="associated-functions-25"><a class="header" href="#associated-functions-25">Associated functions</a></h2>
<h3 id="from_data-29"><a class="header" href="#from_data-29"><code>from_data</code></a></h3>
<pre><code class="language-helios">Tx::from_data(data: Data) -&gt; Tx
</code></pre>
<h3 id="new-12"><a class="header" href="#new-12"><code>new</code></a></h3>
<p>Construct a <code>Tx</code> instance. <strong>Only available after <code>main</code></strong>, see <a href="lang/builtins/../script-structure.html#data-generators-and-test-functions-5">script structure</a>.</p>
<pre><code class="language-helios">Tx::new(
    inputs:      []TxInput,
    ref_inputs:  []TxInput,
    outputs:     []TxOutput,
    fee:         Value,
    minted:      Value,
    dcerts:      []DCert,
    withdrawals: Map[StakingCredential]Int,
    time_range:  TimeRange,
    signatories: []PubKeyHash,
    redeemers:   Map[ScriptPurpose]AnyType,
    datums:      Map[DatumHash]AnyType
) -&gt; Tx
</code></pre>
<blockquote>
<p><strong>Note</strong>: the value type of the <code>redeemers</code> and <code>datums</code> fields can be any type when instantiating a new <code>Tx</code> instance. But when getting the <code>redeemers</code> and the <code>datums</code> the value type is actually <code>Data</code> (see <a href="lang/builtins/./tx.html#redeemers"><code>redeemers</code></a> and <a href="lang/builtins/./tx.html#datums"><code>datums</code></a>).</p>
</blockquote>
<h2 id="getters-16"><a class="header" href="#getters-16">Getters</a></h2>
<h3 id="inputs"><a class="header" href="#inputs"><code>inputs</code></a></h3>
<p>Returns the list of <a href="lang/builtins/./txinput.html"><code>TxInput</code></a>s of the transaction.</p>
<pre><code class="language-helios">tx.inputs -&gt; []TxInput
</code></pre>
<h3 id="ref_inputs"><a class="header" href="#ref_inputs"><code>ref_inputs</code></a></h3>
<p>Returns the list of reference inputs (as <code>[]</code><a href="lang/builtins/./txinput.html"><code>TxInput</code></a>) of the transaction.</p>
<pre><code class="language-helios">tx.ref_inputs -&gt; []TxInput
</code></pre>
<h3 id="outputs"><a class="header" href="#outputs"><code>outputs</code></a></h3>
<p>Returns the list of <a href="lang/builtins/./txoutput.html"><code>TxOutput</code></a>s of the transaction.</p>
<pre><code class="language-helios">tx.outputs -&gt; []TxOutput
</code></pre>
<h3 id="fee"><a class="header" href="#fee"><code>fee</code></a></h3>
<p>Returns the fee <a href="lang/builtins/./value.html"><code>Value</code></a> paid for the transaction.</p>
<pre><code class="language-helios">tx.fee -&gt; Value
</code></pre>
<h3 id="minted"><a class="header" href="#minted"><code>minted</code></a></h3>
<p>Returns the <a href="lang/builtins/./value.html"><code>Value</code></a> minted by the transaction.</p>
<pre><code class="language-helios">tx.minted -&gt; Value
</code></pre>
<h3 id="dcerts"><a class="header" href="#dcerts"><code>dcerts</code></a></h3>
<p>Returns the list of <a href="lang/builtins/./dcert.html"><code>DCert</code></a>s of the transaction (i.e. list of staking certifying actions).</p>
<pre><code class="language-helios">tx.dcerts -&gt; []DCert
</code></pre>
<h3 id="withdrawals"><a class="header" href="#withdrawals"><code>withdrawals</code></a></h3>
<p>Returns a <a href="lang/builtins/./map.html">map</a> of staking reward withdrawals. The map value <code>Int</code>s are lovelace quantities.</p>
<pre><code class="language-helios">tx.withdrawals -&gt; Map[StakingCredential]Int
</code></pre>
<h3 id="time_range"><a class="header" href="#time_range"><code>time_range</code></a></h3>
<p>Returns the valid <a href="lang/builtins/./timerange.html"><code>TimeRange</code></a> of the transaction. This <a href="lang/builtins/./timerange.html"><code>TimeRange</code></a> must contain the current time.</p>
<pre><code class="language-helios">tx.time_range -&gt; TimeRange
</code></pre>
<blockquote>
<p><strong>Note</strong>: we can't access the current time from within the validator script because it would lead to differing evaluation results as the tx propagates across the network. Instead we can use <code>tx.time_range</code> as an approximation of the current time.</p>
</blockquote>
<h3 id="signatories"><a class="header" href="#signatories"><code>signatories</code></a></h3>
<p>Returns the list of explicit transaction signers as <code>[]</code><a href="lang/builtins/./pubkeyhash.html"><code>PubKeyHash</code></a>.</p>
<pre><code class="language-helios">tx.signatories -&gt; []PubKeyHash
</code></pre>
<h3 id="redeemers"><a class="header" href="#redeemers"><code>redeemers</code></a></h3>
<p>Returns all the redeemers of the transaction as a map with <code>ScriptPurpose</code> keys, and <code>Data</code> values. This allows more complex interactions between different scripts being used in the same transaction.</p>
<pre><code class="language-helios">tx.redeemers -&gt; Map[ScriptPurpose]Data
</code></pre>
<h3 id="datums"><a class="header" href="#datums"><code>datums</code></a></h3>
<p>Returns a <a href="lang/builtins/./map.html"><code>Map</code></a> of <a href="lang/builtins/./datumhash.html"><code>DatumHash</code>es</a> to raw <a href="lang/builtins/./data.html"><code>Data</code></a>. This can be used to get the datum content of any <a href="lang/builtins/./txinput.html"><code>TxInput</code></a> that doesn't use inline datums.</p>
<pre><code class="language-helios">tx.datums -&gt; Map[DatumHash]Data
</code></pre>
<h3 id="id"><a class="header" href="#id"><code>id</code></a></h3>
<p>Returns the hash of the current transaction as <a href="lang/builtins/./txid.html"><code>TxId</code></a>.</p>
<pre><code class="language-helios">tx.id -&gt; TxId
</code></pre>
<h2 id="operators-30"><a class="header" href="#operators-30">Operators</a></h2>
<h3 id="-117"><a class="header" href="#-117"><code>==</code></a></h3>
<pre><code class="language-helios">Tx == Tx -&gt; Bool
</code></pre>
<h3 id="-118"><a class="header" href="#-118"><code>!=</code></a></h3>
<pre><code class="language-helios">Tx != Tx -&gt; Bool
</code></pre>
<h2 id="methods-30"><a class="header" href="#methods-30">Methods</a></h2>
<h3 id="serialize-30"><a class="header" href="#serialize-30"><code>serialize</code></a></h3>
<pre><code class="language-helios">tx.serialize() -&gt; ByteArray
</code></pre>
<h3 id="is_signed_by"><a class="header" href="#is_signed_by"><code>is_signed_by</code></a></h3>
<p>Returns <code>true</code> if the transaction was signed by the given pubkeyhash.</p>
<pre><code class="language-helios">tx.is_signed_by(pubkeyhash: PubKeyHash) -&gt; Bool
</code></pre>
<h3 id="find_datum_hash"><a class="header" href="#find_datum_hash"><code>find_datum_hash</code></a></h3>
<p>Returns the <a href="lang/builtins/./datumhash.html"><code>DatumHash</code></a> of datum data used in one the UTxO inputs.</p>
<pre><code class="language-helios">tx.find_datum_hash(data: AnyType) -&gt; ByteArray
</code></pre>
<h3 id="get_datum_data"><a class="header" href="#get_datum_data"><code>get_datum_data</code></a></h3>
<p>Returns the datum <a href="lang/builtins/./data.html"><code>Data</code></a> of a <a href="lang/builtins/./txoutput.html"><code>TxOutput</code></a>. Throws an error if no datum is attached to the output.</p>
<pre><code class="language-helios">tx.get_datum_data(output: TxOutput) -&gt; Data
</code></pre>
<h3 id="outputs_sent_to"><a class="header" href="#outputs_sent_to"><code>outputs_sent_to</code></a></h3>
<p>Returns the <a href="lang/builtins/./txoutput.html"><code>TxOutput</code></a>s sent to a regular payment address.</p>
<pre><code class="language-helios">tx.outputs_sent_to(pkh: PubKeyHash) -&gt; []TxOutput
</code></pre>
<h3 id="outputs_sent_to_datum"><a class="header" href="#outputs_sent_to_datum"><code>outputs_sent_to_datum</code></a></h3>
<p>Returns the <a href="lang/builtins/./txoutput.html"><code>TxOutput</code></a>s sent to a regular payment address tagged with the given datum (datum tagging can be used to prevent double satisfaction exploits).</p>
<pre><code class="language-helios">tx.outputs_sent_to_datum(
    pkh: PubKeyHash, 
    datum: AnyType, 
    is_inline: Bool
) -&gt; []TxOutput
</code></pre>
<h3 id="outputs_locked_by"><a class="header" href="#outputs_locked_by"><code>outputs_locked_by</code></a></h3>
<p>Returns the <a href="lang/builtins/./txoutput.html"><code>TxOutput</code></a>s being locked at the given script address.</p>
<pre><code class="language-helios">tx.outputs_locked_by(script_hash: ValidatorHash) -&gt; []TxOutput
</code></pre>
<h3 id="outputs_locked_by_datum"><a class="header" href="#outputs_locked_by_datum"><code>outputs_locked_by_datum</code></a></h3>
<p>Returns the <a href="lang/builtins/./txoutput.html"><code>TxOutput</code></a>s being locked at the given script address with the given datum.</p>
<pre><code class="language-helios">tx.outputs_locked_by_datum(
    script_hash: ValidatorHash, 
    datum: AnyType, 
    is_inline: Bool
) -&gt; []TxOutput
</code></pre>
<h3 id="value_sent_to"><a class="header" href="#value_sent_to"><code>value_sent_to</code></a></h3>
<p>Returns the output <a href="lang/builtins/./value.html"><code>Value</code></a> sent to a regular payment address.</p>
<pre><code class="language-helios">tx.value_sent_to(addr: PubKeyHash) -&gt; Value
</code></pre>
<h3 id="value_sent_to_datum"><a class="header" href="#value_sent_to_datum"><code>value_sent_to_datum</code></a></h3>
<p>Returns the output <a href="lang/builtins/./value.html"><code>Value</code></a> sent to a regular payment address tagged with the given datum (datum tagging can be used to prevent double satisfaction exploits).</p>
<pre><code class="language-helios">tx.value_sent_to_datum(
    addr: PubKeyHash, 
    datum: AnyType, 
    is_inline: Bool
) -&gt; Value
</code></pre>
<h3 id="value_locked_by"><a class="header" href="#value_locked_by"><code>value_locked_by</code></a></h3>
<p>Returns the output <a href="lang/builtins/./value.html"><code>Value</code></a> being locked at the given script address.</p>
<pre><code class="language-helios">tx.value_locked_by(script_hash: ValidatorHash) -&gt; Value
</code></pre>
<h3 id="value_locked_by_datum"><a class="header" href="#value_locked_by_datum"><code>value_locked_by_datum</code></a></h3>
<p>Returns the output <a href="lang/builtins/./value.html"><code>Value</code></a> being locked at the given script address with the given datum.</p>
<pre><code class="language-helios">tx.value_locked_by_datum(
    script_hash: ValidatorHash, 
    datum: AnyType, 
    is_inline: Bool
) -&gt; Value
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="txid"><a class="header" href="#txid"><code>TxId</code></a></h1>
<p>This is a type-safe wrapper around <code>ByteArray</code> representing the hash of a transaction.</p>
<h2 id="associated-functions-26"><a class="header" href="#associated-functions-26">Associated functions</a></h2>
<h3 id="new-13"><a class="header" href="#new-13"><code>new</code></a></h3>
<pre><code class="language-helios">TxId::new(bytes: ByteArray) -&gt; TxId
</code></pre>
<h3 id="from_data-30"><a class="header" href="#from_data-30"><code>from_data</code></a></h3>
<pre><code class="language-helios">TxId::from_data(data: Data) -&gt; TxId
</code></pre>
<h2 id="operators-31"><a class="header" href="#operators-31">Operators</a></h2>
<h3 id="-119"><a class="header" href="#-119"><code>==</code></a></h3>
<pre><code class="language-helios">TxId == TxId -&gt; Bool
</code></pre>
<h3 id="-120"><a class="header" href="#-120"><code>!=</code></a></h3>
<pre><code class="language-helios">TxId != TxId -&gt; Bool
</code></pre>
<h3 id="-121"><a class="header" href="#-121"><code>&gt;=</code></a></h3>
<pre><code class="language-helios">TxId &gt;= TxId -&gt; Bool
</code></pre>
<h3 id="-122"><a class="header" href="#-122"><code>&gt;</code></a></h3>
<pre><code class="language-helios">TxId &gt; TxId -&gt; Bool
</code></pre>
<h3 id="-123"><a class="header" href="#-123"><code>&lt;=</code></a></h3>
<pre><code class="language-helios">TxId &lt;= TxId -&gt; Bool
</code></pre>
<h3 id="-124"><a class="header" href="#-124"><code>&lt;</code></a></h3>
<pre><code class="language-helios">TxId &lt; TxId -&gt; Bool
</code></pre>
<h2 id="methods-31"><a class="header" href="#methods-31">Methods</a></h2>
<h3 id="serialize-31"><a class="header" href="#serialize-31"><code>serialize</code></a></h3>
<pre><code class="language-helios">tx_id.serialize() -&gt; ByteArray
</code></pre>
<h3 id="show-12"><a class="header" href="#show-12"><code>show</code></a></h3>
<p>Hexadecimal representation of a <code>TxId</code>.</p>
<pre><code class="language-helios">tx_id.show() -&gt; String
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="txinput"><a class="header" href="#txinput"><code>TxInput</code></a></h1>
<p>Represents a <strong>transaction input</strong>.</p>
<h2 id="associated-functions-27"><a class="header" href="#associated-functions-27">Associated functions</a></h2>
<h3 id="from_data-31"><a class="header" href="#from_data-31"><code>from_data</code></a></h3>
<pre><code class="language-helios">TxInput::from_data(data: Data) -&gt; TxInput
</code></pre>
<h3 id="new-14"><a class="header" href="#new-14"><code>new</code></a></h3>
<p>Construct a <code>TxInput</code> instance. <strong>Only available after <code>main</code></strong>, see <a href="lang/builtins/../script-structure.html#data-generators-and-test-functions-5">script structure</a>.</p>
<pre><code class="language-helios">TxInput::new(
    output_id: TxOutputId,
    output:    TxOutput
) -&gt; TxInput
</code></pre>
<h2 id="getters-17"><a class="header" href="#getters-17">Getters</a></h2>
<h3 id="output_id-1"><a class="header" href="#output_id-1"><code>output_id</code></a></h3>
<p>Returns the <a href="lang/builtins/./txoutputid.html"><code>TxOutputId</code></a> of the underlying UTxO.</p>
<pre><code class="language-helios">tx_input.output_id -&gt; TxOutputId
</code></pre>
<h3 id="output"><a class="header" href="#output"><code>output</code></a></h3>
<p>Returns the underlying UTxO as a <a href="lang/builtins/./txoutput.html"><code>TxOutput</code></a>.</p>
<pre><code class="language-helios">tx_input.output -&gt; TxOutput
</code></pre>
<h2 id="operators-32"><a class="header" href="#operators-32">Operators</a></h2>
<h3 id="-125"><a class="header" href="#-125"><code>==</code></a></h3>
<pre><code class="language-helios">TxInput == TxInput -&gt; Bool
</code></pre>
<h3 id="-126"><a class="header" href="#-126"><code>!=</code></a></h3>
<pre><code class="language-helios">TxInput != TxInput -&gt; Bool
</code></pre>
<h2 id="methods-32"><a class="header" href="#methods-32">Methods</a></h2>
<h3 id="serialize-32"><a class="header" href="#serialize-32"><code>serialize</code></a></h3>
<pre><code class="language-helios">tx_input.serialize() -&gt; ByteArray
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="txoutput"><a class="header" href="#txoutput"><code>TxOutput</code></a></h1>
<p>Represents a <strong>transaction output</strong>.</p>
<h2 id="associated-functions-28"><a class="header" href="#associated-functions-28">Associated functions</a></h2>
<h3 id="from_data-32"><a class="header" href="#from_data-32"><code>from_data</code></a></h3>
<pre><code class="language-helios">TxOutput::from_data(data: Data) -&gt; TxOutput
</code></pre>
<h3 id="new-15"><a class="header" href="#new-15"><code>new</code></a></h3>
<p>Construct a <code>TxOutput</code> instance.</p>
<pre><code class="language-helios">TxOutput::new(
    address: Address,
    value:   Value,
    datum:   OutputDatum
) -&gt; TxOutput
</code></pre>
<h2 id="getters-18"><a class="header" href="#getters-18">Getters</a></h2>
<h3 id="address-2"><a class="header" href="#address-2"><code>address</code></a></h3>
<p>Returns the <a href="lang/builtins/./address.html"><code>Address</code></a> at which the <code>TxOutput</code> is located.</p>
<pre><code class="language-helios">tx_output.address -&gt; Address
</code></pre>
<h3 id="value"><a class="header" href="#value"><code>value</code></a></h3>
<p>Returns the <a href="lang/builtins/./value.html"><code>Value</code></a> locked in the <code>TxOutput</code>.</p>
<pre><code class="language-helios">tx_output.value -&gt; Value
</code></pre>
<h3 id="datum-1"><a class="header" href="#datum-1"><code>datum</code></a></h3>
<p>Returns the datum of the <code>TxOutput</code> as an <a href="lang/builtins/./outputdatum.html"><code>OutputDatum</code></a>.</p>
<pre><code class="language-helios">tx_output.datum -&gt; OutputDatum
</code></pre>
<h3 id="ref_script_hash"><a class="header" href="#ref_script_hash"><code>ref_script_hash</code></a></h3>
<p>Returns the <a href="lang/builtins/./scripthash.html"><code>ScriptHash</code></a> of the optional reference script attached to the <code>TxOutput</code>.</p>
<pre><code class="language-helios">tx_output.ref_script_hash -&gt; Option[ScriptHash]
</code></pre>
<h2 id="operators-33"><a class="header" href="#operators-33">Operators</a></h2>
<h3 id="-127"><a class="header" href="#-127"><code>==</code></a></h3>
<pre><code class="language-helios">TxOutput == TxOutput -&gt; Bool
</code></pre>
<h3 id="-128"><a class="header" href="#-128"><code>!=</code></a></h3>
<pre><code class="language-helios">TxOutput != TxOutput -&gt; Bool
</code></pre>
<h2 id="methods-33"><a class="header" href="#methods-33">Methods</a></h2>
<h3 id="serialize-33"><a class="header" href="#serialize-33"><code>serialize</code></a></h3>
<pre><code class="language-helios">tx_output.serialize() -&gt; ByteArray
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="txoutputid"><a class="header" href="#txoutputid"><code>TxOutputId</code></a></h1>
<p>Represents the unique ID of a UTxO. It's composed of the <strong>transaction ID</strong> (<a href="lang/builtins/./txid.html"><code>TxId</code></a>) of the transaction that created that UTxO, and of the index (<a href="lang/builtins/./int.html"><code>Int</code></a>) of that UTxO in the outputs of that transaction.</p>
<h2 id="associated-functions-29"><a class="header" href="#associated-functions-29">Associated functions</a></h2>
<h3 id="new-16"><a class="header" href="#new-16"><code>new</code></a></h3>
<pre><code class="language-helios">TxOutputId::new(tx_id: TxId, index: Int) -&gt; TxOutputId
</code></pre>
<h3 id="from_data-33"><a class="header" href="#from_data-33"><code>from_data</code></a></h3>
<pre><code class="language-helios">TxOutputId::from_data(data: Data) -&gt; TxOutputId
</code></pre>
<h2 id="getters-19"><a class="header" href="#getters-19">Getters</a></h2>
<h3 id="index"><a class="header" href="#index"><code>index</code></a></h3>
<p>Index of the UTxO in the producing transaction:</p>
<pre><code class="language-helios">tx_output_id.index -&gt; Int
</code></pre>
<h3 id="tx_id"><a class="header" href="#tx_id"><code>tx_id</code></a></h3>
<p><code>TxId</code> of the producing transaction:</p>
<pre><code class="language-helios">tx_output_id.tx_id -&gt; TxId
</code></pre>
<h2 id="operators-34"><a class="header" href="#operators-34">Operators</a></h2>
<h3 id="-129"><a class="header" href="#-129"><code>==</code></a></h3>
<pre><code class="language-helios">TxOutputId == TxOutputId -&gt; Bool
</code></pre>
<h3 id="-130"><a class="header" href="#-130"><code>!=</code></a></h3>
<pre><code class="language-helios">TxOutputId != TxOutputId -&gt; Bool
</code></pre>
<h3 id="-131"><a class="header" href="#-131"><code>&gt;=</code></a></h3>
<p>First compares bytes of <a href="lang/builtins/./txid.html"><code>TxId</code></a>, then compares index.</p>
<pre><code class="language-helios">TxOutputId &gt;= TxOutputId -&gt; Bool
</code></pre>
<h3 id="-132"><a class="header" href="#-132"><code>&gt;</code></a></h3>
<p>First compares bytes of <a href="lang/builtins/./txid.html"><code>TxId</code></a>, then compares index.</p>
<pre><code class="language-helios">TxOutputId &gt; TxOutputId -&gt; Bool
</code></pre>
<h3 id="-133"><a class="header" href="#-133"><code>&lt;=</code></a></h3>
<p>First compares bytes of <a href="lang/builtins/./txid.html"><code>TxId</code></a>, then compares index.</p>
<pre><code class="language-helios">TxOutputId &lt;= TxOutputId -&gt; Bool
</code></pre>
<h3 id="-134"><a class="header" href="#-134"><code>&lt;</code></a></h3>
<p>First compares bytes of <a href="lang/builtins/./txid.html"><code>TxId</code></a>, then compares index.</p>
<pre><code class="language-helios">TxOutputId &lt; TxOutputId -&gt; Bool
</code></pre>
<h2 id="methods-34"><a class="header" href="#methods-34">Methods</a></h2>
<h3 id="serialize-34"><a class="header" href="#serialize-34"><code>serialize</code></a></h3>
<pre><code class="language-helios">tx_output_id.serialize() -&gt; ByteArray
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validatorhash"><a class="header" href="#validatorhash"><code>ValidatorHash</code></a></h1>
<p><a href="https://en.wikipedia.org/wiki/Opaque_data_type">Opaque</a> <a href="lang/builtins/./bytearray.html"><code>ByteArray</code></a> that represents the hash of a validator script.</p>
<p>The first part of a script address is formed by a <code>ValidatorHash</code>.</p>
<h2 id="associated-functions-30"><a class="header" href="#associated-functions-30">Associated functions</a></h2>
<h3 id="new-17"><a class="header" href="#new-17"><code>new</code></a></h3>
<pre><code class="language-helios">ValidatorHash::new(bytes: ByteArray) -&gt; ValidatorHash
</code></pre>
<h3 id="from_data-34"><a class="header" href="#from_data-34"><code>from_data</code></a></h3>
<pre><code class="language-helios">ValidatorHash::from_data(data: Data) -&gt; ValidatorHash
</code></pre>
<h3 id="from_script_hash-2"><a class="header" href="#from_script_hash-2"><code>from_script_hash</code></a></h3>
<p>Casts the generic <a href="lang/builtins/./scripthash.html"><code>ScriptHash</code></a> type into <code>ValidatorHash</code>.</p>
<pre><code class="language-helios">ValidatorHash::from_script_hash(hash: ScriptHash) -&gt; ValidatorHash
</code></pre>
<h2 id="operators-35"><a class="header" href="#operators-35">Operators</a></h2>
<h3 id="-135"><a class="header" href="#-135"><code>==</code></a></h3>
<pre><code class="language-helios">ValidatorHash == ValidatorHash -&gt; Bool
</code></pre>
<h3 id="-136"><a class="header" href="#-136"><code>!=</code></a></h3>
<pre><code class="language-helios">ValidatorHash != ValidatorHash -&gt; Bool
</code></pre>
<h3 id="-137"><a class="header" href="#-137"><code>&gt;=</code></a></h3>
<pre><code class="language-helios">ValidatorHash &gt;= ValidatorHash -&gt; Bool
</code></pre>
<h3 id="-138"><a class="header" href="#-138"><code>&gt;</code></a></h3>
<pre><code class="language-helios">ValidatorHash &gt; ValidatorHash -&gt; Bool
</code></pre>
<h3 id="-139"><a class="header" href="#-139"><code>&lt;=</code></a></h3>
<pre><code class="language-helios">ValidatorHash &lt;= ValidatorHash -&gt; Bool
</code></pre>
<h3 id="-140"><a class="header" href="#-140"><code>&lt;</code></a></h3>
<pre><code class="language-helios">ValidatorHash &lt; ValidatorHash -&gt; Bool
</code></pre>
<h2 id="methods-35"><a class="header" href="#methods-35">Methods</a></h2>
<h3 id="serialize-35"><a class="header" href="#serialize-35"><code>serialize</code></a></h3>
<pre><code class="language-helios">validator_hash.serialize() -&gt; ByteArray
</code></pre>
<h3 id="show-13"><a class="header" href="#show-13"><code>show</code></a></h3>
<p>Hexadecimal representation of the <code>ValidatorHash</code>.</p>
<pre><code class="language-helios">validator_hash.show() -&gt; String
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="value-1"><a class="header" href="#value-1"><code>Value</code></a></h1>
<p>The <code>Value</code> type represents monetary value as a <strong>token bundle</strong> (internally represented as a <code>Map[</code><a href="lang/builtins/./mintingpolicyhash.html"><code>MintingPolicyHash</code></a><code>]Map[</code><a href="lang/builtins/./bytearray.html"><code>ByteArray</code></a><code>]</code><a href="lang/builtins/./int.html"><code>Int</code></a>)</p>
<blockquote>
<p><strong>Note</strong>: 1 ADA is equal to 1 million Lovelace</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: You might find yourself comparing the output of <code>value.get()</code> to a number in order to check if <code>value</code> contains something, but in that case it is usually better to use the <code>value.contains()</code> method instead.</p>
</blockquote>
<h2 id="associated-functions-and-constants-4"><a class="header" href="#associated-functions-and-constants-4">Associated functions and constants</a></h2>
<h3 id="zero"><a class="header" href="#zero"><code>ZERO</code></a></h3>
<p>An empty <code>Value</code>.</p>
<pre><code class="language-helios">Value::ZERO -&gt; Value
</code></pre>
<h3 id="lovelace"><a class="header" href="#lovelace"><code>lovelace</code></a></h3>
<p>Returns a <code>Value</code> containing only lovelace.</p>
<pre><code class="language-helios">Value::lovelace(amount: Int) -&gt; Value
</code></pre>
<h3 id="new-18"><a class="header" href="#new-18"><code>new</code></a></h3>
<p>Returns a <code>Value</code> containing an amount of a given <a href="lang/builtins/./assetclass.html"><code>AssetClass</code></a>.</p>
<pre><code class="language-helios">Value::new(asset_class: AssetClass, amount: Int) -&gt; Value
</code></pre>
<h3 id="from_data-35"><a class="header" href="#from_data-35"><code>from_data</code></a></h3>
<pre><code class="language-helios">Value::from_data(data: Data) -&gt; Value
</code></pre>
<h3 id="from_map"><a class="header" href="#from_map"><code>from_map</code></a></h3>
<p>Instantiates a <code>Value</code> using a raw map.</p>
<pre><code class="language-helios">Value::from_map(raw_value: Map[MintingPolicyHash]Map[ByteArray]Int) -&gt; Value
</code></pre>
<h2 id="operators-36"><a class="header" href="#operators-36">Operators</a></h2>
<h3 id="-141"><a class="header" href="#-141"><code>==</code></a></h3>
<p>Returns <code>true</code> if two <code>Value</code>s are the same.</p>
<pre><code class="language-helios">Value == Value -&gt; Bool
</code></pre>
<blockquote>
<p><strong>Note</strong>: the assets and tokens must also be in the same order for <code>==</code> to return <code>true</code>.</p>
</blockquote>
<h3 id="-142"><a class="header" href="#-142"><code>!=</code></a></h3>
<pre><code class="language-helios">Value != Value -&gt; Bool
</code></pre>
<h3 id="-143"><a class="header" href="#-143"><code>&gt;=</code></a></h3>
<p>Strict greater-equals comparison. If every lhs token has a greater-or-equals amount than the equivalent rhs token then <code>&gt;=</code> returns <code>true</code>. If any rhs token has a greater amount than the equivalent lhs token then <code>&gt;=</code> returns <code>false</code>.</p>
<pre><code class="language-helios">Value &gt;= Value -&gt; Bool
</code></pre>
<h3 id="-144"><a class="header" href="#-144"><code>&gt;</code></a></h3>
<p>Strict greater-than comparison. If every lhs token has a greater amount than the equivalent rhs token then <code>&gt;</code> returns <code>true</code>. If any rhs token has a greater-or-equals amount than the equivalent lhs token then <code>&gt;</code> returns <code>false</code>.</p>
<pre><code class="language-helios">Value &gt; Value -&gt; Bool
</code></pre>
<h3 id="-145"><a class="header" href="#-145"><code>&lt;=</code></a></h3>
<p>Strict less-equals comparison. If every lhs token has a smaller-or-equals amount than the equivalent rhs token then <code>&lt;=</code> returns <code>true</code>. If any rhs token has a smaller amount than the equivalent lhs token, or doesn't exist in lhs, then <code>&lt;=</code> returns <code>false</code>.</p>
<pre><code class="language-helios">Value &lt;= Value -&gt; Bool
</code></pre>
<h3 id="-146"><a class="header" href="#-146"><code>&lt;</code></a></h3>
<p>Strict less-than comparison. If every lhs token has a smaller amount than the equivalent rhs token then <code>&lt;</code> returns <code>true</code>. If any rhs token has a smaller-or-equals amount than the equivalent lhs token, or doesn't exist in lhs, then <code>&lt;</code> returns <code>false</code>.</p>
<pre><code class="language-helios">Value &lt; Value -&gt; Bool
</code></pre>
<h3 id="-147"><a class="header" href="#-147"><code>+</code></a></h3>
<pre><code class="language-helios">Value + Value -&gt; Value
</code></pre>
<h3 id="--5"><a class="header" href="#--5"><code>-</code></a></h3>
<p>Subtracts two <code>Value</code> instances. Note that negative token amounts are possible.</p>
<pre><code class="language-helios">Value - Value -&gt; Value
</code></pre>
<h3 id="-148"><a class="header" href="#-148"><code>*</code></a></h3>
<pre><code class="language-helios">Value * Int -&gt; Value
</code></pre>
<h3 id="-149"><a class="header" href="#-149"><code>/</code></a></h3>
<pre><code class="language-helios">Value / Int -&gt; Value
</code></pre>
<h2 id="methods-36"><a class="header" href="#methods-36">Methods</a></h2>
<h3 id="contains-1"><a class="header" href="#contains-1"><code>contains</code></a></h3>
<p>Alias for <code>&gt;=</code> (where lhs is <code>self</code>).</p>
<pre><code class="language-helios">value.contains(other_value: Value) -&gt; Bool
</code></pre>
<h3 id="contains_policy"><a class="header" href="#contains_policy"><code>contains_policy</code></a></h3>
<p>Returns <code>true</code> if a given <a href="lang/builtins/./mintingpolicyhash.html"><code>MintingPolicyHash</code></a> is in a <code>Value</code>.</p>
<pre><code class="language-helios">value.contains_policy(mph: MintingPolicyHash) -&gt; Bool
</code></pre>
<h3 id="get-2"><a class="header" href="#get-2"><code>get</code></a></h3>
<p>Returns the amount of the given <a href="lang/builtins/./assetclass.html"><code>AssetClass</code></a> in a <code>Value</code>. Throws error if the <a href="lang/builtins/./assetclass.html"><code>AssetClass</code></a> isn't found.</p>
<pre><code class="language-helios">value.get(asset_class: AssetClass) -&gt; Int
</code></pre>
<h3 id="get_assets"><a class="header" href="#get_assets"><code>get_assets</code></a></h3>
<p>Returns a new <code>Value</code> with the lovelace removed.</p>
<pre><code class="language-helios">value.get_assets() -&gt; Value
</code></pre>
<h3 id="get_lovelace"><a class="header" href="#get_lovelace"><code>get_lovelace</code></a></h3>
<p>Returns the amount of lovelace in a <code>Value</code>. Returns <code>0</code> if there isn't any.</p>
<pre><code class="language-helios">value.get_lovelace() -&gt; Int
</code></pre>
<h3 id="get_safe-1"><a class="header" href="#get_safe-1"><code>get_safe</code></a></h3>
<p>Like <code>get</code>, but returns <code>0</code> instead of throwing an error if the given <a href="lang/builtins/./assetclass.html"><code>AssetClass</code></a> isn't found.</p>
<pre><code class="language-helios">value.get_safe(asset_class: AssetClass) -&gt; Int
</code></pre>
<h3 id="get_policy"><a class="header" href="#get_policy"><code>get_policy</code></a></h3>
<p>Returns a map of tokens of the given <a href="lang/builtins/./mintingpolicyhash.html"><code>MintingPolicyHash</code></a> in a <code>Value</code>. Throws an error if the <a href="lang/builtins/./mintingpolicyhash.html"><code>MintingPolicyHash</code></a> isn't found.</p>
<pre><code class="language-helios">value.get_policy(mph: MintingPolicyHash) -&gt; Map[ByteArray]Int
</code></pre>
<h3 id="is_zero"><a class="header" href="#is_zero"><code>is_zero</code></a></h3>
<p>Checks if a <code>Value</code> is empty.</p>
<pre><code class="language-helios">value.is_zero() -&gt; Bool
</code></pre>
<h3 id="serialize-36"><a class="header" href="#serialize-36"><code>serialize</code></a></h3>
<pre><code class="language-helios">value.serialize() -&gt; ByteArray
</code></pre>
<h3 id="show-14"><a class="header" href="#show-14"><code>show</code></a></h3>
<p>Returns a formatted <a href="lang/builtins/./string.html"><code>String</code></a> showing all the assets contained in a <code>Value</code>.</p>
<pre><code class="language-helios">value.show() -&gt; String
</code></pre>
<h3 id="to_map"><a class="header" href="#to_map"><code>to_map</code></a></h3>
<p>Returning the underlying <a href="lang/builtins/./map.html"><code>Map</code></a>:</p>
<pre><code class="language-helios">value.to_map() -&gt; Map[MintingPolicyHash]Map[ByteArray]Int
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="helios-api"><a class="header" href="#helios-api">Helios API</a></h1>
<p>This chapter covers how to compile Helios sources and how to build Cardano transactions using the Helios Javascript/Typescript library.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup-of-the-helios-library"><a class="header" href="#setup-of-the-helios-library">Setup of the Helios Library</a></h1>
<p>The Helios library is platform agnostic and can be used in many different ways.</p>
<script>
import("https://www.hyperion-bt.org/helios/helios.js").then((module) => {let elem = document.querySelector("main"); elem.innerHTML = elem.innerHTML.replaceAll('&lt;' + 'version' + '&gt;', module.VERSION);});
</script>
<h2 id="webpage-script-tag"><a class="header" href="#webpage-script-tag">Webpage <code>script</code> tag</a></h2>
<pre><code class="language-html">&lt;script src=&quot;https://helios.hyperion-bt.org/&lt;version&gt;/helios.js&quot; type=&quot;module&quot; crossorigin&gt;&lt;/script&gt;
</code></pre>
<h2 id="module-with-cdn-url"><a class="header" href="#module-with-cdn-url">Module with CDN URL</a></h2>
<p>Helios can be imported as a module using our CDN. This is supported by <a href="https://deno.land">Deno</a> and most modern browsers:</p>
<pre><code class="language-js">import * as helios from &quot;https://helios.hyperion-bt.org/&lt;version&gt;/helios.js&quot;

// or only the necessary parts (recommended as you get more acquainted with the library)
import { Program } from &quot;https://helios.hyperion-bt.org/&lt;version&gt;/helios.js&quot;
</code></pre>
<p>Alternatively you can use <code>&quot;helios&quot;</code> as a placeholder for the URL and, if not using any builder-tools, specify the module URL in an <a href="https://github.com/WICG/import-maps">importmap</a> (currently only supported by Chrome):</p>
<pre><code class="language-js">// in you javascript file
import * as helios from &quot;helios&quot;
</code></pre>
<pre><code class="language-html">&lt;!-- in your html file --&gt;
&lt;script type=&quot;importmap&quot;&gt;
    {
        &quot;imports&quot;: {
            &quot;helios&quot;: &quot;https://helios.hyperion-bt.org/&lt;version&gt;/helios.js&quot;
        }
    }
&lt;/script&gt;
</code></pre>
<p>The examples in this chapter will use the placeholder approach.</p>
<h2 id="npm"><a class="header" href="#npm"><a href="https://www.npmjs.com">npm</a></a></h2>
<p>Install the latest version of the library using the following command:</p>
<pre><code class="language-bash">$ npm i @hyperionbt/helios
</code></pre>
<p>Or install a specific version:</p>
<pre><code class="language-bash">$ npm i @hyperionbt/helios@&lt;version&gt;
</code></pre>
<p>In your Javascript/Typescript file:</p>
<pre><code class="language-js">import { Program } from &quot;@hyperionbt/helios&quot;
</code></pre>
<p>We don't yet recommend installing the Helios library globally, as the API is still changing frequently.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deno-as-a-vscode-language-server"><a class="header" href="#deno-as-a-vscode-language-server"><a href="https://deno.land">Deno</a> as a <a href="https://code.visualstudio.com">VSCode</a> language server</a></h1>
<p>To use Deno as a VSCode language server you must first install the Deno CLI. Assuming you have access to a Linux-linux terminal:</p>
<pre><code class="language-bash">$ curl -fsSL https://deno.land/x/install/install.sh | sh
</code></pre>
<p>This should download the <code>deno</code> binary to <code>$HOME/.deno/bin/deno</code>. Either add this directory to your <code>PATH</code>, or copy the binary to the system-wide bin directory:</p>
<pre><code>$ sudo cp $HOME/.deno/bin/deno /usr/local/bin/deno
</code></pre>
<p>Make sure the <code>.vscode/settings.json</code> file points to the correct <code>deno</code> binary. For example:</p>
<pre><code class="language-json">{
    &quot;deno.enable&quot;: true,
    &quot;deno.path&quot;: &quot;/usr/local/bin/deno&quot;
}
</code></pre>
<p>External modules must be cached by Deno before you can benefit from their type annotations.</p>
<p>Cache external modules using the following command:</p>
<pre><code class="language-bash">$ deno cache --reload my_entry_point.js
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiling-helios-sources"><a class="header" href="#compiling-helios-sources">Compiling Helios sources</a></h1>
<p>The recommended way to compile Helios sources is to use the library directly. This approach makes it easier to maintain a <a href="https://en.wikipedia.org/wiki/Single_source_of_truth">single-source-of-truth</a> version of your contract in client-side dApps.</p>
<p>First step is to write your contract as a js literal string. For example:</p>
<pre><code class="language-js">const src = `
spending always_succeeds

func main(_, _, _) -&gt; Bool {
    true
}`
</code></pre>
<p>Then you can create a Helios <code>Program</code> instance:</p>
<pre><code class="language-js">// at top of js file
import * as helios from &quot;helios&quot;
</code></pre>
<pre><code class="language-js">...
</code></pre>
<pre><code class="language-js">const program = helios.Program.new(src)
</code></pre>
<p>The <code>Program</code> instantiation will perform syntax and type checking, but won't actually do the compilation into the on-chain format. For that you need to call the <code>compile</code> method first:</p>
<pre><code class="language-js">const simplify = true

const myUplcProgram = program.compile(simplify)
</code></pre>
<blockquote>
<p><strong>Note</strong>: If <code>simplify</code> is <code>true</code> the resulting program is optimized for production. If <code>simplify</code> is <code>false</code> no optimizations are performed and <code>print</code> expressions aren't removed, which makes the resulting program more suitable for debugging.</p>
</blockquote>
<p>Here <code>myUplcProgram</code> is an instance of <code>UplcProgram</code> (<em>uplc</em> stands for <em>Untyped PLutus Core</em>). A <code>UplcProgram</code> instance has methods for running, profiling, hashing, and serializing the contained Plutus-Core program.</p>
<p>Now you can serialize the <code>UplcProgram</code> into a JSON string that can be used by <em>cardano-cli</em>:</p>
<pre><code class="language-js">console.log(myUplcProgram.serialize())

// prints '{&quot;type&quot;: PlutusScriptV2, &quot;description&quot;: &quot;&quot;, &quot;cborHex&quot;: ...}'
</code></pre>
<p>When <a href="api/./building/index.html">building transactions with Helios</a> the <code>UplcProgram</code> instance is used directly when attaching scripts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-datums-and-redeemers"><a class="header" href="#generating-datums-and-redeemers">Generating datums and redeemers</a></h1>
<p>Smart contract transactions include datum and redeemer data. You can generate these data structures using Helios.</p>
<p>Let's look at the following Helios script (as a literal string inside a js file):</p>
<pre><code class="language-js">const src = `
spending owner_only

struct Datum {
    owner: PubKeyHash
}

func main(datum: Datum, _, ctx: ScriptContext) -&gt; Bool {
    ctx.tx.is_signed_by(datum.owner)
}

const MY_DATUM = Datum {
    PubKeyHash::new(#...)
}`
</code></pre>
<p>Remember that after the <code>main</code> function you can define data generators and test functions (see <a href="api/../lang/script-structure.html">script structure</a>).</p>
<p><code>MY_DATUM</code> in this example can be evaluated using the API:</p>
<pre><code class="language-js">// at top of js file
import * as helios from &quot;helios&quot;
</code></pre>
<pre><code class="language-js">...
</code></pre>
<pre><code class="language-js">const program = helios.Program.new(src)

const myDatum = program.parameters[&quot;MY_DATUM&quot;]
</code></pre>
<p>Here <code>myDatum</code> is a <code>UplcValue</code> instance. <code>UplcValue</code> is the internal (unexported) base class of every Helios value. To get the underlying data we can use the <code>data</code> getter:</p>
<pre><code class="language-js">const myDatumData = myDatum.data
</code></pre>
<blockquote>
<p><strong>Note</strong>: the <code>UplcValue</code> <code>data</code> getter doesn't work for booleans as booleans are always kept in their primitive Plutus-Core form for performance reasons.</p>
</blockquote>
<p>Here <code>myDatumData</code> is a <code>UplcData</code> instance. <code>UplcData</code> is equivalent to the <code>BuiltinData</code> type in Plutus.</p>
<p>To create a JSON string that can be used by <em>cardano-cli</em> we can use the <code>toSchemaJson</code> method:</p>
<pre><code class="language-js">console.log(myDatumData.toSchemaJson())

// prints '{&quot;constructor&quot;: 0, &quot;fields&quot;: [...]}'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-transactions"><a class="header" href="#building-transactions">Building transactions</a></h1>
<p>Besides compiling and generating data structures the Helios library can also be used to build transactions.</p>
<p>In this section we assume the Helios library has been imported in the following way:</p>
<pre><code class="language-js">import * as helios from &quot;helios&quot;
</code></pre>
<h2 id="tx-2"><a class="header" href="#tx-2"><code>Tx</code></a></h2>
<p>A new <a href="api/building/../reference/tx.html"><code>Tx</code></a> instance acts as a transaction builder, using builder pattern methods.</p>
<pre><code class="language-js">const tx = new helios.Tx()
</code></pre>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<ul>
<li><a href="api/building/./inputs.html">inputs</a></li>
<li><a href="api/building/./outputs.html">outputs</a></li>
<li><a href="api/building/./collateral.html">collateral</a></li>
<li><a href="api/building/./signers.html">explicit signers</a></li>
<li><a href="api/building/./minting.html">minting</a></li>
<li><a href="api/building/./finalizing.html">finalizing</a></li>
<li><a href="api/building/./signing-and-submitting.html">signing and submitting</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-inputs"><a class="header" href="#transaction-inputs">Transaction inputs</a></h1>
<p>Each transaction input is an instance of the <code>UTxO</code> class. A <code>UTxO</code> represents a <code>TxOutputId</code> and, when building a new transaction, also contains the underlying <code>TxOutput</code>.</p>
<pre><code class="language-js">const utxo = new helios.UTxO(
    helios.TxId.fromHex(&quot;...&quot;), // hash of the tx that created the utxo
    0n, // utxo index as bigint
    new helios.TxOutput(...) // TxOutput with address, value and datum fields
)
</code></pre>
<h2 id="spending-a-regular-utxo"><a class="header" href="#spending-a-regular-utxo">Spending a regular UTxO</a></h2>
<p>Spending a regular UTxO (i.e. non-script UTxO), is done with the <code>addInput</code> method:</p>
<pre><code class="language-js">tx.addInput(utxo)
</code></pre>
<h2 id="spending-a-script-utxo"><a class="header" href="#spending-a-script-utxo">Spending a script UTxO</a></h2>
<p>Spending a <code>UTxO</code> locked at a script address is also done with <code>addInput</code>, but requires specifying a redeemer:</p>
<pre><code class="language-js">// program.evalParam(&quot;...&quot;).data can be used directly as 'redeemerData'
tx.addInput(utxo, redeemerData)
</code></pre>
<p>The corresponding script must be also be attached to such a transaction:</p>
<pre><code class="language-js">// 'uplcProgram' is an instance of UplcProgram (i.e. result of helios.Program.new(...).compile(...))
tx.attachScript(uplcProgram)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-outputs"><a class="header" href="#transaction-outputs">Transaction outputs</a></h1>
<p>Each transaction output is an instance of the <code>TxOutput</code> class. A <code>TxOutput</code> contains an <code>Address</code>, a <code>Value</code>, and, optionally, a <code>Datum</code> field.</p>
<h2 id="example-txoutput-instance-without-a-datum"><a class="header" href="#example-txoutput-instance-without-a-datum">Example: <code>TxOutput</code> instance without a datum</a></h2>
<pre><code class="language-js">const output = new helios.TxOutput(
    helios.Address.fromBech32(&quot;addr_test...&quot;),
    new helios.Value(1000000n), // 1 tAda == 1 million lovelace
)
</code></pre>
<h2 id="example-txoutput-instance-with-an-inline-datum"><a class="header" href="#example-txoutput-instance-with-an-inline-datum">Example: <code>TxOutput</code> instance with an inline datum</a></h2>
<pre><code class="language-js">const outputWithDatum = new helios.TxOutput(
    helios.Address.fromBech32(&quot;addr_test...&quot;),
    new helios.Value(1000000n),
    helios.Datum.inline(...), // result from program.evalParam(&quot;...&quot;).data can be used directly as an argument for Datum.inline()
)
</code></pre>
<h2 id="adding-a-txoutput-to-a-tx"><a class="header" href="#adding-a-txoutput-to-a-tx">Adding a <code>TxOutput</code> to a <code>Tx</code></a></h2>
<p>A <code>TxOutput</code> can be added to the transaction with the <code>addOutput</code> method:</p>
<pre><code class="language-js">tx.addOutput(output)
</code></pre>
<p>Multiple outputs at once with the <code>addOutputs</code> method:</p>
<pre><code class="language-js">tx.addOutputs(outputs)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collateral"><a class="header" href="#collateral">Collateral</a></h1>
<p>Some <code>UTxO</code>s must be added as collateral to the transaction in case the transaction interacts with smart contracts:</p>
<pre><code class="language-js">tx.addCollateral(utxo)
</code></pre>
<blockquote>
<p><strong>Note</strong>: the collateral is only lost if the transaction fails once submitted. There are however plenty of checks that happen before the transaction is submitted to the blockchain mem-pool, so such a situation is very unlikely.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: since v0.12.6 of Helios, setting the collateral is no longer necessary. If unset, the collateral (and collateral return) is set automatically inside <code>tx.finalize()</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="explicit-signers"><a class="header" href="#explicit-signers">Explicit signers</a></h1>
<p>Explicit signers are actors who approve the transaction without necessarily sending or receiving UTxOs.</p>
<p>Only these explicit signers appear in the <a href="api/building/../../lang/builtins/tx.html#signatories"><code>tx.signatories</code></a> field.</p>
<p>Signers are identified by their <code>PubKeyHash</code>:</p>
<pre><code class="language-js">tx.addSigner(helios.PubKeyHash.fromHex(&quot;...&quot;))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minting"><a class="header" href="#minting">Minting</a></h1>
<p>Tokens can be minted using the <code>mintTokens</code> method. The <code>UplcProgram</code> of the corresponding minting policy must also be attached:</p>
<pre><code class="language-js">tx
    .mintTokens(
        uplcProgram.mintingPolicyHash, 
        [[&quot;my_first_nft&quot;, 1n], [&quot;my_second_nft&quot;, 1n]], 
        redeemerData // can be generated using program.evalParam(&quot;...&quot;).data
    )
    .attachScript(uplcProgram)
</code></pre>
<blockquote>
<p><strong>Note</strong>: the transaction building methods can be chained.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="finalizing"><a class="header" href="#finalizing">Finalizing</a></h1>
<p>Before signing the serialized transaction using a wallet, the transaction must be finalized. The finalization process calculates the transaction fee, balances the transaction, and checks min collateral and min lovelace deposit requirements.</p>
<p>Finalization requires the most recent network parameters (see below), a change address for balancing, and optionally some additional UTxOs that will be used if the inputs specified by the user don't contain enough lovelace to cover the fees and deposits:</p>
<pre><code class="language-js">// async because scripts are evaluated asyncronously

await tx.finalize(networkParams, changeAddress, extraUTxOs)
</code></pre>
<blockquote>
<p><strong>Note</strong>: <code>finalize</code> is asynchronous because script evaluation is asynchronous. Script evaluation is asynchronous so that interactive debuggers can easily step through the evaluation process.</p>
</blockquote>
<h2 id="network-parameters"><a class="header" href="#network-parameters">Network parameters</a></h2>
<p>The finalization process require downloading the latest network parameters. For example, for the preview testnet:</p>
<pre><code class="language-js">// in an async context

const networkParams = new helios.NetworkParams(
    await fetch(&quot;https://d1t0d7c2nekuk0.cloudfront.net/preview.json&quot;)
        .then(response =&gt; response.json())
)
</code></pre>
<blockquote>
<p><strong>Note</strong>: we've set up a CDN with daily updated raw network parameters:</p>
<ul>
<li>Preview: <a href="https://d1t0d7c2nekuk0.cloudfront.net/preview.json">https://d1t0d7c2nekuk0.cloudfront.net/preview.json</a></li>
<li>Preprod: <a href="https://d1t0d7c2nekuk0.cloudfront.net/preprod.json">https://d1t0d7c2nekuk0.cloudfront.net/preprod.json</a></li>
<li>Mainnet: <a href="https://d1t0d7c2nekuk0.cloudfront.net/mainnet.json">https://d1t0d7c2nekuk0.cloudfront.net/mainnet.json</a></li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signing-and-submitting-a-transactions"><a class="header" href="#signing-and-submitting-a-transactions">Signing and submitting a transactions</a></h1>
<h2 id="signing"><a class="header" href="#signing">Signing</a></h2>
<p>The finalized transaction can be signed by a wallet, for example using the <a href="https://cips.cardano.org/cips/cip30/">CIP 30 dApp connector</a>:</p>
<pre><code class="language-js">// in an async context

const response = await walletHandle.signTx(helios.bytesToHex(tx.toCbor()), true)

// extract the deserialized signatures
const signatures = helios.TxWitnesses.fromCbor(helios.hexToBytes(response)).signatures

tx.addSignatures(signatures)
</code></pre>
<blockquote>
<p><strong>Note</strong>: the <code>bytesToHex</code> and <code>hexToBytes</code> functions are provided by the Helios library as convenient and unambiguous ways to convert a byte-array between string hexadecimal format and raw lists of bytes.</p>
</blockquote>
<h2 id="submitting"><a class="header" href="#submitting">Submitting</a></h2>
<p>After adding the wallet signatures to the transaction, the transaction can be submitted:</p>
<pre><code class="language-js">// in async context

// returns the hash of the tx
await walletHandle.submitTx(helios.bytesToHex(tx.toCbor()))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-picoswap"><a class="header" href="#example-picoswap">Example: PicoSwap</a></h1>
<p>This section walks you through building a minimal marketplace dApp using Helios. The full demo is hosted <a href="https://www.hyperion-bt.org/PicoSwap">here</a>.</p>
<p>Only the Helios-specific parts are covered (i.e. not the UI, not the wallet interaction, and not the blockchain queries). This example is intended as an alternate introduction to the Helios API, and shouldn't be seen as an authoritative guide on how to write secure dApps.</p>
<p>We assume here that the library has been imported in the following way:</p>
<pre><code class="language-js">import * as helios from &quot;helios&quot;
</code></pre>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<ul>
<li><a href="api/picoswap/./script.html">main script</a></li>
<li><a href="api/picoswap/./datums.html">generating datums</a></li>
<li><a href="api/picoswap/./contract-class.html"><code>Contract</code> helper class</a></li>
<li><a href="api/picoswap/./new-sale.html">creating a new sale</a></li>
<li><a href="api/picoswap/./cancel-sale.html">canceling a sale</a></li>
<li><a href="api/picoswap/./buying.html">buying for-sale assets</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="main-script"><a class="header" href="#main-script">Main script</a></h1>
<p>The source of the validator script can be placed in a js literal string:</p>
<pre><code class="language-js">const mainScript = `
spending picoswap

// Note: each input UTxO must contain some lovelace, so the datum price will be a bit higher than the nominal price
// Note: public sales are possible when a buyer isn't specified
 
struct Datum {
    seller: PubKeyHash
    price:  Value              
    buyer:  Option[PubKeyHash]
    nonce:  Int // double satisfaction protection
 
    func seller_signed(self, tx: Tx) -&gt; Bool {
        tx.is_signed_by(self.seller)
    }
 
    func buyer_signed(self, tx: Tx) -&gt; Bool {
        self.buyer.switch{
            None    =&gt; true,
            s: Some =&gt; tx.is_signed_by(s.some)
        }
    }
 
    func seller_received_money(self, tx: Tx) -&gt; Bool {
        // protect against double satisfaction exploit by datum tagging the output using a nonce
        tx.value_sent_to_datum(self.seller, self.nonce, false) &gt;= self.price
     }
 }
 
func main(datum: Datum, _, ctx: ScriptContext) -&gt; Bool {
    tx: Tx = ctx.tx;
 
    // sellers can do whatever they want with the locked UTxOs
    datum.seller_signed(tx) || (
        // buyers can do whatever they want with the locked UTxOs, as long as the sellers receive their end of the deal
        datum.buyer_signed(tx) &amp;&amp; 
        datum.seller_received_money(tx)
    )
}`
</code></pre>
<p>We recommend including a <em>Show script</em> or <em>Show contract</em> button in every dApp so users can easily audit the smart contract logic they are interacting with.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-datums"><a class="header" href="#generating-datums">Generating datums</a></h1>
<p>We can use the following Helios code to generate datums:</p>
<pre><code class="language-js">const datumScript = `
const SELLER_BYTES   = # // must be 28 bytes long
const PRICE_LOVELACE = 0
const BUYER_BYTES    = # // must be 0 or 28 bytes long
const NONCE          = 0

const DATUM = Datum{
    seller: PubKeyHash::new(SELLER_BYTES),
    price:  Value::lovelace(PRICE_LOVELACE),
    buyer:  if (BUYER_BYTES.length == 0) {
                Option[PubKeyHash]::None
            } else {
                Option[PubKeyHash]::Some{PubKeyHash::new(BUYER_BYTES)}
            },
    nonce:  NONCE
}`
</code></pre>
<p>Before generating a datum with <code>evalParam</code>, we concatenate <code>mainScript</code> with <code>datumScript</code> and change the values of the input parameters:</p>
<pre><code class="language-js">/**
 * @param {helios.Address} seller
 * @param {bigint} price
 * @returns {helios.UplcData}
 */
function generatePublicSaleDatum(seller, price) {
    // public sale, don't set the buyer bytes
    return helios.Program.new(mainScript + datumScript)
        .changeParam(&quot;SELLER_BYTES&quot;,   JSON.stringify(seller.pubKeyHash.bytes))
        .changeParam(&quot;PRICE_LOVELACE&quot;, price.toString())
        .changeParam(&quot;NONCE&quot;,          (Math.random()*1000000).toString())
        .evalParam(&quot;DATUM&quot;).data
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: the <code>program.changParam()</code> method takes as a second argument a JSON string, or a <code>UplcValue</code> (i.e. the result of a <code>evalParam</code> call). It doesn't take an arbitrary object however, as that might get confused for the internals of a <code>UplcValue</code>. </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract-helper-class"><a class="header" href="#contract-helper-class"><code>Contract</code> helper class</a></h1>
<p>Before describing PicoSwap's smart contract end-points, it is helpful to define a <code>Contract</code> class that can be instantiated for each set of UTxOs locked at the script address having the same datum.</p>
<pre><code class="language-js">class Contract {
    /**
     * @param {helios.ConstrData} datum - not a helios.Datum instance!
     * @param {helios.UTxO[]} utxos
     */
    constructor(datum, utxos) {
        this.datum = datum
        this.utxos = utxos
    }

    get seller() {
        return new helios.PubKeyHash(this.datum.fields[0].bytes)
    }

    get sellerAddress() {
        // true -&gt; testnet
        return helios.Address.fromPubKeyHash(true, this.seller)
    }

    get price() {
        return helios.Value.fromData(this.datum.fields[1])
    }

    get forSale() {
        return helios.UTxO.sumValue(this.utxos)
    }

    get nonce() {
        return this.datum.fields[3].int
    }
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: <code>ConstrData</code> is one of the 5 child-types of <code>UplcData</code>. The other <code>UplcData</code> child-types are: <code>IntData</code>, <code>ByteArrayData</code>, <code>ListData</code> and <code>MapData</code>.</p>
</blockquote>
<p>Grouping the contract UTxOs and extracting the inline datum data is left as an exercise to the reader.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-new-sale"><a class="header" href="#creating-a-new-sale">Creating a new sale</a></h1>
<p>A new sale is created by sending funds (the <code>forSale</code> assets) to the contract address with the appropriate datum.</p>
<p>The following function creates a transaction that represents a <em>new sale</em>:</p>
<pre><code class="language-js">/**
 * @param {helios.Value} forSale
 * @param {bigint} price - in lovelace
 * @returns {Promise&lt;helios.Tx&gt;} - the finalized, but unsigned transaction
 */
async function createNewSaleTx(forSale, price) {
    const uplcProgram = helios.Program.new(mainScript).compile(true)

    const forSaleUtxos = /* code that picks some utxos that cover the 'forSale' value */
    const changeAddress = /* code that picks the changeAddress */

    // create the forSale output that will be locked at the script address
    const output = new helios.TxOutput(
        helios.Address.fromValidatorHash(
            true, // true -&gt; testNet
            uplcProgram.validatorHash
        ),
        forSale,
        helios.Datum.inline(generatePublicSaleDatum(changeAddress, price)) // changeAddress is also the seller address
    )

    // the output might not contain any lovelace, that must be corrected (and the price in the datum must be increased accordingly)
    output.correctLovelace(networkParams, (output) =&gt; {
        // increase the price by the min amount of lovelace needed as a deposit
        output.setDatum(
            helios.Datum.inline(
                generatePublicSaleDatum(
                    changeAddress, 
                    price + output.value.lovelace
                )
            )
        );
    })    

    return await ((new helios.Tx())
        .addInputs(forSaleUtxos)
        .addOutput(output)
        .finalize(networkParams, changeAddress)
    )
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="canceling-a-sale"><a class="header" href="#canceling-a-sale">Canceling a sale</a></h1>
<p>A seller can cancel a sale before it is fulfilled.</p>
<p>The following function creates the <em>cancel</em> transaction:</p>
<pre><code class="language-js">/**
 * @param {Contract} contract - instantiated elsewhere
 * @returns {Promise&lt;helios.Tx&gt;} - finalized but unsigned transaction
 */
async function cancelSaleTx(contract) {
    const uplcProgram = helios.Program.new(mainScript).compile(true)

    const feeUtxos = /* code that picks the utxos with which the tx fee will be paid */
    const changeAddress = /* code that picks the change address */

    // we must add the seller as an explicit signer, some collateral and attach the script
    return await ((new helios.Tx())
        .addInputs(feeUtxos)
        .addInputs(contract.utxos, new helios.IntData(42n)) // dummy redeemer
        // send all the contract utxos back to the seller (i.e. back to the changeAddress)
        .addOutputs(contract.utxos.map(utxo =&gt; new helios.TxOutput( 
            changeAddress, utxo.origOutput.value
        )))
        .addSigner(contract.seller)
        .addCollateral(feeUtxos[0]) // assume one of the feeUtxos is big enough to be used as collateral
        .attachScript(uplcProgram)
        .finalize(networkParams, changeAddress)
    )
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="buying-for-sale-assets"><a class="header" href="#buying-for-sale-assets">Buying for-sale assets</a></h1>
<p>Anyone can buy the assets locked in the script by sending the price <code>Value</code> to the seller.</p>
<p>The following function creates the <em>buy</em> transaction:</p>
<pre><code class="language-js">/**
 * @param {Contract} contract - instantiated elsewhere
 * @returns {Promise&lt;helios.Tx&gt;} - finalized but unsigned transaction
 */
async function buyTx(contract) {
    const uplcProgram = helios.Program.new(mainScript).compile(true)

    const paymentUtxos = /* code that picks the utxos used for payment */
    const changeAddress = /* code that picks the change address */
    
    return await ((new helios,Tx())
        .addInputs(paymentUtxos)
        .addInputs(contract.utxos, new helios.IntData(42n)) // dummy redeemer
        .attachScript(uplcProgram)
        .addOutput(new helios.TxOutput( // send 'price' to seller
            contract.sellerAddress,
            contract.price,
            helios.Datum.hashed(new helios.IntData(contract.nonce)) // nonce that protects agains double satisfaction exploit
        ))
        .addOutputs(contract.utxos.map( // send for-sale assets to buyer
            // preserve the number of UTxOs
            utxo =&gt; new helios.TxOutput(changeAddress, utxo.value)
        ))
        .addCollateral(/* code that picks collateral UTxOs */)
        .finalize(networkParams, changeAddress)
    )
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference"><a class="header" href="#api-reference">API reference</a></h1>
<p>This section contains a complete reference of all the functions and classes exported by the Helios library. Note that only the class methods that are intended for external use are documented here, even if many more methods can be accessed.</p>
<p>Typescript annotations are used to document types. </p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<h3 id="global-constants-and-variables"><a class="header" href="#global-constants-and-variables">Global constants and variables</a></h3>
<ul>
<li><a href="api/reference/./globals.html#version"><code>VERSION</code></a></li>
<li><a href="api/reference/./globals.html#is_testnet"><code>IS_TESTNET</code></a></li>
</ul>
<h3 id="functions-1"><a class="header" href="#functions-1">Functions</a></h3>
<ul>
<li><a href="api/reference/./functions.html#bytestohex"><code>bytesToHex</code></a></li>
<li><a href="api/reference/./functions.html#deserializeuplcbytes"><code>deserializeUplcBytes</code></a></li>
<li><a href="api/reference/./functions.html#extractscriptpurposeandname"><code>extractScriptPurposeAndName</code></a></li>
<li><a href="api/reference/./functions.html#hextobytes"><code>hexToBytes</code></a></li>
<li><a href="api/reference/./functions.html#highlight"><code>highlight</code></a></li>
<li><a href="api/reference/./functions.html#hl"><code>hl</code></a></li>
</ul>
<h3 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h3>
<p>Can only be imported in typescript files.</p>
<ul>
<li><a href="api/reference/./cip30handle.html"><code>Cip30Handle</code></a></li>
<li><a href="api/reference/./network.html"><code>Network</code></a></li>
<li><a href="api/reference/./wallet.html"><code>Wallet</code></a></li>
</ul>
<h3 id="classes"><a class="header" href="#classes">Classes</a></h3>
<ul>
<li><a href="api/reference/./address.html"><code>Address</code></a></li>
<li><a href="api/reference/./assets.html"><code>Assets</code></a></li>
<li><a href="api/reference/./blockfrostv0.html"><code>BlockfrostV0</code></a></li>
<li><a href="api/reference/./bytearraydata.html"><code>ByteArrayData</code></a></li>
<li><a href="api/reference/./cbordata.html"><code>CborData</code></a></li>
<li><a href="api/reference/./cip30wallet.html"><code>Cip30Wallet</code></a></li>
<li><a href="api/reference/./coinselection.html"><code>CoinSelection</code></a></li>
<li><a href="api/reference/./constrdata.html"><code>ConstrData</code></a></li>
<li><a href="api/reference/./crypto.html"><code>Crypto</code></a></li>
<li><a href="api/reference/./datum.html"><code>Datum</code></a></li>
<li><a href="api/reference/./datumhash.html"><code>DatumHash</code></a></li>
<li><a href="api/reference/./fuzzytest.html"><code>FuzzyTest</code></a></li>
<li><a href="api/reference/./heliosdata.html"><code>HeliosData</code></a></li>
<li><a href="api/reference/./intdata.html"><code>IntData</code></a></li>
<li><a href="api/reference/./listdata.html"><code>ListData</code></a></li>
<li><a href="api/reference/./mapdata.html"><code>MapData</code></a></li>
<li><a href="api/reference/./mintingpolicyhash.html"><code>MintingPolicyHash</code></a></li>
<li><a href="api/reference/./networkemulator.html"><code>NetworkEmulator</code></a></li>
<li><a href="api/reference/./networkparams.html"><code>NetworkParams</code></a></li>
<li><a href="api/reference/./program.html"><code>Program</code></a></li>
<li><a href="api/reference/./pubkeyhash.html"><code>PubKeyHash</code></a></li>
<li><a href="api/reference/./signature.html"><code>Signature</code></a></li>
<li><a href="api/reference/./tx.html"><code>Tx</code></a></li>
<li><a href="api/reference/./txid.html"><code>TxId</code></a></li>
<li><a href="api/reference/./txoutput.html"><code>TxOutput</code></a></li>
<li><a href="api/reference/./txrefinput.html"><code>TxRefInput</code></a></li>
<li><a href="api/reference/./txwitnesses.html"><code>TxWitnesses</code></a></li>
<li><a href="api/reference/./uplcbool.html"><code>UplcBool</code></a></li>
<li><a href="api/reference/./uplcbytearray.html"><code>UplcByteArray</code></a></li>
<li><a href="api/reference/./uplcdata.html"><code>UplcData</code></a></li>
<li><a href="api/reference/./uplcdatavalue.html"><code>UplcDataValue</code></a></li>
<li><a href="api/reference/./uplcint.html"><code>UplcInt</code></a></li>
<li><a href="api/reference/./uplcpair.html"><code>UplcPair</code></a></li>
<li><a href="api/reference/./uplcprogram.html"><code>UplcProgram</code></a></li>
<li><a href="api/reference/./uplcstring.html"><code>UplcString</code></a></li>
<li><a href="api/reference/./uplcunit.html"><code>UplcUnit</code></a></li>
<li><a href="api/reference/./uplcvalue.html"><code>UplcValue</code></a></li>
<li><a href="api/reference/./usererror.html"><code>UserError</code></a></li>
<li><a href="api/reference/./utxo.html"><code>UTxO</code></a></li>
<li><a href="api/reference/./validatorhash.html"><code>ValidatorHash</code></a></li>
<li><a href="api/reference/./value.html"><code>Value</code></a></li>
<li><a href="api/reference/./walletemulator.html"><code>WalletEmulator</code></a></li>
<li><a href="api/reference/./wallethelper.html"><code>WalletHelper</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="global-constants-and-variables-1"><a class="header" href="#global-constants-and-variables-1">Global constants and variables</a></h1>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<h3 id="version"><a class="header" href="#version"><code>VERSION</code></a></h3>
<p>Current version of the Helios library.</p>
<pre><code class="language-ts">helios.VERSION: string
</code></pre>
<h2 id="variables-1"><a class="header" href="#variables-1">Variables</a></h2>
<p>Modifiable through the <code>config</code> object.</p>
<h3 id="debug"><a class="header" href="#debug"><code>DEBUG</code></a></h3>
<p>Currently unused by the library itself. Defaults to <code>false</code>.</p>
<pre><code class="language-ts">helios.config.DEBUG: boolean = false
</code></pre>
<h3 id="is_testnet"><a class="header" href="#is_testnet"><code>IS_TESTNET</code></a></h3>
<p>If <code>true</code>, <a href="api/reference/./address.html"><code>Address</code></a>es are built for testnet by default, otherwise for mainnet. Defaults to <code>true</code>.</p>
<pre><code class="language-ts">helios.config.IS_TESTNET: boolean = true
</code></pre>
<h3 id="strict_babbage"><a class="header" href="#strict_babbage"><code>STRICT_BABBAGE</code></a></h3>
<p>If <code>true</code>, serializes <a href="api/reference/./txoutput.html"><code>TxOutput</code></a> using strictly the Babagge cddl format. Defaults to <code>false</code>.</p>
<pre><code class="language-ts">helios.config.STRICT_BABBAGE: boolean = false
</code></pre>
<h3 id="n_dummy_inputs"><a class="header" href="#n_dummy_inputs"><code>N_DUMMY_INPUTS</code></a></h3>
<p>Calculating the execution budget during <a href="api/reference/./tx.html#finalize">Tx finalization</a> requires knowing all the inputs beforehand. This is however very difficult because balancing is done after the execution budget is calculated.</p>
<p>Helios uses <code>1</code> or <code>2</code> dummy inputs as placeholders for the balancing input(s). This avoids the difficulty of figuring out the final balancing input(s) before knowing the transaction fee, but slightly overestimates the execution budget.</p>
<p>The 1st dummy input has <a href="api/reference/./txid.html"><code>TxId</code></a><code>=#0000...</code>, which overestimates any operation that iterates over <a href="api/reference/../../lang/builtins/tx.html#inputs"><code>tx.inputs</code></a>.</p>
<p>The 2nd optional dummy input has <a href="api/reference/./txid.html"><code>TxId</code></a><code>=#ffff...</code>, which overestimates any operation that prints the <a href="api/reference/../../lang/builtins/txid.html#show"><code>TxId</code></a> of the entries in <a href="api/reference/../../lang/builtins/tx"><code>tx.inputs</code></a>.</p>
<p>An error is thrown if <code>N_DUMMY_INPUTS</code> isn't <code>1</code> or <code>2</code>. <code>N_DUMMY_INPUTS</code> defaults to <code>2</code> (more robust, but more overestimation of the tx fee).</p>
<pre><code class="language-ts">helios.config.N_DUMMY_INPUTS: number = 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-2"><a class="header" href="#functions-2">Functions</a></h1>
<h3 id="bytestohex"><a class="header" href="#bytestohex"><code>bytesToHex</code></a></h3>
<p>Converts a list of bytes into its hexadecimal string representation.</p>
<pre><code class="language-ts">helios.bytesToHex(bytes: number[]): string
</code></pre>
<h3 id="bytestotext"><a class="header" href="#bytestotext"><code>bytesToText</code></a></h3>
<p>Converts utf-8 encoded text from its byte representation to its string representation.</p>
<pre><code class="language-ts">helios.bytesToText(bytes: number[]): string
</code></pre>
<h3 id="deserializeuplcbytes"><a class="header" href="#deserializeuplcbytes"><code>deserializeUplcBytes</code></a></h3>
<p>Deserializes a flat encoded <a href="api/reference/./uplcprogram.html"><code>UplcProgram</code></a>.</p>
<pre><code class="language-ts">helios.deserializeUplcBytes(bytes: number[]): helios.UplcProgram
</code></pre>
<h3 id="extractscriptpurposeandname"><a class="header" href="#extractscriptpurposeandname"><code>extractScriptPurposeAndName</code></a></h3>
<p>Quickly extract the script purpose header of a script source, by parsing only the minimally necessary characters. Returns <code>null</code> if the script header is missing or syntactically incorrect.</p>
<p>The first string returned is the script purpose, the second value returned is the script name.</p>
<pre><code class="language-ts">helios.extractScriptPurposeAndName(src: string): ?[string, string]
</code></pre>
<h3 id="hextobytes"><a class="header" href="#hextobytes"><code>hexToBytes</code></a></h3>
<p>Converts a hexadecimal string into a list of bytes.</p>
<pre><code class="language-ts">helios.hexToBytes(hex: string): number[]
</code></pre>
<h3 id="highlight"><a class="header" href="#highlight"><code>highlight</code></a></h3>
<p>Returns <code>Uint8Array</code> with the same length as the number of chars in the script. Each resulting byte respresents a different syntax category. This approach should faster than a regexp based a approach.</p>
<pre><code class="language-ts">helios.highlight(src: string): Uint8Array
</code></pre>
<h3 id="hl"><a class="header" href="#hl"><code>hl</code></a></h3>
<p>Template string tag function that doens't do anything and just returns the template string as a string. Can be used as a marker of Helios sources so that syntax highlighting can work inside js/ts files.</p>
<pre><code class="language-ts">helios.hl`...`: string
</code></pre>
<h3 id="texttobytes"><a class="header" href="#texttobytes"><code>textToBytes</code></a></h3>
<p>Converts a string into its utf-8 encoded byte representation.</p>
<pre><code class="language-ts">helios.textToBytes(text: string): number[]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="address-3"><a class="header" href="#address-3"><code>Address</code></a></h1>
<p>Wrapper for Cardano address bytes. An <code>Address</code> consists of three parts internally:</p>
<ul>
<li>Header (1 byte, see <a href="https://cips.cardano.org/cips/cip19/">CIP 19</a>)</li>
<li>Witness hash (28 bytes that represent the <code>PubKeyHash</code> or <code>ValidatorHash</code>)</li>
<li>Optional staking credential (0 or 28 bytes)</li>
</ul>
<h2 id="constructor"><a class="header" href="#constructor">Constructor</a></h2>
<pre><code class="language-ts">new helios.Address(bytes: []number)
</code></pre>
<h2 id="static-methods"><a class="header" href="#static-methods">Static methods</a></h2>
<h3 id="frombech32"><a class="header" href="#frombech32"><code>fromBech32</code></a></h3>
<p>Converts a Bech32 string into an <code>Address</code>:</p>
<pre><code class="language-ts">helios.Address.fromBech32(str: string): helios.Address
</code></pre>
<h3 id="fromcbor"><a class="header" href="#fromcbor"><code>fromCbor</code></a></h3>
<p>Deserializes bytes into an <code>Address</code>.</p>
<pre><code class="language-ts">helios.Address.fromCbor(bytes: []number): helios.Address
</code></pre>
<h3 id="fromhex"><a class="header" href="#fromhex"><code>fromHex</code></a></h3>
<p>Constructs an <code>Address</code> using a hexadecimal string representation of the address bytes.</p>
<pre><code class="language-ts">helios.Address.fromHex(hex: string): helios.Address
</code></pre>
<h3 id="fromhashes"><a class="header" href="#fromhashes"><code>fromHashes</code></a></h3>
<p>Constructs an <code>Address</code> using either a <a href="api/reference/./pubkeyhash.html"><code>PubKeyHash</code></a> (i.e. simple payment address) or <a href="api/reference/./validatorhash.html"><code>ValidatorHash</code></a> (i.e. script address), in combination with an optional staking hash (<a href="api/reference/./stakekeyhash.html"><code>StakeKeyHash</code></a> or <a href="api/reference/./stakingvalidatorhash.html"><code>StakingValidatorHash</code></a>).</p>
<p>Testnet addresses have different header bytes. <a href="api/reference/./globals.html"><code>IS_TESTNET</code></a> is a library-scope variable that can be set globally.</p>
<pre><code class="language-ts">helios.Address.fromPubKeyHash(
    pkh: helios.PubKeyHash | helios.ValidatorHash,
    sh: ?(helios.StakeKeyHash | helios.StakingValidatorHash) = null,
    isTestnet: boolean = IS_TESTNET
): helios.Address
</code></pre>
<h3 id="isfortestnet"><a class="header" href="#isfortestnet"><code>isForTestnet</code></a></h3>
<p>Returns <code>true</code> if the given <code>Address</code> is a testnet address.</p>
<pre><code class="language-ts">helios.Address.isForTestnet(
    address: helios.Address
): boolean
</code></pre>
<h2 id="getters-20"><a class="header" href="#getters-20">Getters</a></h2>
<h3 id="pubkeyhash-1"><a class="header" href="#pubkeyhash-1"><code>pubKeyHash</code></a></h3>
<p>Returns the underlying <a href="api/reference/./pubkeyhash.html"><code>PubKeyHash</code></a> of a simple payment address, or <code>null</code> for a script <code>Address</code>.</p>
<pre><code class="language-ts">address.pubKeyHash: ?helios.PubKeyHash
</code></pre>
<h3 id="validatorhash-1"><a class="header" href="#validatorhash-1"><code>validatorHash</code></a></h3>
<p>Returns the underlying <a href="api/reference/./validatorhash.html"><code>ValidatorHash</code></a> of a script address, or <code>null</code> for a regular payment <code>Address</code>.</p>
<pre><code class="language-ts">address.validatorHash: ?helios.ValidatorHash
</code></pre>
<h3 id="stakinghash-1"><a class="header" href="#stakinghash-1"><code>stakingHash</code></a></h3>
<p>Returns the underlying [<code>StakeKeyHash](./stakekeyhash.md) or [</code>StakingValidatorHash<code>](./stakingvalidatorhash.md), or </code>null` for non-staked addresses.</p>
<pre><code class="language-ts">address.stakingHash: ?(helios.StakeKeyHash | helios.StakingValidatorHash)
</code></pre>
<h2 id="methods-37"><a class="header" href="#methods-37">Methods</a></h2>
<h3 id="tobech32"><a class="header" href="#tobech32"><code>toBech32</code></a></h3>
<p>Turns an <code>Address</code> into its Bech32 representation.</p>
<pre><code class="language-ts">address.toBech32(): string
</code></pre>
<h3 id="tocbor"><a class="header" href="#tocbor"><code>toCbor</code></a></h3>
<p>Turns an <code>Address</code> into its CBOR representation.</p>
<pre><code class="language-ts">address.toCbor(): number[]
</code></pre>
<h3 id="tohex"><a class="header" href="#tohex"><code>toHex</code></a></h3>
<p>Turns a <code>Address</code> into its hexadecimal representation.</p>
<pre><code class="language-ts">address.toHex(): string
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assetclass-1"><a class="header" href="#assetclass-1"><code>AssetClass</code></a></h1>
<p>Child class of <a href="api/reference/./heliosdata.html"><code>HeliosData</code></a>.</p>
<h2 id="constructor-1"><a class="header" href="#constructor-1">Constructor</a></h2>
<p>Intelligently converts arguments. The format for single argument string is <code>&lt;hex-encoded-mph&gt;.&lt;hex-encoded-token-name&gt;</code>.</p>
<pre><code class="language-ts">new helios.AssetClass(
    ...args : 
        [string] | 
        [number[] | string | MintingPolicyHash, number[] | string]
)
</code></pre>
<h2 id="static-methods-1"><a class="header" href="#static-methods-1">Static methods</a></h2>
<h3 id="fromcbor-1"><a class="header" href="#fromcbor-1"><code>fromCbor</code></a></h3>
<p>Deserializes bytes into an <code>AssetClass</code>.</p>
<pre><code class="language-ts">helios.AssetClass.fromCbor(bytes: []number): helios.AssetClass
</code></pre>
<h2 id="methods-38"><a class="header" href="#methods-38">Methods</a></h2>
<h3 id="tocbor-1"><a class="header" href="#tocbor-1"><code>toCbor</code></a></h3>
<p>Turns an <code>AssetClass</code> instance into its CBOR representation.</p>
<pre><code class="language-ts">asset_class.toCbor(): number[]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assets"><a class="header" href="#assets"><code>Assets</code></a></h1>
<p>Represents a list of tokens. An <code>Assets</code> instance is used as the second argument of the <a href="api/reference/./value.html"><code>Value</code></a> constructor (the first argument is the number of lovelace).</p>
<h2 id="constructor-2"><a class="header" href="#constructor-2">Constructor</a></h2>
<p>The <code>Assets</code> contructor takes one argument: a list of pairs. </p>
<p>The first item of each pair is a <code>MintingPolicyHash</code>, the second item of each pair is another list of pairs of token name bytes and token quantities.</p>
<pre><code class="language-ts">new helios.Assets(assets: [
    helios.MintingPolicyHash,
    [number[], bigint][]
][])
</code></pre>
<h2 id="getters-21"><a class="header" href="#getters-21">Getters</a></h2>
<h3 id="mintingpolicies"><a class="header" href="#mintingpolicies"><code>mintingPolicies</code></a></h3>
<p>Returns a list of all the minting policies (as a list of <code>MintingPolicyHash</code>es).</p>
<pre><code class="language-ts">assets.mintingPolicies: helios.MintingPolicyHash[]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blockfrostv0"><a class="header" href="#blockfrostv0"><code>BlockfrostV0</code></a></h1>
<p>Blockfrost specific implementation of <a href="api/reference/./network.html"><code>Network</code></a>.</p>
<p>WiP.</p>
<h2 id="constructor-3"><a class="header" href="#constructor-3">Constructor</a></h2>
<p>Constructs a <code>BlockfrostV0</code> using the network name (<code>preview</code>, <code>preprod</code> or <code>mainnet</code>) and your Blockfrost project id.</p>
<pre><code class="language-ts">const network = new helios.BlockfrostV0(networkName: string, projectId: string)
</code></pre>
<h2 id="static-methods-2"><a class="header" href="#static-methods-2">Static methods</a></h2>
<h3 id="resolve"><a class="header" href="#resolve"><code>resolve</code></a></h3>
<p>Connect the same network a <a href="api/reference/./wallet.html"><code>Wallet</code></a> is connected to (<code>preview</code>, <code>preprod</code> or <code>mainnet</code>). Throws an error if a Blockfrost project id is missing for that specific network.</p>
<pre><code class="language-ts">const network = helios.BlockforstV0.resolve(
    wallet: helios.Wallet,
    projectIds: {
        preview?: string,
        preprod?: string,
        mainnet?: string
    }
)
</code></pre>
<h2 id="methods-39"><a class="header" href="#methods-39">Methods</a></h2>
<h3 id="getutxos"><a class="header" href="#getutxos"><code>getUtxos</code></a></h3>
<p>Gets a complete list of UTxOs at a given <a href="api/reference/./address.html">address</a>.</p>
<pre><code class="language-ts">network.getUtxos(address: helios.Address): Promise&lt;helios.UTxO[]&gt;
</code></pre>
<h3 id="submittx"><a class="header" href="#submittx"><code>submitTx</code></a></h3>
<p>Submits a <a href="api/reference/./tx.html">transaction</a> to the blockchain. Returns the <a href="api/reference/./txid.html"><code>TxId</code></a>.</p>
<pre><code class="language-ts">network.submitTx(tx: helios.Tx): Promise&lt;helios.TxId&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytearraydata"><a class="header" href="#bytearraydata"><code>ByteArrayData</code></a></h1>
<p>One of Plutus-Core's 5 builtin data types, representing a list of bytes. Parent class is <a href="api/reference/./uplcdata.html"><code>UplcData</code></a>.</p>
<h2 id="constructor-4"><a class="header" href="#constructor-4">Constructor</a></h2>
<pre><code class="language-ts">new helios.ByteArrayData(bytes: []number)
</code></pre>
<h2 id="static-methods-3"><a class="header" href="#static-methods-3">Static methods</a></h2>
<h3 id="fromcbor-2"><a class="header" href="#fromcbor-2"><code>fromCbor</code></a></h3>
<p>Decodes CBOR bytes representing a <code>ByteArrayData</code> instance. Mutates the <code>bytes</code> argument.</p>
<pre><code class="language-ts">helios.ByteArrayData.fromCbor(bytes: []number): helios.ByteArrayData
</code></pre>
<h3 id="fromstring"><a class="header" href="#fromstring"><code>fromString</code></a></h3>
<p>Encodes a utf-8 string as a <code>ByteArrayData</code> instance.</p>
<pre><code class="language-ts">helios.ByteArrayData.fromString(str: string): helios.ByteArrayData
</code></pre>
<h2 id="getters-22"><a class="header" href="#getters-22">Getters</a></h2>
<h3 id="bytes"><a class="header" href="#bytes"><code>bytes</code></a></h3>
<p>Returns the underlying list of bytes.</p>
<pre><code class="language-ts">byte_array_data.bytes: number[]
</code></pre>
<h2 id="methods-40"><a class="header" href="#methods-40">Methods</a></h2>
<h3 id="tocbor-2"><a class="header" href="#tocbor-2"><code>toCbor</code></a></h3>
<p>Encodes a <code>ByteArrayData</code> instance using CBOR.</p>
<pre><code class="language-ts">byte_array_data.toCbor(): number[]
</code></pre>
<h3 id="tohex-1"><a class="header" href="#tohex-1"><code>toHex</code></a></h3>
<p>Returns the hexadecimal string representation of the underlying bytes.</p>
<pre><code class="language-ts">byte_array_data.toHex(): string
</code></pre>
<h3 id="toschemajson"><a class="header" href="#toschemajson"><code>toSchemaJson</code></a></h3>
<p>Returns the JSON representation of a <code>ByteArrayData</code> instance. Needed for interacting with external tools like <em>cardano-cli</em> and <em>Lucid</em>.</p>
<pre><code class="language-ts">byte_array_data.toSchemaJson(): string
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cbordata"><a class="header" href="#cbordata"><code>CborData</code></a></h1>
<p>Base class of each CBOR (de)serializeable type. <code>CborData</code> also contains many static helper methods which can be used to decode/encode CBOR data.</p>
<h2 id="static-methods-4"><a class="header" href="#static-methods-4">Static methods</a></h2>
<h3 id="decodebool"><a class="header" href="#decodebool"><code>decodeBool</code></a></h3>
<p>Decodes a CBOR encoded <code>boolean</code>. Input list is mutated. Throws an error if the next element in <code>bytes</code> isn't a <code>boolean</code>.</p>
<pre><code class="language-ts">helios.CborData.decodeBool(bytes: number[]): boolean
</code></pre>
<h3 id="decodebytes"><a class="header" href="#decodebytes"><code>decodeBytes</code></a></h3>
<p>Unwraps a CBOR encoded list of bytes. Mutates <code>bytes</code> and moves to the following element.</p>
<pre><code class="language-ts">helios.CborData.decodeBytes(bytes: number[]): number[]
</code></pre>
<h3 id="decodeinteger"><a class="header" href="#decodeinteger"><code>decodeInteger</code></a></h3>
<p>Decode a CBOR encoded bigint integer. Mutates <code>bytes</code> and moves to the following element.</p>
<pre><code class="language-ts">helios.CborData.decodeInteger(bytes: number[]): bigint
</code></pre>
<h3 id="decodelist"><a class="header" href="#decodelist"><code>decodeList</code></a></h3>
<p>Decodes a CBOR encoded list. A decoder function is called with the bytes of every contained item (nothing is returning directly). Mutates <code>bytes</code> and moves on to element following the list.</p>
<pre><code class="language-ts">helios.CborData.decodeList(
    bytes: number[], 
    decoder: (number[]) =&gt; void
): void
</code></pre>
<h3 id="decodemap"><a class="header" href="#decodemap"><code>decodeMap</code></a></h3>
<p>Decodes a CBOR encoded map. Calls a decoder function for each key-value pair (nothing is returned directly).</p>
<p>The decoder function is responsible for separating the key from the value, which are simply stored as consecutive CBOR elements.</p>
<pre><code class="language-ts">helios.CborData.decodeMap(
    bytes: number[],
    decoder: (number[]) =&gt; void
): void
</code></pre>
<h3 id="decodenull"><a class="header" href="#decodenull"><code>decodeNull</code></a></h3>
<p>Checks if next element in <code>bytes</code> is a <code>null</code>. Throws an error if it isn't. Mutates <code>bytes</code> by moving to the following element.</p>
<pre><code class="language-ts">helios.CborData.decodeNull(bytes: number[]): void
</code></pre>
<h3 id="decodeobject"><a class="header" href="#decodeobject"><code>decodeObject</code></a></h3>
<p>Decodes a CBOR encoded object. For each field a decoder is called which takes the field index and the field bytes as arguments.</p>
<pre><code class="language-ts">helios.CborData.decodeObject(
    bytes: number[],
    decoder: (number, number[]) =&gt; void
): void
</code></pre>
<h3 id="encodebool"><a class="header" href="#encodebool"><code>encodeBool</code></a></h3>
<p>Encode a <code>boolean</code> into its CBOR representation.</p>
<pre><code class="language-ts">helios.CborData.encodeBool(b: boolean): number[]
</code></pre>
<h3 id="encodebytes"><a class="header" href="#encodebytes"><code>encodeBytes</code></a></h3>
<p>Wraps a list of bytes using CBOR. Optionally splits the <code>bytes</code> in chunks.</p>
<pre><code class="language-ts">helios.CborData.encodeBytes(
    bytes: number[],
    splitInChunks: boolean = false
): number[]
</code></pre>
<h3 id="encodedeflist"><a class="header" href="#encodedeflist"><code>encodeDefList</code></a></h3>
<p>Encodes a list of CBOR encodeable items using CBOR definite length encoding (i.e. header bytes of the element represent the length of the list).</p>
<p>Each item is <code>CborData</code> child instances with the <code>toCbor</code> method defined, or an already encoded list of CBOR bytes.</p>
<pre><code class="language-ts">helios.CborData.encodeDefList(
    list: helios.CborData[] | number[][]
): number[]
</code></pre>
<h3 id="encodeindeflist"><a class="header" href="#encodeindeflist"><code>encodeIndefList</code></a></h3>
<p>Encodes a list of CBOR encodeable items using CBOR indefinite length encoding.</p>
<p>Each item is eiter a <code>CborData</code> child instance with the <code>toCbor</code> method defined, or an already encoded list of CBOR bytes.</p>
<pre><code class="language-ts">helios.encodeIndefList(
    list: helios.CborData[] | number[][]
): number[]
</code></pre>
<h3 id="encodeinteger"><a class="header" href="#encodeinteger"><code>encodeInteger</code></a></h3>
<p>Encodes a bigint integer using CBOR.</p>
<pre><code class="language-ts">helios.CborData.encodeInteger(x: bigint): number[]
</code></pre>
<h3 id="encodemap"><a class="header" href="#encodemap"><code>encodeMap</code></a></h3>
<p>Encodes a list of key-value pairs. Each key and each value is either a <code>CborData</code> child instance with the <code>toCbor</code> method defined, or an already encoded list of CBOR bytes.</p>
<pre><code class="language-ts">helios.CborData.encodeMap(
    pairs: [
        helios.CborData | number[],
        helios.CborData | number[]
    ][]
): number[]
</code></pre>
<h3 id="encodenull"><a class="header" href="#encodenull"><code>encodeNull</code></a></h3>
<p>Encode a <code>null</code> into its CBOR representation.</p>
<pre><code class="language-ts">helios.CborData.encodNull(): number[]
</code></pre>
<h3 id="encodeobject"><a class="header" href="#encodeobject"><code>encodeObject</code></a></h3>
<p>Encodes an object with optional fields. A CBOR object element is simply a map element with integer keys representing the field index.</p>
<pre><code class="language-ts">helios.encodeObject(
    object: Map&lt;
        number,
        helios.CborData | number[]
    &gt;
): number[]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cip30handle"><a class="header" href="#cip30handle"><code>Cip30Handle</code></a></h1>
<p>Convenience type for browser plugin wallets supporting the <a href="https://cips.cardano.org/cips/cip30/">CIP 30 dApp connector</a> standard (eg. Eternl, Nami). </p>
<pre><code class="language-ts">interface Cip30Handle {
    getNetworkId(): Promise&lt;number&gt;,
    getUsedAddresses(): Promise&lt;string[]&gt;,
    getUnusedAddresses(): Promise&lt;string[]&gt;,
    getUtxos(): Promise&lt;string[]&gt;,
    signTx(txHex: string, partialSign: boolean): Promise&lt;string&gt;,
    submitTx(txHex: string): Promise&lt;string&gt;
}
</code></pre>
<p>This is useful in typescript projects to avoid type errors when accessing the handles in <code>window.cardano</code>.</p>
<pre><code class="language-ts">// refer to this file in the 'typeRoots' list in tsconfig.json

type Cip30SimpleHandle = {
    name: string,
    icon: string,
    enable(): Promise&lt;helios.Cip30Handle&gt;,
    isEnabled(): boolean
}

declare global {
  interface Window {
    cardano: {
        [walletName: string]: Cip30SimpleHandle
    };  
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cip30wallet"><a class="header" href="#cip30wallet"><code>Cip30Wallet</code></a></h1>
<p>Implementation of <a href="api/reference/./wallet.html"><code>Wallet</code></a> that lets you connect to a browser plugin wallet.</p>
<h2 id="constructor-5"><a class="header" href="#constructor-5">Constructor</a></h2>
<p>Constructs <code>Cip30Wallet</code> using the <a href="api/reference/./cip30handle.html"><code>Cip30Handle</code></a> which is available in the browser <code>window.cardano</code> context.</p>
<pre><code class="language-ts">const handle: helios.Cip30Handle = await window.cardano.eternl.enable()

const wallet = new helios.Cip30Wallet(handle)
</code></pre>
<h2 id="getters-23"><a class="header" href="#getters-23">Getters</a></h2>
<h3 id="usedaddresses"><a class="header" href="#usedaddresses"><code>usedAddresses</code></a></h3>
<p>Gets a list of addresses which already contain UTxOs.</p>
<pre><code class="language-ts">wallet.usedAddresses: Promise&lt;helios.Address[]&gt;
</code></pre>
<h3 id="unusedaddresses"><a class="header" href="#unusedaddresses"><code>unusedAddresses</code></a></h3>
<p>Gets a list of unique unused addresses which can be used to UTxOs to.</p>
<pre><code class="language-ts">wallet.unusedAddresses: Promise&lt;helios.Address[]&gt;
</code></pre>
<h3 id="utxos"><a class="header" href="#utxos"><code>utxos</code></a></h3>
<p>Gets the complete list of <a href="api/reference/./utxo.html"><code>UTxO</code>s</a> sitting at the addresses owned by the wallet.</p>
<pre><code class="language-ts">wallet.utxos: Promise&lt;helios.UTxO[]&gt;
</code></pre>
<h2 id="methods-41"><a class="header" href="#methods-41">Methods</a></h2>
<h3 id="ismainnet"><a class="header" href="#ismainnet"><code>isMainnet</code></a></h3>
<p>Returns <code>true</code> if the wallet is connected to the mainnet.</p>
<pre><code class="language-ts">wallet.isMainnet(): Promise&lt;boolean&gt;
</code></pre>
<h3 id="signtx"><a class="header" href="#signtx"><code>signTx</code></a></h3>
<p>Signs a <a href="api/reference/./tx.html">transaction</a>, returning a list of signatures needed for submitting a valid transaction.</p>
<pre><code class="language-ts">wallet.signTx(tx: helios.Tx): Promise&lt;helios.Signature[]&gt;
</code></pre>
<h3 id="submittx-1"><a class="header" href="#submittx-1"><code>submitTx</code></a></h3>
<p>Submits a <a href="api/reference/./tx.html">transaction</a> to the blockchain. Returns the <a href="api/reference/./txid.html"><code>TxId</code></a>.</p>
<pre><code class="language-ts">wallet.submitTx(tx: helios.Tx): Promise&lt;helios.TxId&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coinselection"><a class="header" href="#coinselection"><code>CoinSelection</code></a></h1>
<p>Static class with common <a href="https://cips.cardano.org/cips/cip2/">coin selection algorithms</a>.</p>
<h2 id="static-methods-5"><a class="header" href="#static-methods-5">Static methods</a></h2>
<h3 id="selectlargestfirst"><a class="header" href="#selectlargestfirst"><code>selectLargestFirst</code></a></h3>
<p>Selects <a href="api/reference/./utxo.html">UTxOs</a> from a list by iterating through the tokens in the given <a href="api/reference/./value.html"><code>Value</code></a> and picking the <a href="api/reference/./utxo.html">UTxOs</a> containing the largest corresponding amount first.</p>
<p>Returns two lists. The first list contains the selected <a href="api/reference/./utxo.html">UTxOs</a>, the second list contains the remaining <a href="api/reference/./utxos.html">UTxOs</a>.</p>
<pre><code class="language-ts">helios.CoinSelection.selectLargestFirst(
    utxos: helios.UTxO[],
    amount: helios.Value
)
</code></pre>
<h3 id="selectsmallestfirst"><a class="header" href="#selectsmallestfirst"><code>selectSmallestFirst</code></a></h3>
<p>Selects <a href="api/reference/./utxo.html">UTxOs</a> from a list by iterating through the tokens in the given <a href="api/reference/./value.html"><code>Value</code></a> and picking the <a href="api/reference/./utxo.html">UTxOs</a> containing the smallest corresponding amount first. This method can be used to eliminate dust <a href="api/reference/./utxo.html">UTxOs</a> from a wallet.</p>
<p>Returns two lists. The first list contains the selected <a href="api/reference/./utxo.html">UTxOs</a>, the second list contains the remaining <a href="api/reference/./utxo.html">UTxOs</a>.</p>
<pre><code class="language-ts">helios.CoinSelection.selectSmallestFirst(
    utxos: helios.UTxO[],
    amount: helios.Value
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constrdata"><a class="header" href="#constrdata"><code>ConstrData</code></a></h1>
<p>One of the 5 Plutus-Core builtin data classes. Parent class is <a href="api/reference/./uplcdata.html"><code>UplcData</code></a>.</p>
<p>Represents a tag index and a list of data fields. Each field is also a <a href="api/reference/./uplcdata.html"><code>UplcData</code></a> child instance.</p>
<h2 id="constructor-6"><a class="header" href="#constructor-6">Constructor</a></h2>
<pre><code class="language-ts">new helios.ConstrData(
    index: number,
    fields: helios.UplcData[]
)
</code></pre>
<h2 id="static-methods-6"><a class="header" href="#static-methods-6">Static methods</a></h2>
<h3 id="fromcbor-3"><a class="header" href="#fromcbor-3"><code>fromCbor</code></a></h3>
<p>Decoded a CBOR encoded <code>ConstrData</code> instance. Mutates <code>bytes</code> and shifts it to the following element.</p>
<pre><code class="language-ts">helios.ConstrData.fromCbor(bytes: number[]): helios.ConstrData
</code></pre>
<h2 id="getters-24"><a class="header" href="#getters-24">Getters</a></h2>
<h3 id="index-1"><a class="header" href="#index-1"><code>index</code></a></h3>
<p>Returns the <code>ConstrData</code> tag.</p>
<pre><code class="language-ts">constr_data.index: number
</code></pre>
<h3 id="fields"><a class="header" href="#fields"><code>fields</code></a></h3>
<p>Returns the <code>ConstrData</code> fields.</p>
<pre><code class="language-ts">constr_data.fields: helios.UplcData[]
</code></pre>
<h2 id="methods-42"><a class="header" href="#methods-42">Methods</a></h2>
<h3 id="tocbor-3"><a class="header" href="#tocbor-3"><code>toCbor</code></a></h3>
<p>Encodes a <code>ConstrData</code> instance as CBOR bytes.</p>
<pre><code class="language-ts">constr_data.toCbor(): number[]
</code></pre>
<h3 id="toschemajson-1"><a class="header" href="#toschemajson-1"><code>toSchemaJson</code></a></h3>
<p>Returns the schema JSON needed to interact with external tools like <em>cardano-cli</em> and <em>Lucid</em>.</p>
<pre><code class="language-ts">constr_data.toSchemaJson(): string
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crypto"><a class="header" href="#crypto"><code>Crypto</code></a></h1>
<p>The Helios <code>Crypto</code> class contains a collection of cryptography primitives:</p>
<ul>
<li><strong>Mulberry32</strong>: pseudo random number generator</li>
<li><strong>Base32</strong> encoding and decoding</li>
<li><strong>Bech32</strong> encoding, checking, and decoding</li>
<li><strong>Sha2 256</strong>, <strong>Sha2 512</strong>, <strong>Sha3</strong> and <strong>Blake2b</strong> hashing</li>
<li><strong>Ed25519</strong> pubkey generation, signing, and signature verification</li>
</ul>
<p>These functions have been implemented as part of the Helios library in order to avoid external dependencies (there still isn't a standardized Javascript <a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto">Crypto API</a> that provides all the needed functionality).</p>
<h2 id="random-number-generators"><a class="header" href="#random-number-generators">Random number generators</a></h2>
<h3 id="mulberry32"><a class="header" href="#mulberry32"><code>mulberry32</code></a></h3>
<p>A simple pseudo number generator for use in tests that requires some randomness but need to be deterministic (i.e. each test run gives the same result).</p>
<pre><code class="language-ts">helios.Crypto.mulberry32(seed: number): (() =&gt; number)
</code></pre>
<p>The returned function returns a new random number between 0 and 1 upon each call.</p>
<h3 id="rand"><a class="header" href="#rand"><code>rand</code></a></h3>
<p>Alias for <code>mulberry32</code>.</p>
<pre><code class="language-ts">helios.Crypto.rand(seed: number): (() =&gt; number)
</code></pre>
<h2 id="base32"><a class="header" href="#base32">Base32</a></h2>
<p>Needed by Bech32.</p>
<h3 id="encodebase32"><a class="header" href="#encodebase32"><code>encodeBase32</code></a></h3>
<pre><code class="language-ts">helios.Crypto.encodeBase32(
    bytes: number[],
    alphabet: string = DEFAULT_BASE32_ALPHABET
): string
</code></pre>
<h3 id="decodebase32"><a class="header" href="#decodebase32"><code>decodeBase32</code></a></h3>
<pre><code class="language-ts">helios.Crypto.decodeBase32(
    encoded: string,
    alphabet: string = DEFAULT_BASE32_ALPHABET
): number[]
</code></pre>
<h3 id="default_base32_alphabet"><a class="header" href="#default_base32_alphabet"><code>DEFAULT_BASE32_ALPHABET</code></a></h3>
<pre><code class="language-ts">helios.Crypto.DEFAULT_BASE32_ALPHABET: &quot;abcdefghijklmnopqrstuvwxyz234567&quot;
</code></pre>
<h3 id="bech32_base32_alphabet"><a class="header" href="#bech32_base32_alphabet"><code>BECH32_BASE32_ALPHABET</code></a></h3>
<pre><code class="language-ts">helios.Crypto.DEFAULT_BASE32_ALPHABET: &quot;qpzry9x8gf2tvdw0s3jn54khce6mua7l&quot;
</code></pre>
<h2 id="bech32"><a class="header" href="#bech32">Bech32</a></h2>
<p>Address encoding scheme used by Cardano. Includes a checksum.</p>
<h3 id="encodebech32"><a class="header" href="#encodebech32"><code>encodeBech32</code></a></h3>
<p>The human readable part is <code>&quot;addr&quot;</code> or <code>&quot;addr_test&quot;</code> for Cardano addresses.</p>
<pre><code class="language-ts">helios.Crypto.encodeBech32(
    hrp: string, // typically &quot;addr&quot; or &quot;addr_test&quot;
    data: number[]
): string
</code></pre>
<h3 id="decodebech32"><a class="header" href="#decodebech32"><code>decodeBech32</code></a></h3>
<p>Throws an error if the checksum is invalid. Returns both the human readable part and the contained data bytes.</p>
<pre><code class="language-ts">helios.Crypto.decodeBech32(
    encoded: string
): [string, number[]]
</code></pre>
<h3 id="verifybech32"><a class="header" href="#verifybech32"><code>verifyBech32</code></a></h3>
<p>Returns false if the bech32 checksum is incorrect.</p>
<pre><code class="language-ts">helios.Crypto.verifyBech32(encoded: string): boolean
</code></pre>
<h2 id="hashing"><a class="header" href="#hashing">Hashing</a></h2>
<h3 id="sha2_256"><a class="header" href="#sha2_256"><code>sha2_256</code></a></h3>
<p>The returned hash is 32 bytes long.</p>
<pre><code class="language-ts">helios.Crypto.sha2_256(bytes: number[]): number[]
</code></pre>
<h3 id="sha2_512"><a class="header" href="#sha2_512"><code>sha2_512</code></a></h3>
<p>The returned hash is 64 bytes long.</p>
<pre><code class="language-ts">helios.Crypto.sha2_512(bytes: number[]): number[]
</code></pre>
<h3 id="sha3-1"><a class="header" href="#sha3-1"><code>sha3</code></a></h3>
<p>The returned hash is 32 bytes long.</p>
<pre><code class="language-ts">helios.Crypto.sha3(bytes: number[]): number[]
</code></pre>
<h3 id="blake2b-1"><a class="header" href="#blake2b-1"><code>blake2b</code></a></h3>
<p>The returned hash can be up to 64 bytes long (length can be chosen by the caller).</p>
<pre><code class="language-ts">helios.Crypto.blake2b(
    bytes: number[],
    digestSize: number = 32
): number[]
</code></pre>
<h2 id="ed25519"><a class="header" href="#ed25519">Ed25519</a></h2>
<p>The elliptic curve signature algorithm used by Cardano wallets. The current implementation is simple but slow.</p>
<h3 id="derivepublickey"><a class="header" href="#derivepublickey"><code>derivePublicKey</code></a></h3>
<p>Derive a public key from a private key. The private key can be any number of bytes (it's hashed internally). The returned public key is 32 bytes long.</p>
<pre><code class="language-ts">helios.Crypto.Ed25519.derivePublicKey(privateKey: number[]): number[]
</code></pre>
<h3 id="sign"><a class="header" href="#sign"><code>sign</code></a></h3>
<p>Creates a 64 byte signature.</p>
<pre><code class="language-ts">helios.Crypto.Ed25519.sign(
    message: number[],
    privateKey: number[]
): number[]
</code></pre>
<h3 id="verify-1"><a class="header" href="#verify-1"><code>verify</code></a></h3>
<p>Returns <code>true</code> if the signature is correct.</p>
<pre><code class="language-ts">helios.Crypto.Ed25519.verify(
    signature: number[],
    message: number[],
    publicKey: number[]
): boolean
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="datum-2"><a class="header" href="#datum-2"><code>Datum</code></a></h1>
<p>Represents either an inline datum, or a hashed datum.</p>
<h2 id="static-methods-7"><a class="header" href="#static-methods-7">Static methods</a></h2>
<h3 id="fromcbor-4"><a class="header" href="#fromcbor-4"><code>fromCbor</code></a></h3>
<p>Decodes a CBOR encoded datum. Can be inline or hashed.</p>
<p>Mutates <code>bytes</code> and shifts it to the following element.</p>
<pre><code class="language-ts">helios.Datum.fromCbor(bytes: number[]): helios.Datum
</code></pre>
<h3 id="hashed"><a class="header" href="#hashed"><code>hashed</code></a></h3>
<p>Constructs a <code>HashedDatum</code>. The input <code>data</code> is hashed internally.</p>
<pre><code class="language-ts">helios.Datum.hashed(
    data: helios.UplcDataValue | helios.UplcData
): helios.HashedDatum
</code></pre>
<h3 id="inline"><a class="header" href="#inline"><code>inline</code></a></h3>
<p>Constructs an <code>InlineDatum</code>.</p>
<pre><code class="language-ts">helios.Datum.inline(
    data: helios.UplcDataValue | helios.UplcData
): helios.InlineDatum
</code></pre>
<h2 id="getters-25"><a class="header" href="#getters-25">Getters</a></h2>
<h3 id="data-3"><a class="header" href="#data-3"><code>data</code></a></h3>
<p>Return the underlying data, or <code>null</code> if not available.</p>
<pre><code class="language-ts">datum.data: ?helios.UplcData
</code></pre>
<h3 id="hash-4"><a class="header" href="#hash-4"><code>hash</code></a></h3>
<p>Get the <code>DatumHash</code>.</p>
<pre><code class="language-ts">datum.hash: helios.DatumHash
</code></pre>
<h2 id="methods-43"><a class="header" href="#methods-43">Methods</a></h2>
<h3 id="ishashed"><a class="header" href="#ishashed"><code>isHashed</code></a></h3>
<p>Returns <code>true</code> if this is a hashed datum.</p>
<pre><code class="language-ts">datum.isHashed(): boolean
</code></pre>
<h3 id="isinline"><a class="header" href="#isinline"><code>isInline</code></a></h3>
<p>Returns <code>true</code> if this is an inline datum.</p>
<pre><code class="language-ts">datum.isInline(): boolean
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="datumhash-1"><a class="header" href="#datumhash-1"><code>DatumHash</code></a></h1>
<p>Represents a blake2b-256 hash of datum data.</p>
<h2 id="static-methods-8"><a class="header" href="#static-methods-8">Static methods</a></h2>
<h3 id="fromcbor-5"><a class="header" href="#fromcbor-5"><code>fromCbor</code></a></h3>
<p>Deserialize a CBOR encoded <code>DatumHash</code>.</p>
<p>Mutates <code>bytes</code> and shifts it to the next CBOR element.</p>
<pre><code class="language-ts">helios.DatumHash.fromCbor(bytes: number[]): helios.DatumHash
</code></pre>
<h3 id="fromhex-1"><a class="header" href="#fromhex-1"><code>fromHex</code></a></h3>
<p>Construct a <code>DatumHash</code> from the hexadecimal string representation of the underlying bytes.</p>
<pre><code class="language-ts">helios.DatumHash.fromHex(hex: string): helios.DatumHash
</code></pre>
<h2 id="getters-26"><a class="header" href="#getters-26">Getters</a></h2>
<h3 id="bytes-1"><a class="header" href="#bytes-1"><code>bytes</code></a></h3>
<p>Get the underlying bytes.</p>
<pre><code class="language-ts">datum_hash.bytes: number[]
</code></pre>
<h3 id="hex"><a class="header" href="#hex"><code>hex</code></a></h3>
<p>Returns the hexadecimal representation of the underlying bytes.</p>
<pre><code class="language-ts">datum_hash.hex: string
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fuzzytest"><a class="header" href="#fuzzytest"><code>FuzzyTest</code></a></h1>
<p>Helper class for performing fuzzy property-based tests of Helios scripts.</p>
<h2 id="constructor-7"><a class="header" href="#constructor-7">Constructor</a></h2>
<pre><code class="language-ts">new helios.FuzzyTest(
    seed: number = 0,
    runsPerTest: number = 100,
    simplify: boolean = false
)
</code></pre>
<p>The <code>simplify</code> argument specifies whether optimized versions of the Helios sources should also be tested.</p>
<h2 id="methods-44"><a class="header" href="#methods-44">Methods</a></h2>
<h3 id="ascii"><a class="header" href="#ascii"><code>ascii</code></a></h3>
<p>Returns a generator for <a href="api/reference/./bytearraydata.html"><code>ByteArrayData</code></a> instances representing ascii strings.</p>
<pre><code class="language-ts">fuzzy_test.ascii(
    minLength: number = 0,
    maxLength: number = 64
): (() =&gt; helios.ByteArrayData)
</code></pre>
<h3 id="bool-2"><a class="header" href="#bool-2"><code>bool</code></a></h3>
<p>Returns a generator for primitive boolean instances.</p>
<pre><code class="language-ts">fuzzy_test.bool(): (() =&gt; helios.ConstrData)
</code></pre>
<h3 id="bytes-2"><a class="header" href="#bytes-2"><code>bytes</code></a></h3>
<p>Returns a generator for <a href="api/reference/./bytearraydata.html"><code>ByteArrayData</code></a>.</p>
<pre><code class="language-ts">fuzzy_test.bytes(
    minLength: number = 0,
    maxLength: number = 64
): (() =&gt; helios.ByteArrayData)
</code></pre>
<h3 id="int-2"><a class="header" href="#int-2"><code>int</code></a></h3>
<p>Returns a generator for <a href="api/reference/./intdata.html"><code>IntData</code></a>.</p>
<pre><code class="language-ts">fuzzy_test.int(
    min: number = -10000000,
    max: number =  10000000
): (() =&gt; helios.IntData)
</code></pre>
<h3 id="list-2"><a class="header" href="#list-2"><code>list</code></a></h3>
<p>Returns a generator for <a href="api/reference/./listdata.html"><code>ListData</code></a>, where every item is generated by the given <code>itemGenerator</code>.</p>
<pre><code class="language-ts">fuzzy_test.list(
    itemGenerator: () =&gt; helios.UplcData,
    minLength: number = 0,
    maxLength: number = 10
): (() =&gt; helios.ListData)
</code></pre>
<h3 id="map-5"><a class="header" href="#map-5"><code>map</code></a></h3>
<p>Returns a generator for <a href="api/reference/./mapdata.html"><code>MapData</code></a>, where every key and value is generated by the given <code>keyGenerator</code> and <code>valueGenerator</code> respectively.</p>
<pre><code class="language-ts">fuzzy_test.map(
    keyGenerator: () =&gt; helios.UplcData,
    valueGenerator: () =&gt; helios.UplcData,
    minLength: number = 0,
    maxLength: number = 10
): (() =&gt; helios.MapData)
</code></pre>
<h3 id="option-2"><a class="header" href="#option-2"><code>option</code></a></h3>
<p>Returns a generator for <a href="api/reference/./constrdata.html"><code>ConstrData</code></a> instances representing random options. The probability of <em>none</em> occurences can be configured.</p>
<pre><code class="language-ts">fuzzy_test.option(
    someGenerator: () =&gt; helios.UplcData,
    noneProbability: number = 0.5
): (() =&gt; helios.ConstrData)
</code></pre>
<h3 id="string-2"><a class="header" href="#string-2"><code>string</code></a></h3>
<p>Returns a generator for <a href="api/reference/./bytearraydata.html"><code>ByteArrayData</code></a> instances representing utf-8 strings.</p>
<pre><code class="language-ts">fuzzy_test.string(
    minLength: number = 0,
    maxLength: number = 64
): (() =&gt; helios.ByteArrayData)
</code></pre>
<h3 id="test"><a class="header" href="#test"><code>test</code></a></h3>
<p>Perform a fuzzy/property-based test-run of a Helios source. One value generator must be specified per argument of <code>main</code>.</p>
<p>Throws an error if the <code>propTest</code> fails.</p>
<p>The <code>propTest</code> can simply return a <code>boolean</code>, or can return an object with boolean values, and if any of these booleans is <code>false</code> the <code>propTest</code> fails (the keys can be used to provide extra information).</p>
<pre><code class="language-ts">fuzzy_test.test(
    argGens: (() =&gt; helios.UplcData)[],
    src: string,
    propTest: (
        args: helios.UplcValue[], 
        res: helios.UplcValue | helios.UserError
    ) =&gt; (boolean | Object.&lt;string, boolean&gt;)
): Promise&lt;void&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="heliosdata"><a class="header" href="#heliosdata"><code>HeliosData</code></a></h1>
<p>Abstract parent class of Helios API types that can be used directly when <a href="api/reference/./program.html#parameters-1">setting parameters</a>:</p>
<ul>
<li><a href="api/reference/./address.html"><code>Address</code></a></li>
<li><a href="api/reference/./assetclass.html"><code>AssetClass</code></a></li>
<li><code>Bool</code></li>
<li><code>ByteArray</code></li>
<li><a href="api/reference/./datumhash.html"><code>DatumHash</code></a></li>
<li><code>HMap</code></li>
<li><code>HString</code></li>
<li><code>HInt</code></li>
<li><code>HList</code></li>
<li><code>Option</code></li>
<li><a href="api/reference/./pubkeyhash.html"><code>PubKeyHash</code></a></li>
<li><a href="api/reference/./stakekeyhash.html"><code>StakeKeyHash</code></a></li>
<li><a href="api/reference/./stakingvalidatorhash.html"><code>StakingValidatorHash</code></a></li>
<li><a href="api/reference/./txid.html"><code>TxId</code></a></li>
<li><code>TxOutputId</code></li>
<li><a href="api/reference/./validatorhash.html"><code>ValidatorHash</code></a></li>
<li><a href="api/reference/./value.html"><code>Value</code></a></li>
</ul>
<h2 id="methods-45"><a class="header" href="#methods-45">Methods</a></h2>
<h3 id="toschemajson-2"><a class="header" href="#toschemajson-2"><code>toSchemaJson</code></a></h3>
<p>Returns a JSON-string in the schema needed for interaction with non-Helios tools.</p>
<pre><code class="language-ts">helios_data.toSchemaJson(): string
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intdata"><a class="header" href="#intdata"><code>IntData</code></a></h1>
<p>One of the 5 Plutus-Core builtin data classes. Parent class is <a href="api/reference/./uplcdata.html"><code>UplcData</code></a>.</p>
<p>Represents an unbounded integer (bigint).</p>
<h2 id="constructor-8"><a class="header" href="#constructor-8">Constructor</a></h2>
<pre><code class="language-ts">new helios.IntData(value: bigint)
</code></pre>
<h2 id="static-methods-9"><a class="header" href="#static-methods-9">Static methods</a></h2>
<h3 id="fromcbor-6"><a class="header" href="#fromcbor-6"><code>fromCbor</code></a></h3>
<p>Deserialize a CBOR encoded <code>IntData</code>. Mutates <code>bytes</code> and shifts it to the following element.</p>
<pre><code class="language-ts">helios.IntData.fromCbor(bytes: number[]): IntData
</code></pre>
<h2 id="getters-27"><a class="header" href="#getters-27">Getters</a></h2>
<h3 id="value-2"><a class="header" href="#value-2"><code>value</code></a></h3>
<p>Get the underlying bigint value.</p>
<pre><code class="language-ts">int_data.value: bigint
</code></pre>
<h2 id="methods-46"><a class="header" href="#methods-46">Methods</a></h2>
<h3 id="tocbor-4"><a class="header" href="#tocbor-4"><code>toCbor</code></a></h3>
<p>Encodes a <code>IntData</code> instance as CBOR bytes.</p>
<pre><code class="language-ts">int_data.toCbor(): number[]
</code></pre>
<h3 id="toschemajson-3"><a class="header" href="#toschemajson-3"><code>toSchemaJson</code></a></h3>
<p>Returns the schema JSON needed to interact with external tools like <em>cardano-cli</em> and <em>Lucid</em>.</p>
<pre><code class="language-ts">int_data.toSchemaJson(): string
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="listdata"><a class="header" href="#listdata"><code>ListData</code></a></h1>
<p>One of the 5 Plutus-Core builtin data classes. Parent class is <a href="api/reference/./uplcdata.html"><code>UplcData</code></a>.</p>
<p>Represents a list of other <a href="api/reference/./uplcdata.html"><code>UplcData</code></a> instances.</p>
<h2 id="constructor-9"><a class="header" href="#constructor-9">Constructor</a></h2>
<pre><code class="language-ts">new helios.ListData(list: UplcData[])
</code></pre>
<h2 id="static-methods-10"><a class="header" href="#static-methods-10">Static methods</a></h2>
<h3 id="fromcbor-7"><a class="header" href="#fromcbor-7"><code>fromCbor</code></a></h3>
<p>Deserialize a CBOR encoded <code>ListData</code> instance. Mutates <code>bytes</code> and shifts it to the following element.</p>
<pre><code class="language-ts">helios.ListData.fromCbor(bytes: number[]): ListData
</code></pre>
<h2 id="getters-28"><a class="header" href="#getters-28">Getters</a></h2>
<h3 id="list-3"><a class="header" href="#list-3"><code>list</code></a></h3>
<p>Get the underlying <code>UplcData</code> list.</p>
<pre><code class="language-ts">list_data.list: UplcData[]
</code></pre>
<h2 id="methods-47"><a class="header" href="#methods-47">Methods</a></h2>
<h3 id="tocbor-5"><a class="header" href="#tocbor-5"><code>toCbor</code></a></h3>
<p>Encodes a <code>ListData</code> instance as CBOR bytes.</p>
<pre><code class="language-ts">list_data.toCbor(): number[]
</code></pre>
<h3 id="toschemajson-4"><a class="header" href="#toschemajson-4"><code>toSchemaJson</code></a></h3>
<p>Returns the schema JSON needed to interact with external tools like <em>cardano-cli</em> and <em>Lucid</em>.</p>
<pre><code class="language-ts">list_data.toSchemaJson(): string
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mapdata"><a class="header" href="#mapdata"><code>MapData</code></a></h1>
<p>One of the 5 Plutus-Core builtin data classes. Parent class is <a href="api/reference/./uplcdata.html"><code>UplcData</code></a>.</p>
<p>Represents a list of pairs of other <a href="api/reference/./uplcdata.html"><code>UplcData</code></a> instances.</p>
<h2 id="constructor-10"><a class="header" href="#constructor-10">Constructor</a></h2>
<pre><code class="language-ts">new helios.MapData(pairs: [UplcData, UplcData][])
</code></pre>
<h2 id="static-methods-11"><a class="header" href="#static-methods-11">Static methods</a></h2>
<h3 id="fromcbor-8"><a class="header" href="#fromcbor-8"><code>fromCbor</code></a></h3>
<p>Deserialize a CBOR encoded <code>MapData</code> instance. Mutates <code>bytes</code> and shifts it to the following element.</p>
<pre><code class="language-ts">helios.MapData.fromCbor(bytes: number[]): MapData
</code></pre>
<h2 id="getters-29"><a class="header" href="#getters-29">Getters</a></h2>
<h3 id="map-6"><a class="header" href="#map-6"><code>map</code></a></h3>
<p>Get the underlying list of <code>UplcData</code> pairs.</p>
<pre><code class="language-ts">map_data.map: [UplcData, UplcData][]
</code></pre>
<h2 id="methods-48"><a class="header" href="#methods-48">Methods</a></h2>
<h3 id="tocbor-6"><a class="header" href="#tocbor-6"><code>toCbor</code></a></h3>
<p>Encodes a <code>MapData</code> instance as CBOR bytes.</p>
<pre><code class="language-ts">map_data.toCbor(): number[]
</code></pre>
<h3 id="toschemajson-5"><a class="header" href="#toschemajson-5"><code>toSchemaJson</code></a></h3>
<p>Returns the schema JSON needed to interact with external tools like <em>cardano-cli</em> and <em>Lucid</em>.</p>
<pre><code class="language-ts">map_data.toSchemaJson(): string
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mintingpolicyhash-1"><a class="header" href="#mintingpolicyhash-1"><code>MintingPolicyHash</code></a></h1>
<p>Represents a blake2b-224 hash of a minting policy script (first encoded as a CBOR byte-array and prepended by a script version byte).</p>
<h2 id="static-methods-12"><a class="header" href="#static-methods-12">Static methods</a></h2>
<h3 id="fromcbor-9"><a class="header" href="#fromcbor-9"><code>fromCbor</code></a></h3>
<p>Deserialize a CBOR encoded <code>MintingPolicyHash</code>.</p>
<p>Mutates <code>bytes</code> and shifts it to the next CBOR element.</p>
<pre><code class="language-ts">helios.MintingPolicyHash.fromCbor(bytes: number[]): helios.MintingPolicyHash
</code></pre>
<h3 id="fromhex-2"><a class="header" href="#fromhex-2"><code>fromHex</code></a></h3>
<p>Construct a <code>MintingPolicyHash</code> from the hexadecimal string representation of the underlying bytes.</p>
<pre><code class="language-ts">helios.MintingPolicyHash.fromHex(hex: string): helios.MintingPolicyHash
</code></pre>
<h2 id="getters-30"><a class="header" href="#getters-30">Getters</a></h2>
<h3 id="bytes-3"><a class="header" href="#bytes-3"><code>bytes</code></a></h3>
<p>Get the underlying bytes.</p>
<pre><code class="language-ts">minting_policy_hash.bytes: number[]
</code></pre>
<h3 id="hex-1"><a class="header" href="#hex-1"><code>hex</code></a></h3>
<p>Returns the hexadecimal representation of the underlying bytes.</p>
<pre><code class="language-ts">minting_policy_hash.hex: string
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network"><a class="header" href="#network"><code>Network</code></a></h1>
<p>Blockchain query interface. Notably implemented by <a href="api/reference/./blockfrostv0.html"><code>BlockfrostV0</code></a> and <a href="api/reference/./networkemulator.html"><code>NetworkEmulator</code></a>.</p>
<h2 id="methods-49"><a class="header" href="#methods-49">Methods</a></h2>
<h3 id="getutxos-1"><a class="header" href="#getutxos-1"><code>getUtxos</code></a></h3>
<p>Gets a complete list of UTxOs at a given <a href="api/reference/./address.html">address</a>.</p>
<pre><code class="language-ts">network.getUtxs(address: helios.Address): Promise&lt;helios.UTxO[]&gt;
</code></pre>
<h3 id="submittx-2"><a class="header" href="#submittx-2"><code>submitTx</code></a></h3>
<p>Submits a <a href="api/reference/./tx.html">transaction</a> to the blockchain. Returns the <a href="api/reference/./txid.html"><code>TxId</code></a>.</p>
<pre><code class="language-ts">network.submitTx(tx: helios.Tx): Promise&lt;helios.TxId&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networkemulator"><a class="header" href="#networkemulator"><code>NetworkEmulator</code></a></h1>
<p>A simple emulated <a href="api/reference/./network.html"><code>Network</code></a>. This can be used to do integration tests of whole dApps. Staking is not yet supported.</p>
<h2 id="constructor-11"><a class="header" href="#constructor-11">Constructor</a></h2>
<p>Instantiates a <code>NetworkEmulator</code> at slot 0. An optional seed number can be specified, from which all emulated randomness is derived.</p>
<pre><code class="language-ts">const network = new helios.NetworkEmulator(seed: number = 0)
</code></pre>
<h2 id="methods-50"><a class="header" href="#methods-50">Methods</a></h2>
<h3 id="createwallet"><a class="header" href="#createwallet"><code>createWallet</code></a></h3>
<p>Creates a new <a href="api/reference/./walletemulator.html"><code>WalletEmulator</code></a> and populates it with a given lovelace quantity and <a href="api/reference/./assets.html">assets</a> (these are taken from special genesis transactions).</p>
<pre><code class="language-ts">network.createWallet(
    lovelace: bigint,
    assets: helios.Assets
): helios.WalletEmulator
</code></pre>
<h3 id="getutxos-2"><a class="header" href="#getutxos-2"><code>getUtxos</code></a></h3>
<p>Gets a complete list of UTxOs at a given <a href="api/reference/./address.html">address</a>.</p>
<pre><code class="language-ts">network.getUtxos(address: helios.Address): Promise&lt;helios.UTxO[]&gt;
</code></pre>
<h3 id="initnetworkparams"><a class="header" href="#initnetworkparams"><code>initNetworkParams</code></a></h3>
<p>Creates a new <a href="api/reference/./networkparams.html"><code>NetworkParams</code></a> instance that has access to current slot (so that <a href="api/reference/./tx.html"><code>Tx</code></a> validity range can be set automatically during <a href="api/reference/./tx.html#finalize"><code>finalize()</code></a>).</p>
<pre><code class="language-ts">network.initNetworkParams(networkParams: helios.NetworkParams): helios.NetworkParams
</code></pre>
<h3 id="submittx-3"><a class="header" href="#submittx-3"><code>submitTx</code></a></h3>
<p>Validates and submits a transaction to the emulated mempool. Any input UTxOs are immediately marked as spent.</p>
<pre><code class="language-ts">network.submitTx(tx: helios.Tx): Promise&lt;helios.TxId&gt;
</code></pre>
<h3 id="tick"><a class="header" href="#tick"><code>tick</code></a></h3>
<p>Mints a block with the current emulated mempool, and advances the head slot by <code>nSlots</code>.</p>
<pre><code class="language-ts">network.tick(nSlots: bigint)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networkparams"><a class="header" href="#networkparams"><code>NetworkParams</code></a></h1>
<p>Wrapper for the raw JSON containing all the current network parameters.</p>
<p><code>NetworkParams</code> is needed to be able to calculate script budgets and perform transaction building checks.</p>
<p>The raw JSON can be downloaded from the following CDN locations:</p>
<ul>
<li>Preview: <a href="https://d1t0d7c2nekuk0.cloudfront.net/preview.json">https://d1t0d7c2nekuk0.cloudfront.net/preview.json</a></li>
<li>Preprod: <a href="https://d1t0d7c2nekuk0.cloudfront.net/preprod.json">https://d1t0d7c2nekuk0.cloudfront.net/preprod.json</a></li>
<li>Mainnet: <a href="https://d1t0d7c2nekuk0.cloudfront.net/mainnet.json">https://d1t0d7c2nekuk0.cloudfront.net/mainnet.json</a></li>
</ul>
<p>These JSONs are updated daily.</p>
<h2 id="constructor-12"><a class="header" href="#constructor-12">Constructor</a></h2>
<pre><code class="language-js">// in an async context

const networkParams = new helios.NetworkParams(
    await fetch(&quot;https://d1t0d7c2nekuk0.cloudfront.net/preview.json&quot;)
        .then(response =&gt; response.json())
)
</code></pre>
<h2 id="methods-51"><a class="header" href="#methods-51">Methods</a></h2>
<h3 id="slottotime"><a class="header" href="#slottotime"><code>slotToTime</code></a></h3>
<p>Calculates the time (in milliseconds in 01/01/1970) associated with a given slot number.</p>
<pre><code class="language-ts">networkParams.slotToTime(slot: bigint): bigint
</code></pre>
<h3 id="timetoslot"><a class="header" href="#timetoslot"><code>timeToSlot</code></a></h3>
<p>Calculates the slot number associated with a given time. Time is specified as milliseconds since 01/01/1970.</p>
<pre><code class="language-ts">networkParams.timeToSlot(time: bigint): bigint
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="program"><a class="header" href="#program"><code>Program</code></a></h1>
<p>Represents a Helios program containing a <code>main</code> function.</p>
<p>This is the principal API class with which users of the library interact.</p>
<h2 id="constructor-13"><a class="header" href="#constructor-13">Constructor</a></h2>
<p>The constructor isn't intended for direct use. The <code>new</code> static method should be used instead:</p>
<pre><code class="language-ts">helios.Program.new(
    mainSrc: string, 
    moduleSrcs: string[] = []
): helios.Program
</code></pre>
<p>The 1st argument here is the source of the entrypoint of the program. The 2nd argument here is optional, and is a list of the sources of modules that can be import by the entrypoint source.</p>
<h2 id="getters-31"><a class="header" href="#getters-31">Getters</a></h2>
<h3 id="name"><a class="header" href="#name"><code>name</code></a></h3>
<p>Get the name of the script (contained in the <a href="api/reference/../../lang/script-structure.html#script-purpose-1">header of the script</a>).</p>
<pre><code class="language-ts">program.name: string
</code></pre>
<h3 id="paramtypes"><a class="header" href="#paramtypes"><code>paramTypes</code></a></h3>
<p>Returns a mapping of top-level <code>const</code> names to <code>const</code> types.</p>
<pre><code class="language-ts">program.paramTypes: Object.&lt;string, helios.Type&gt;
</code></pre>
<h3 id="parameters"><a class="header" href="#parameters"><code>parameters</code></a></h3>
<p>Returns an object containing all the evaluated parameters.</p>
<pre><code class="language-ts">program.parameters: {[paramName: string]: helios.HeliosData}
</code></pre>
<p><code>HeliosData</code> is the abstract parent class of many Helios API types that have Helios language equivalents.</p>
<h3 id="types"><a class="header" href="#types"><code>types</code></a></h3>
<p>Returns an object containing Javascript contructors for the user-defined types in the main script (including those imported into the main script).</p>
<pre><code class="language-ts">program.types: {[typeName: string]: {new(...any) =&gt; helios.HeliosData}}
</code></pre>
<p>Instantiating these constructors creates objects with <a href="api/reference/./heliosdata.html"><code>HeliosData</code></a> as a parent type.</p>
<h2 id="setters"><a class="header" href="#setters">Setters</a></h2>
<h3 id="parameters-1"><a class="header" href="#parameters-1"><code>parameters</code></a></h3>
<p>Parameters can be set using the <code>parameters</code> setter. Parameters are <a href="api/reference/../../lang/variables.html#const-statements"><code>const</code> statements</a> that are visible in the main Helios script. In many cases a Javascript value can be used directly (i.e. JSON-like).</p>
<pre><code class="language-ts">program.parameters = {MY_PARAM: my_param, ...} as {[name: string]: helios.HeliosData | any}
</code></pre>
<p>Primitive Javascript values can also be used as a rhs when setting parameters like this. Helios will intelligently convert these in the necessary <a href="api/reference/./heliosdata.html"><code>HeliosData</code></a> instances.</p>
<h2 id="methods-52"><a class="header" href="#methods-52">Methods</a></h2>
<h3 id="compile"><a class="header" href="#compile"><code>compile</code></a></h3>
<p>Compiles a Helios program, with optional optimization. Returns a <a href="api/reference/./uplcprogram.html"><code>UplcProgram</code></a> instance.</p>
<pre><code class="language-ts">program.compile(simplify: boolean = false): helios.UplcProgram
</code></pre>
<h3 id="evalparam"><a class="header" href="#evalparam"><code>evalParam</code></a></h3>
<p>Eval the rhs of a <code>const</code> statement, and return the result as a <code>UplcValue</code>.</p>
<pre><code class="language-ts">program.evalParam(paramName: string): helios.UplcValue
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pubkeyhash-2"><a class="header" href="#pubkeyhash-2"><code>PubKeyHash</code></a></h1>
<p>Represents a Blake2-224 hash of public key.</p>
<p>A <code>PubKeyHash</code> is used as the first part of a regular payment <a href="api/reference/./address.html"><code>Address</code></a>.</p>
<h2 id="static-methods-13"><a class="header" href="#static-methods-13">Static methods</a></h2>
<h3 id="fromcbor-10"><a class="header" href="#fromcbor-10"><code>fromCbor</code></a></h3>
<p>Deserialize a CBOR encoded <code>PubKeyHash</code>.</p>
<p>Mutates <code>bytes</code> and shifts it to the next CBOR element.</p>
<pre><code class="language-ts">helios.PubKeyHash.fromCbor(bytes: number[]): helios.PubKeyHash
</code></pre>
<h3 id="fromhex-3"><a class="header" href="#fromhex-3"><code>fromHex</code></a></h3>
<p>Construct a <code>PubKeyHash</code> from its hexadecimal string representation.</p>
<pre><code class="language-ts">helios.PubKeyHash.fromHex(hex: string): helios.PubKeyHash
</code></pre>
<h2 id="getters-32"><a class="header" href="#getters-32">Getters</a></h2>
<h3 id="bytes-4"><a class="header" href="#bytes-4"><code>bytes</code></a></h3>
<p>Get the underlying bytes.</p>
<pre><code class="language-ts">pubkey_hash.bytes: number[]
</code></pre>
<h3 id="hex-2"><a class="header" href="#hex-2"><code>hex</code></a></h3>
<p>Returns the hexadecimal representation.</p>
<pre><code class="language-ts">pubkey_hash.hex: string
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signature"><a class="header" href="#signature"><code>Signature</code></a></h1>
<p>Represents a Ed25519 signature associated with a given public key.</p>
<p>Transactions must be signed by the owners of the public keys of the input UTxOs.</p>
<h2 id="constructor-14"><a class="header" href="#constructor-14">Constructor</a></h2>
<pre><code class="language-ts">new helios.Signature(
    pubKey: number[],
    signatureBytes: number[]
)
</code></pre>
<h2 id="static-methods-14"><a class="header" href="#static-methods-14">Static methods</a></h2>
<h3 id="fromcbor-11"><a class="header" href="#fromcbor-11"><code>fromCbor</code></a></h3>
<p>Deserialize a CBOR encoded <code>Signature</code> instance.</p>
<pre><code class="language-ts">helios.Signature.fromCbor(bytes: number{}): helios.Signature
</code></pre>
<h2 id="methods-53"><a class="header" href="#methods-53">Methods</a></h2>
<h3 id="tocbor-7"><a class="header" href="#tocbor-7"><code>toCbor</code></a></h3>
<p>Encodes a <code>Signature</code> instance using CBOR.</p>
<pre><code class="language-ts">signature.toCbor(): number[]
</code></pre>
<h3 id="verify-2"><a class="header" href="#verify-2"><code>verify</code></a></h3>
<p>Verify that the signature corresponds with the given message bytes.</p>
<p>Throws an error if the signature is wrong.</p>
<pre><code class="language-ts">signature.verify(messageBytes: number[]): void
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stakeaddress"><a class="header" href="#stakeaddress"><code>StakeAddress</code></a></h1>
<p>Wrapper for Cardano stake address bytes. An <code>StakeAddress</code> consists of two parts internally:</p>
<ul>
<li>Header (1 byte, see CIP 8)</li>
<li>Staking witness hash (28 bytes that represent the <a href="api/reference/./stakekeyhash.html"><code>StakeKeyHash</code></a> or <a href="api/reference/./stakingvalidatorhash.html"><code>StakingValidatorHash</code></a>)</li>
</ul>
<p>Stake addresses are used to query the assets held by given staking credentials.</p>
<h2 id="constructor-15"><a class="header" href="#constructor-15">Constructor</a></h2>
<pre><code class="language-ts">new helios.StakeAddress(bytes: []number)
</code></pre>
<h2 id="static-methods-15"><a class="header" href="#static-methods-15">Static methods</a></h2>
<h3 id="fromaddress"><a class="header" href="#fromaddress"><code>fromAddress</code></a></h3>
<p>Convert a regular <a href="api/reference/./address.html"><code>Address</code></a> into a <code>StakeAddress</code>. Throws an error if the <code>Address</code> doesn't have a staking credential.</p>
<pre><code class="language-ts">helios.StakeAddress.fromAddress(address: helios.Address): helios.StakeAddress
</code></pre>
<h3 id="fromcbor-12"><a class="header" href="#fromcbor-12"><code>fromCbor</code></a></h3>
<p>Deserializes bytes into an <code>StakeAddress</code>.</p>
<pre><code class="language-ts">helios.StakeAddress.fromCbor(bytes: []number): helios.StakeAddress
</code></pre>
<h3 id="frombech32-1"><a class="header" href="#frombech32-1"><code>fromBech32</code></a></h3>
<p>Converts a Bech32 string into an <code>StakeAddress</code>:</p>
<pre><code class="language-ts">helios.StakeAddress.fromBech32(str: string): helios.StakeAddress
</code></pre>
<h3 id="fromhash"><a class="header" href="#fromhash"><code>fromHash</code></a></h3>
<p>Converts a <a href="api/reference/./stakekeyhash.html"><code>StakeKeyHash</code></a> or <a href="api/reference/./stakingvalidatorhash.html"><code>StakingValidatorHash</code></a> into <code>StakeAddress</code>.</p>
<pre><code class="language-ts">helios.StakeAddress.fromHash(
    isTestnet: boolean,
    hash: helios.StakeKeyHash | helios.StakingValidatorHash
)
</code></pre>
<blockquote>
<p><strong>Note</strong>: bech32 encoded stake addresses have a &quot;stake&quot; or &quot;stake_test&quot; prefix.</p>
</blockquote>
<h3 id="fromhex-4"><a class="header" href="#fromhex-4"><code>fromHex</code></a></h3>
<p>Constructs a <code>StakeAddress</code> using a hexadecimal string representation of the address bytes.</p>
<pre><code class="language-ts">helios.StakeAddress.fromHex(hex: string): helios.StakeAddress
</code></pre>
<h3 id="isfortestnet-1"><a class="header" href="#isfortestnet-1"><code>isForTestnet</code></a></h3>
<p>Returns <code>true</code> if the given <code>StakeAddress</code> is a testnet address.</p>
<pre><code class="language-ts">helios.StakeAddress.isForTestnet(
    stake_address: helios.StakeAddress
): boolean
</code></pre>
<h2 id="getters-33"><a class="header" href="#getters-33">Getters</a></h2>
<h3 id="stakinghash-2"><a class="header" href="#stakinghash-2"><code>stakingHash</code></a></h3>
<p>Returns the underlying <a href="api/reference/./stakingvalidatorhash.html"><code>StakeKeyHash](./stakekeyhash.md) or [</code>StakingValidatorHash`</a>.</p>
<pre><code class="language-ts">stake_address.stakingHash: (helios.StakeKeyHash | helios.StakingValidatorHash)
</code></pre>
<h2 id="methods-54"><a class="header" href="#methods-54">Methods</a></h2>
<h3 id="tobech32-1"><a class="header" href="#tobech32-1"><code>toBech32</code></a></h3>
<p>Turns a <code>StakeAddress</code> into its Bech32 representation.</p>
<pre><code class="language-ts">stake_address.toBech32(): string
</code></pre>
<h3 id="tocbor-8"><a class="header" href="#tocbor-8"><code>toCbor</code></a></h3>
<p>Turns a <code>StakeAddress</code> into its CBOR representation.</p>
<pre><code class="language-ts">stake_address.toCbor(): number[]
</code></pre>
<h3 id="tohex-2"><a class="header" href="#tohex-2"><code>toHex</code></a></h3>
<p>Turns a <code>StakeAddress</code> into its hexadecimal representation.</p>
<pre><code class="language-ts">stake_address.toHex(): string
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stakekeyhash-1"><a class="header" href="#stakekeyhash-1"><code>StakeKeyHash</code></a></h1>
<p>Represents a blake2b-224 hash of staking key.</p>
<p>A <code>StakeKeyHash</code> can be used as the second part of a regular payment <a href="api/reference/./address.html"><code>Address</code></a>, or to construct a <a href="api/reference/./stakeaddress.html"><code>StakeAddress</code></a>.</p>
<h2 id="static-methods-16"><a class="header" href="#static-methods-16">Static methods</a></h2>
<h3 id="fromcbor-13"><a class="header" href="#fromcbor-13"><code>fromCbor</code></a></h3>
<p>Deserialize a CBOR encoded <code>StakeKeyHash</code>.</p>
<p>Mutates <code>bytes</code> and shifts it to the next CBOR element.</p>
<pre><code class="language-ts">helios.StakeKeyHash.fromCbor(bytes: number[]): helios.StakeKeyHash
</code></pre>
<h3 id="fromhex-5"><a class="header" href="#fromhex-5"><code>fromHex</code></a></h3>
<p>Construct a <code>StakeKeyHash</code> from its hexadecimal string representation.</p>
<pre><code class="language-ts">helios.StakeKeyHash.fromHex(hex: string): helios.StakeKeyHash
</code></pre>
<h2 id="getters-34"><a class="header" href="#getters-34">Getters</a></h2>
<h3 id="bytes-5"><a class="header" href="#bytes-5"><code>bytes</code></a></h3>
<p>Get the underlying bytes.</p>
<pre><code class="language-ts">stakekey_hash.bytes: number[]
</code></pre>
<h3 id="hex-3"><a class="header" href="#hex-3"><code>hex</code></a></h3>
<p>Returns the hexadecimal representation.</p>
<pre><code class="language-ts">stakekey_hash.hex: string
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stakingvalidatorhash-1"><a class="header" href="#stakingvalidatorhash-1"><code>StakingValidatorHash</code></a></h1>
<p>Represents a blake2b-224 hash of a staking script (first encoded as a CBOR byte-array and prepended by a script version byte).</p>
<h2 id="static-methods-17"><a class="header" href="#static-methods-17">Static methods</a></h2>
<h3 id="fromcbor-14"><a class="header" href="#fromcbor-14"><code>fromCbor</code></a></h3>
<p>Deserialize a CBOR encoded <code>StakingValidatorHash</code>.</p>
<p>Mutates <code>bytes</code> and shifts it to the next CBOR element.</p>
<pre><code class="language-ts">helios.StakingValidatorHash.fromCbor(bytes: number[]): helios.StakingValidatorHash
</code></pre>
<h3 id="fromhex-6"><a class="header" href="#fromhex-6"><code>fromHex</code></a></h3>
<p>Construct a <code>StakingValidatorHash</code> from the hexadecimal string representation of the underlying bytes.</p>
<pre><code class="language-ts">helios.StakingValidatorHash.fromHex(hex: string): helios.StakingValidatorHash
</code></pre>
<h2 id="getters-35"><a class="header" href="#getters-35">Getters</a></h2>
<h3 id="bytes-6"><a class="header" href="#bytes-6"><code>bytes</code></a></h3>
<p>Get the underlying bytes.</p>
<pre><code class="language-ts">staking_validator_hash.bytes: number[]
</code></pre>
<h3 id="hex-4"><a class="header" href="#hex-4"><code>hex</code></a></h3>
<p>Returns the hexadecimal representation of the underlying bytes.</p>
<pre><code class="language-ts">staking_validator_hash.hex: string
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tx-3"><a class="header" href="#tx-3"><code>Tx</code></a></h1>
<p>Represents a cardano transaction. Can also be used a transaction builder.</p>
<h2 id="constructor-16"><a class="header" href="#constructor-16">Constructor</a></h2>
<p>Init a new transaction builder.</p>
<pre><code class="language-ts">new helios.Tx()
</code></pre>
<h2 id="static-methods-18"><a class="header" href="#static-methods-18">Static methods</a></h2>
<h3 id="fromcbor-15"><a class="header" href="#fromcbor-15"><code>fromCbor</code></a></h3>
<p>Deserialize a CBOR encoded Cardano transaction.</p>
<pre><code class="language-ts">helios.Tx.fromCbor(bytes: number[]): helios.Tx
</code></pre>
<h2 id="methods-55"><a class="header" href="#methods-55">Methods</a></h2>
<h3 id="addcollateral"><a class="header" href="#addcollateral"><code>addCollateral</code></a></h3>
<p>Add a <a href="api/reference/./utxo.html"><code>UTxO</code></a> instance as collateral to the transaction being built. Usually adding only one collateral input is enough. The number of collateral inputs must be greater than 0 if script witnesses are used in the transaction, and must be less than the limit defined in the <a href="api/reference/./networkparams.html"><code>NetworkParams</code></a>.</p>
<p>Mutates the transaction. Only available when building the transaction. Returns the transaction instance so build methods can be chained.</p>
<pre><code class="language-ts">tx.addCollateral(input: helios.TxInput): helios.Tx
</code></pre>
<h3 id="addinput"><a class="header" href="#addinput"><code>addInput</code></a></h3>
<p>Add a <a href="api/reference/./utxo.html"><code>UTxO</code></a> instance as an input to the transaction being built. Throws an error if the UTxO is locked at a script address but a redeemer isn't specified.</p>
<p>Mutates the transaction. Only available when building the transaction. Returns the transaction instance so build methods can be chained.</p>
<pre><code class="language-ts">tx.addInput(
    input: helios.UTxO,
    redeemer: ?(helios.UplcData | helios.UplcDataValue) = null
): helios.Tx
</code></pre>
<h3 id="addinputs"><a class="header" href="#addinputs"><code>addInputs</code></a></h3>
<p>Add multiple <a href="api/reference/./utxo.html"><code>UTxO</code></a> instances as inputs to the transaction being built. Throws an error if the UTxOs are locked at a script address but a redeemer isn't specified.</p>
<p>Mutates the transaction. Only available when building the transaction. Returns the transaction instance so build methods can be chained.</p>
<pre><code class="language-ts">tx.addInputs(
    inputs: helios.UTxO[],
    redeemer: ?(helios.UplcData | helios.UplcDataValue) = null
): helios.Tx
</code></pre>
<h3 id="addmetadata"><a class="header" href="#addmetadata"><code>addMetadata</code></a></h3>
<p>Add metadata to a transaction. Metadata can be used to store data on-chain, but can't be consumed by validator scripts. Metadata can for example be used for <a href="https://cips.cardano.org/cips/cip25/">CIP 25</a>. </p>
<pre><code class="language-ts">tx.addMetadata(
    tag: number, // whole number
    metadata: Metadata
)
</code></pre>
<p>The <code>Metadata</code> type is an alias for the following JSON schema:</p>
<pre><code class="language-ts">@typedef {
  string |
  number | // whole numbers only
  Metadata[] | 
  {map: [Metadata, Metadata][]} // a map is implemented as a list of pairs because order needs to be respected
} Metadata
</code></pre>
<h3 id="addoutput"><a class="header" href="#addoutput"><code>addOutput</code></a></h3>
<p>Add a <a href="api/reference/./txoutput.html"><code>TxOutput</code></a> instance to the transaction being built.</p>
<p>Mutates the transaction. Only available when building the transaction. Returns the transaction instance so build methods can be chained.</p>
<pre><code class="language-ts">tx.addOutput(output: helios.TxOutput): helios.Tx
</code></pre>
<h3 id="addoutputs"><a class="header" href="#addoutputs"><code>addOutputs</code></a></h3>
<p>Add multiple <a href="api/reference/./txoutput.html"><code>TxOutput</code></a> instances at once.</p>
<p>Mutates the transaction. Only available when building the transaction. Returns the transaction instance so build methods can be chained.</p>
<pre><code class="language-ts">tx.addOutputs(outputs: helios.TxOutput[]): helios.Tx
</code></pre>
<h3 id="addrefinput"><a class="header" href="#addrefinput"><code>addRefInput</code></a></h3>
<p>Add a <a href="api/reference/./txrefinput.html"><code>TxRefInput</code></a> instance as a reference input to the transaction being built. An associated reference script, as a <a href="api/reference/./uplcprogram.html"><code>UplcProgram</code></a> instance, must also be included in the transaction at this point (so the that the execution budget can be calculated correctly).</p>
<p>Mutates the transaction. Only available when building the transaction. Returns the transaction instance so build methods can be chained.</p>
<pre><code class="language-ts">tx.addRefInput(
    input: helios.TxRefInput
    refScript: ?helios.UplcProgram = null
): helios.Tx
</code></pre>
<h3 id="addrefinputs"><a class="header" href="#addrefinputs"><code>addRefInputs</code></a></h3>
<p>Add multiple <a href="api/reference/./txrefinput.html"><code>TxRefInput</code></a> instances as reference inputs to the transaction being built.</p>
<p>Mutates the transaction. Only available when building the transaction. Returns the transaction instance so build methods can be chained.</p>
<pre><code class="language-ts">tx.addRefInputs(inputs: helios.TxRefInput[]): helios.Tx
</code></pre>
<h3 id="addsignature"><a class="header" href="#addsignature"><code>addSignature</code></a></h3>
<p>Add a signature created by a wallet. Only available after the transaction has been finalized. Optionally verify that the signature is correct.</p>
<pre><code class="language-ts">tx.addSignature(
    signature: helios.Signature,
    verify: boolean = true
): helios.Tx
</code></pre>
<h3 id="addsignatures"><a class="header" href="#addsignatures"><code>addSignatures</code></a></h3>
<p>Add multiple signatures at once. Only available after the transaction has been finalized. Optionally verify correctness (could be slow for many signatures).</p>
<pre><code class="language-ts">tx.addSignatures(
    signatures: helios.Signature[],
    verify: boolean = true
): helios.Tx
</code></pre>
<h3 id="addsigner"><a class="header" href="#addsigner"><code>addSigner</code></a></h3>
<p>Add a signatory <a href="api/reference/./pubkeyhash.html"><code>PubKeyHash</code></a> to the transaction being built. The added entry becomes available in the <a href="api/reference/../../lang/builtins/tx.html#signatories"><code>tx.signatories</code></a> field in the Helios script.</p>
<p>Mutates the transaction. Only available when building the transaction. Returns the transaction instance so build methods can be chained.</p>
<pre><code class="language-ts">tx.addSigner(hash: helios.PubKeyHash): helios.Tx
</code></pre>
<h3 id="attachscript"><a class="header" href="#attachscript"><code>attachScript</code></a></h3>
<p>Attach a script witness to the transaction being built. The script witness is a <a href="api/reference/./uplcprogram.html"><code>UplcProgram</code></a> instance and can be created by compiling a Helios <a href="api/reference/./program.html"><code>Program</code></a>.</p>
<p>Throws an error if script has already been added. Throws an error if the script isn't used upon finalization.</p>
<p>Mutates the transaction. Only available when building the transaction. Returns the transaction instance so build methods can be chained.</p>
<pre><code class="language-ts">tx.attachScript(script: helios.UplcProgram): helios.Tx
</code></pre>
<h3 id="finalize"><a class="header" href="#finalize"><code>finalize</code></a></h3>
<p>Executes all the attached scripts with appropriate redeemers and calculates execution budgets. Balances the transaction, and optionally uses some spare UTxOs if the current inputs don't contain enough lovelace to cover the fees and min output deposits.</p>
<p>Inputs, minted assets, and withdrawals are sorted.</p>
<p>Sets the validatity range automatically if a call to <a href="api/reference/../../lang/builtins/tx.html#time_range"><code>tx.time_range</code></a> is detected in any of the attached scripts.</p>
<pre><code class="language-ts">tx.finalize(
    networkParams: helios.NetworkParams,
    changeAddress: helios.Address,
    spareUtxos:    helios.UTxO[]
): Promise&lt;Tx&gt;
</code></pre>
<h3 id="minttokens"><a class="header" href="#minttokens"><code>mintTokens</code></a></h3>
<p>Mint a list of tokens associated with a given <a href="api/reference/./mintingpolicyhash.html"><code>MintingPolicyHash</code></a>. Throws an error if the given <a href="api/reference/./mintingpolicyhash.html"><code>MintingPolicyHash</code></a> was already used in a previous call to <code>mintTokens</code>. The token names can either by a list of bytes or a hexadecimal string.</p>
<p>Mutates the transaction. Only available when building the transaction. Returns the transaction instance so build methods can be chained.</p>
<pre><code class="language-ts">tx.mintTokens(
    mph: helios.MintingPolicyHash,
    tokens: [number[] | string, bigint][],
    redeemer: helios.UplcData | helios.UplcDataValue
): helios.Tx
</code></pre>
<h3 id="tocbor-9"><a class="header" href="#tocbor-9"><code>toCbor</code></a></h3>
<p>Serialize a transaction.</p>
<pre><code class="language-ts">tx.toCbor(): number[]
</code></pre>
<h3 id="validfrom"><a class="header" href="#validfrom"><code>validFrom</code></a></h3>
<p>Set the start of the valid time range.</p>
<p>Mutates the transaction. Only available when building the transaction. Returns the transaction instance so build methods can be chained.</p>
<pre><code class="language-ts">tx.validFrom(time: Date): helios.Tx
</code></pre>
<blockquote>
<p><strong>Note</strong>: since Helios v0.13.29 this is set automatically if any of the validator scripts call <a href="api/reference/../../lang/builtins/tx.html#time_range"><code>tx.time_range</code></a>.</p>
</blockquote>
<h3 id="validto"><a class="header" href="#validto"><code>validTo</code></a></h3>
<p>Set the end of the valid time range. Mutates the transaction. Only available when building a transaction.</p>
<p>Returns the transaction instance so build methods can be chained.</p>
<pre><code class="language-ts">tx.validTo(time: Date): helios.Tx
</code></pre>
<blockquote>
<p><strong>Note</strong>: since Helios v0.13.29 this is set automatically if any of the validator scripts call <a href="api/reference/../../lang/builtins/tx.html#time_range"><code>tx.time_range</code></a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="txid-1"><a class="header" href="#txid-1"><code>TxId</code></a></h1>
<p>Represents the hash of a transaction. This is used to identify an UTxO (along with the index of the UTxO in the list of UTxOs created by the transaction).</p>
<h2 id="static-methods-19"><a class="header" href="#static-methods-19">Static methods</a></h2>
<h3 id="fromcbor-16"><a class="header" href="#fromcbor-16"><code>fromCbor</code></a></h3>
<p>Deserialize a CBOR encoded <code>TxId</code>.</p>
<p>Shift <code>bytes</code> to the next CBOR element.</p>
<pre><code class="language-ts">helios.TxId.fromCbor(bytes: number[]): helios.TxId
</code></pre>
<h3 id="fromhex-7"><a class="header" href="#fromhex-7"><code>fromHex</code></a></h3>
<p>Construct a <code>TxId</code> from the hexadecimal string representation of the underlying bytes.</p>
<pre><code class="language-ts">helios.TxId.fromHex(hex: string): helios.TxId
</code></pre>
<h2 id="getters-36"><a class="header" href="#getters-36">Getters</a></h2>
<h3 id="bytes-7"><a class="header" href="#bytes-7"><code>bytes</code></a></h3>
<p>Get the underlying bytes.</p>
<pre><code class="language-ts">tx_id.bytes: number[]
</code></pre>
<h3 id="hex-5"><a class="header" href="#hex-5"><code>hex</code></a></h3>
<p>Returns the hexadecimal representation of the underlying bytes.</p>
<pre><code class="language-ts">tx_id.hex: string
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="txoutput-1"><a class="header" href="#txoutput-1"><code>TxOutput</code></a></h1>
<p>Represents a transaction output that is used when <a href="api/reference/./tx.html#addoutput">building a transaction</a>.</p>
<h2 id="constructor-17"><a class="header" href="#constructor-17">Constructor</a></h2>
<p>Constructs a <code>TxOutput</code> instance using an <a href="api/reference/./address.html"><code>Address</code></a>, a <a href="api/reference/./value.html"><code>Value</code></a>, an optional <a href="api/reference/./datum.html"><code>Datum</code></a>, and optional <a href="api/reference/./uplcprogram.html"><code>UplcProgram</code></a> reference script.</p>
<pre><code class="language-ts">new helios.TxOutput(
    address:   helios.Address,
    value:     helios.Value,
    datum:     ?helios.Datum = null,
    refScript: ?helios.UplcProgram = null
)
</code></pre>
<h2 id="static-methods-20"><a class="header" href="#static-methods-20">Static methods</a></h2>
<h3 id="fromcbor-17"><a class="header" href="#fromcbor-17"><code>fromCbor</code></a></h3>
<p>Deserialize a CBOR encoded <code>TxOutput</code>.</p>
<p>Shift <code>bytes</code> to the next CBOR element.</p>
<pre><code class="language-ts">helios.TxOutput.fromCbor(bytes: number[]): helios.TxOutput
</code></pre>
<h2 id="getters-37"><a class="header" href="#getters-37">Getters</a></h2>
<h3 id="address-4"><a class="header" href="#address-4"><code>address</code></a></h3>
<p>Get the <a href="api/reference/./address.html"><code>Address</code></a> to which the <code>TxOutput</code> will be sent.</p>
<pre><code class="language-ts">tx_output.address: helios.Address
</code></pre>
<h3 id="datum-3"><a class="header" href="#datum-3"><code>datum</code></a></h3>
<p>Get the optional <a href="api/reference/./datum.html"><code>Datum</code></a> associated with the <code>TxOutput</code>.</p>
<pre><code class="language-ts">tx_output.datum: helios.Datum
</code></pre>
<h3 id="value-3"><a class="header" href="#value-3"><code>value</code></a></h3>
<p>Get the <a href="api/reference/./value.html"><code>Value</code></a> contained in the <code>TxOutput</code>.</p>
<pre><code class="language-ts">tx_output.value: helios.Value
</code></pre>
<h2 id="methods-56"><a class="header" href="#methods-56">Methods</a></h2>
<h3 id="correctlovelace"><a class="header" href="#correctlovelace"><code>correctLovelace</code></a></h3>
<p>Makes sure the <code>TxOutput</code> contains the minimum quantity of lovelace. The network requires this to avoid the creation of unusable dust UTxOs.</p>
<p>Optionally an update function can be specified that allows mutating the datum of the <code>TxOutput</code> to account for an increase of the lovelace quantity contained in the value.</p>
<pre><code class="language-ts">tx_output.correctLovelace(
    networkParams: helios.NetworkParams,
    updater: ?((self: helios.TxOutput) =&gt; void)
): void
</code></pre>
<h3 id="setdatum"><a class="header" href="#setdatum"><code>setDatum</code></a></h3>
<p>Mutates the <code>TxOutput</code> datum.</p>
<pre><code class="language-ts">tx_output.setDatum(datum: helios.Datum): void
</code></pre>
<h3 id="tocbor-10"><a class="header" href="#tocbor-10"><code>toCbor</code></a></h3>
<p>Serialize a <code>TxOutput</code> using CBOR.</p>
<pre><code class="language-ts">tx_output.toCbor(): number[]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="txrefinput"><a class="header" href="#txrefinput"><code>TxRefInput</code></a></h1>
<p>A reference input (similar to <a href="api/reference/./utxo.html"><code>UTxO</code></a>, but without information about original transaction output).</p>
<p>Needed for <a href="api/reference/./tx.html#addrefinput"><code>tx.addRefInput()</code></a> and <a href="api/reference/./tx.html#addrefinputs"><code>tx.addRefInputs()</code></a>.</p>
<h2 id="constructor-18"><a class="header" href="#constructor-18">Constructor</a></h2>
<p>A <code>TxRefInput</code> instance is constructed using the <a href="api/reference/./txid.html"><code>TxId</code></a> where the UTxO was created, and the index of that UTxO in the list of UTxOs created by that transactions.</p>
<pre><code class="language-ts">new helios.TxRefInput(
    txId: TxId,
    utxoIdx: bigint
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="txwitnesses"><a class="header" href="#txwitnesses"><code>TxWitnesses</code></a></h1>
<p>Represents the pubkey signatures, and datums/redeemers/scripts that are witnessing a transaction.</p>
<p>The CBOR representation of <code>TxWitnesses</code> is returned by a wallet when signing a transaction.</p>
<h2 id="static-methods-21"><a class="header" href="#static-methods-21">Static methods</a></h2>
<h3 id="fromcbor-18"><a class="header" href="#fromcbor-18"><code>fromCbor</code></a></h3>
<p>Deserialize a CBOR encoded <code>TxWitnesses</code> instance.</p>
<p>Shifts <code>bytes</code> to the next CBOR element.</p>
<pre><code class="language-ts">helios.TxWitnesses.fromCbor(bytes: number[]): helios.TxWitnesses
</code></pre>
<h2 id="getters-38"><a class="header" href="#getters-38">Getters</a></h2>
<h3 id="signatures"><a class="header" href="#signatures"><code>signatures</code></a></h3>
<p>Gets the list of <a href="api/reference/./signature.html"><code>Signature</code></a> instances created by a wallet.</p>
<pre><code class="language-ts">tx_witnesses.signatures: helios.Signature[]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uplcbool"><a class="header" href="#uplcbool"><code>UplcBool</code></a></h1>
<p>API equivalent of <a href="api/reference/../../lang/builtins/bool.html"><code>Bool</code></a>.</p>
<h2 id="static-methods-22"><a class="header" href="#static-methods-22">Static methods</a></h2>
<h3 id="new-19"><a class="header" href="#new-19"><code>new</code></a></h3>
<p>Constructs a <code>UplcBool</code> instance.</p>
<pre><code class="language-ts">helios.UplcBool.new(value: boolean): helios.UplcBool
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uplcbytearray"><a class="header" href="#uplcbytearray"><code>UplcByteArray</code></a></h1>
<p>Primitive equivalent of <a href="api/reference/./bytearraydata.html"><code>ByteArrayData</code></a>. Not needed to interact with Helios smart contracts, but can be used to interact with smart contracts written in other languages (eg. Plutarch).</p>
<h2 id="static-methods-23"><a class="header" href="#static-methods-23">Static methods</a></h2>
<h3 id="new-20"><a class="header" href="#new-20"><code>new</code></a></h3>
<p>Constructs a <code>UplcByteArray</code> instance.</p>
<pre><code class="language-ts">helios.UplcByteArray.new(value: number[]): helios.UplcByteArray
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uplcdata"><a class="header" href="#uplcdata"><code>UplcData</code></a></h1>
<p>Parent class of:</p>
<ul>
<li><a href="api/reference//.bytearraydata.html"><code>ByteArrayData</code></a></li>
<li><a href="api/reference/./constrdata.html"><code>ConstrData</code></a></li>
<li><a href="api/reference/./intdata.html"><code>IntData</code></a></li>
<li><a href="api/reference/./listdata.html"><code>ListData</code></a></li>
<li><a href="api/reference/./mapdata.html"><code>MapData</code></a></li>
</ul>
<h2 id="static-methods-24"><a class="header" href="#static-methods-24">Static methods</a></h2>
<h3 id="fromcbor-19"><a class="header" href="#fromcbor-19"><code>fromCbor</code></a></h3>
<p>Deserializes a CBOR encoded <code>UplcData</code> child instance.</p>
<p>Shift <code>bytes</code> to the next CBOR element.</p>
<pre><code class="language-ts">helios.UplcData.fromCbor(bytes: number[]): 
    helios.ByteArrayData |
    helios.ConstrData |
    helios.IntData |
    helios.ListData |
    helios.MapData
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uplcdatavalue"><a class="header" href="#uplcdatavalue"><code>UplcDataValue</code></a></h1>
<p>Represents a child instance of <a href="api/reference/./uplcvalue.html"><code>UplcValue</code></a>, wrapping a <a href="api/reference/./uplcdata.html"><code>UplcData</code></a> instance.</p>
<p>Everything except a Helios <a href="api/reference/../../lang/builtins/bool.html"><code>Bool</code></a> value <a href="api/reference/./program.html#evalparam">evaluates</a> to a <code>UplcDataValue</code>.</p>
<h2 id="getters-39"><a class="header" href="#getters-39">Getters</a></h2>
<h3 id="data-4"><a class="header" href="#data-4"><code>data</code></a></h3>
<p>Get the underlying <a href="api/reference/./uplcdata.html"><code>UplcData</code></a>.</p>
<pre><code class="language-ts">uplc_data_value.data: helios.UplcData
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uplcint"><a class="header" href="#uplcint"><code>UplcInt</code></a></h1>
<p>Primitive equivalent of <a href="api/reference/./intdata.html"><code>IntData</code></a>. Not needed to interact with Helios smart contracts, but can be used to interact with smart contracts written in other languages (eg. Plutarch).</p>
<h2 id="static-methods-25"><a class="header" href="#static-methods-25">Static methods</a></h2>
<h3 id="new-21"><a class="header" href="#new-21"><code>new</code></a></h3>
<p>Constructs a <code>UplcInt</code> instance. <code>value</code> must be a whole number.</p>
<pre><code class="language-ts">helios.UplcInt.new(value: number | bigint): helios.UplcInt
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uplcpair"><a class="header" href="#uplcpair"><code>UplcPair</code></a></h1>
<p>Primitive pair value. Not needed to interact with Helios smart contracts, but can be used to interact with smart contracts written in other languages (eg. Plutarch).</p>
<h2 id="static-methods-26"><a class="header" href="#static-methods-26">Static methods</a></h2>
<h3 id="new-22"><a class="header" href="#new-22"><code>new</code></a></h3>
<p>Constructs a <code>UplcPair</code> instance using two <a href="api/reference/./uplcvalue.html"><code>UplcValue</code></a> instances.</p>
<pre><code class="language-ts">helios.UplcPair.new(
    first: helios.UplcValue, 
    second: helios.UplcValue
): helios.UplcPair
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uplcprogram"><a class="header" href="#uplcprogram"><code>UplcProgram</code></a></h1>
<p>Result of <a href="api/reference/./program.html#compile"><code>program.compile()</code></a>. Contains the Untyped Plutus-Core AST, along with a code-mapping to the original source.</p>
<h2 id="static-methods-27"><a class="header" href="#static-methods-27">Static methods</a></h2>
<h3 id="fromcbor-20"><a class="header" href="#fromcbor-20"><code>fromCbor</code></a></h3>
<p>Deserialize a <code>UplcProgram</code> from bytes or from a hexadecimal string.</p>
<pre><code class="language-ts">helios.UplcProgram.fromCbor(bytes: number[] | string): helios.UplcProgram
</code></pre>
<h2 id="getters-40"><a class="header" href="#getters-40">Getters</a></h2>
<h3 id="validatorhash-2"><a class="header" href="#validatorhash-2"><code>validatorHash</code></a></h3>
<p>Returns the <a href="api/reference/./validatorhash.html"><code>ValidatorHash</code></a> of the script. Throws an error if this isn't a spending validator script.</p>
<pre><code class="language-ts">uplcProgram.validatorHash: helios.ValidatorHash
</code></pre>
<h3 id="mintingpolicyhash-2"><a class="header" href="#mintingpolicyhash-2"><code>mintingPolicyHash</code></a></h3>
<p>Returns the <a href="api/reference/./mintingpolicyhash.html"><code>MintingPolicyHash</code></a> of the script. Throws an error if this isn't a minting policy.</p>
<pre><code class="language-ts">uplcProgram.mintingPolicyHash: helios.MintingPolicyHash
</code></pre>
<h3 id="stakingvalidatorhash-2"><a class="header" href="#stakingvalidatorhash-2"><code>stakingValidatorHash</code></a></h3>
<p>Returns the <a href="api/reference/./stakingvalidatorhash.html"><code>StakingValidatorHash</code></a> of the script. Throws an error if this isn't a staking validator script.</p>
<pre><code class="language-ts">uplcProgram.stakingValidatorHash: helios.StakingValidatorHash
</code></pre>
<h2 id="methods-57"><a class="header" href="#methods-57">Methods</a></h2>
<h3 id="apply"><a class="header" href="#apply"><code>apply</code></a></h3>
<p>Wrap the top-level term with consecutive <code>UplcCall</code> (not exported) terms.</p>
<p>Returns a new <code>UplcProgram</code> instance, leaving the original untouched.</p>
<pre><code class="language-ts">uplcProgram.apply(args: helios.UplcValue[]): helios.UplcProgram
</code></pre>
<h3 id="profile"><a class="header" href="#profile"><code>profile</code></a></h3>
<p>Runs and profiles a <code>UplcProgram</code>. Needs the <a href="api/reference/./networkparams.html"><code>NetworkParams</code></a> in order to calculate the execution budget.</p>
<pre><code class="language-ts">uplcProgram.profile(
    args: helios.UplcValue[],
    networkParams: helios.NetworkParams
): Promise&lt;{
    mem: bigint, 
	cpu: bigint,
	size: number,
	builtins: {[name: string]: {mem: bigint, cpu: bigint}},
	terms: {[name: string]: {mem: bigint, cpu: bigint}},
	result: UserError | UplcValue,
	messages: string[]
}&gt;
</code></pre>
<p>The returned profile contains a breakdown of the execution cost per Uplc term type and per Uplc builtin function type.</p>
<h3 id="runwithprint"><a class="header" href="#runwithprint"><code>runWithPrint</code></a></h3>
<p>Run a <code>UplcProgram</code>. The printed messages are part of the return value.</p>
<pre><code class="language-ts">uplcProgram.runWithPrint(args: helios.UplcValue[]): 
    Promise&lt;[helios.UplcValue | helios.UserError, string[]]&gt;
</code></pre>
<h3 id="serialize-37"><a class="header" href="#serialize-37"><code>serialize</code></a></h3>
<p>Serialize a <code>UplcProgram</code> using flat encoding. Returns the JSON representation of the program (needed by <em>cardano-cli</em>).</p>
<pre><code class="language-ts">uplcProgram.serialize(): string
</code></pre>
<h3 id="serializebytes"><a class="header" href="#serializebytes"><code>serializeBytes</code></a></h3>
<p>Serialize a <code>UplcProgram</code> using flat encoding. Returns a list of bytes.</p>
<pre><code class="language-ts">uplcProgram.serializeBytes(): number[]
</code></pre>
<h3 id="tocbor-11"><a class="header" href="#tocbor-11"><code>toCbor</code></a></h3>
<p>Serialize a <code>UplcProgram</code> using CBOR (wraps the flat encoded program).</p>
<pre><code class="language-ts">uplcProgram.toCbor(): number[]
</code></pre>
<h3 id="transfer"><a class="header" href="#transfer"><code>transfer</code></a></h3>
<p>Transfers a <code>UplcProgram</code> from an old version of Helios to a new version of Helios, keeping the script hash the same.</p>
<p>The main benefit of calling this method instead of serializing/deserializing is that the code mapping is maintained.</p>
<pre><code class="language-ts">import { UplcProgram } from &quot;&lt;new-verion-of-helios&gt;&quot;

uplcProgram.transfer(UplcProgram): UplcProgram
</code></pre>
<p>See the <a href="api/reference/../../integrations/different-versions.html"><em>different versions of Helios</em></a> page to learn of how to install a second version of Helios alongside the version of Helios you want to use to compile on-chain code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uplcstring"><a class="header" href="#uplcstring"><code>UplcString</code></a></h1>
<p>Primitive string value. Not needed to interact with Helios smart contracts, but can be used to interact with smart contracts written in other languages (eg. Plutarch).</p>
<h2 id="static-methods-28"><a class="header" href="#static-methods-28">Static methods</a></h2>
<h3 id="new-23"><a class="header" href="#new-23"><code>new</code></a></h3>
<p>Constructs a <code>UplcString</code> instance.</p>
<pre><code class="language-ts">helios.UplcString.new(value: string): helios.UplcString
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uplcunit"><a class="header" href="#uplcunit"><code>UplcUnit</code></a></h1>
<p>Primitive unit value. Not needed to interact with Helios smart contracts, but can be used to interact with smart contracts written in other languages (eg. Plutarch).</p>
<h2 id="static-methods-29"><a class="header" href="#static-methods-29">Static methods</a></h2>
<h3 id="new-24"><a class="header" href="#new-24"><code>new</code></a></h3>
<p>Constructs a <code>UplcUnit</code> instance.</p>
<pre><code class="language-ts">helios.UplcUnit.new(): helios.UplcUnit
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uplcvalue"><a class="header" href="#uplcvalue"><code>UplcValue</code></a></h1>
<p>Parent class of every internal Helios value:</p>
<ul>
<li><a href="api/reference/./uplcbool.html"><code>UplcBool</code></a></li>
<li><a href="api/reference/./uplcbytearray.html"><code>UplcByteArray</code></a></li>
<li><a href="api/reference/./uplcdatavalue.html"><code>UplcDataValue</code></a></li>
<li><a href="api/reference/./uplcint.html"><code>UplcInt</code></a></li>
<li><a href="api/reference/./uplcpair.html"><code>UplcPair</code></a></li>
<li><a href="api/reference/./uplcstring.html"><code>UplcString</code></a></li>
<li><a href="api/reference/./uplcunit.html"><code>UplcUnit</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usererror"><a class="header" href="#usererror"><code>UserError</code></a></h1>
<p>Represents an error thrown when there is a mistake in a Helios source.</p>
<h2 id="getters-41"><a class="header" href="#getters-41">Getters</a></h2>
<h3 id="message"><a class="header" href="#message"><code>message</code></a></h3>
<p>Gets the error message.</p>
<pre><code class="language-ts">user_error.message: string
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="utxo"><a class="header" href="#utxo"><code>UTxO</code></a></h1>
<p><em>Unspent Transaction Output</em> that can be used as an input to when builing a transaction. <code>UTxO</code> instances are also returned when interfacing with <a href="api/reference/./wallet.html#utxos"><code>Wallet</code></a>.</p>
<h2 id="constructor-19"><a class="header" href="#constructor-19">Constructor</a></h2>
<pre><code class="language-ts">new helios.UTxO(
    txId: helios.TxId,
    utxoIdx: bigint,
    origOutput: helios.TxOutput
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validatorhash-3"><a class="header" href="#validatorhash-3"><code>ValidatorHash</code></a></h1>
<p>Represents a blake2b-224 hash of a spending validator script (first encoded as a CBOR byte-array and prepended by a script version byte).</p>
<h2 id="static-methods-30"><a class="header" href="#static-methods-30">Static methods</a></h2>
<h3 id="fromcbor-21"><a class="header" href="#fromcbor-21"><code>fromCbor</code></a></h3>
<p>Deserialize a CBOR encoded <code>ValidatorHash</code>.</p>
<p>Mutates <code>bytes</code> and shifts it to the next CBOR element.</p>
<pre><code class="language-ts">helios.ValidatorHash.fromCbor(bytes: number[]): helios.ValidatorHash
</code></pre>
<h3 id="fromhex-8"><a class="header" href="#fromhex-8"><code>fromHex</code></a></h3>
<p>Construct a <code>ValidatorHash</code> from the hexadecimal string representation of the underlying bytes.</p>
<pre><code class="language-ts">helios.ValidatorHash.fromHex(hex: string): helios.ValidatorHash
</code></pre>
<h2 id="getters-42"><a class="header" href="#getters-42">Getters</a></h2>
<h3 id="bytes-8"><a class="header" href="#bytes-8"><code>bytes</code></a></h3>
<p>Get the underlying bytes.</p>
<pre><code class="language-ts">validator_hash.bytes: number[]
</code></pre>
<h3 id="hex-6"><a class="header" href="#hex-6"><code>hex</code></a></h3>
<p>Returns the hexadecimal representation of the underlying bytes.</p>
<pre><code class="language-ts">validator_hash.hex: string
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="value-4"><a class="header" href="#value-4"><code>Value</code></a></h1>
<p>Represents a collection of tokens.</p>
<h2 id="constructor-20"><a class="header" href="#constructor-20">Constructor</a></h2>
<p>Constructs a <code>Value</code> instance using a quantity of lovelace and an <a href="api/reference/./assets.html"><code>Assets</code></a> instance.</p>
<pre><code class="language-ts">new helios.Value(
    lovelace: bigint = 0n,
    assets: helios.Assets = new helios.Assets()
)
</code></pre>
<h2 id="static-methods-31"><a class="header" href="#static-methods-31">Static methods</a></h2>
<h3 id="fromcbor-22"><a class="header" href="#fromcbor-22"><code>fromCbor</code></a></h3>
<p>Deserialize a CBOR encoded <code>Value</code> instance.</p>
<p>Shifts <code>bytes</code> to the next CBOR element.</p>
<pre><code class="language-ts">helios.Value.fromCbor(bytes: number[]): helios.Value
</code></pre>
<h3 id="fromdata"><a class="header" href="#fromdata"><code>fromData</code></a></h3>
<p>Turns a <a href="api/reference/./uplcdata.html"><code>UplcData</code></a> instance into a <code>Value</code>. Throws an error if it isn't in the right format.</p>
<pre><code class="language-ts">helios.Value.fromData(data: helios.UplcData): helios.Value
</code></pre>
<h2 id="getters-43"><a class="header" href="#getters-43">Getters</a></h2>
<h3 id="assets-1"><a class="header" href="#assets-1"><code>assets</code></a></h3>
<p>Gets the <code>Assets</code> contained in the <code>Value</code>.</p>
<pre><code class="language-ts">value.assets: helios.Assets
</code></pre>
<h3 id="lovelace-1"><a class="header" href="#lovelace-1"><code>lovelace</code></a></h3>
<p>Gets the lovelace quantity contained in the <code>Value</code>.</p>
<pre><code class="language-ts">value.lovelace: bigint
</code></pre>
<h2 id="methods-58"><a class="header" href="#methods-58">Methods</a></h2>
<h3 id="add"><a class="header" href="#add"><code>add</code></a></h3>
<p>Adds two <code>Value</code> instances together. Returns a new <code>Value</code> instance.</p>
<pre><code class="language-ts">value1.add(value2: helios.Value): helios.Value
</code></pre>
<h3 id="assertallpositive"><a class="header" href="#assertallpositive"><code>assertAllPositive</code></a></h3>
<p>Throws an error if any of the <code>Value</code> entries is negative.</p>
<pre><code class="language-ts">value.assertAllPositive(): void
</code></pre>
<h3 id="eq"><a class="header" href="#eq"><code>eq</code></a></h3>
<p>Checks if two <code>Value</code> instances are equal (<code>Assets</code> need to be in the same order).</p>
<pre><code class="language-ts">value1.eq(value2: helios.Value): boolean
</code></pre>
<h3 id="ge"><a class="header" href="#ge"><code>ge</code></a></h3>
<p>Checks if a <code>Value</code> instance is strictly greater or equal to another <code>Value</code> instance.</p>
<pre><code class="language-ts">value1.ge(value2: helios.Value): boolean
</code></pre>
<h3 id="gt"><a class="header" href="#gt"><code>gt</code></a></h3>
<p>Checks if a <code>Value</code> instance is strictly greater than another <code>Value</code> instance.</p>
<pre><code class="language-ts">value1.gt(value2: helios.Value): boolean
</code></pre>
<h3 id="sub"><a class="header" href="#sub"><code>sub</code></a></h3>
<p>Substracts one <code>Value</code> instance from another. Returns a new <code>Value</code> instance.</p>
<pre><code class="language-ts">value1.sub(value2: helios.Value): helios.Value
</code></pre>
<h3 id="setlovelace"><a class="header" href="#setlovelace"><code>setLovelace</code></a></h3>
<p>Mutates the quantity of lovelace in a <code>Value</code>.</p>
<pre><code class="language-ts">value.setLovelace(lovelace: bigint): void
</code></pre>
<h3 id="tocbor-12"><a class="header" href="#tocbor-12"><code>toCbor</code></a></h3>
<p>Serialize a <code>Value</code> instance using CBOR.</p>
<pre><code class="language-ts">value.toCbor(): number[]
</code></pre>
<h3 id="todata"><a class="header" href="#todata"><code>toData</code></a></h3>
<p>Returns a <a href="api/reference/./mapdata.html"><code>MapData</code></a> representation of a <code>Value</code>.</p>
<pre><code class="language-ts">value.toData(): helios.MapData
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wallet"><a class="header" href="#wallet"><code>Wallet</code></a></h1>
<p>An interface type for a wallet that manages a user's UTxOs and addresses. Notably implemented by <a href="api/reference/./cip30wallet.html"><code>Cip30Wallet</code></a> and <a href="api/reference/./walletemulator.html"><code>WalletEmulator</code></a>.</p>
<h2 id="getters-44"><a class="header" href="#getters-44">Getters</a></h2>
<h3 id="usedaddresses-1"><a class="header" href="#usedaddresses-1"><code>usedAddresses</code></a></h3>
<p>Gets a list of addresses which already contain UTxOs.</p>
<pre><code class="language-ts">wallet.usedAddresses: Promise&lt;helios.Address[]&gt;
</code></pre>
<h3 id="unusedaddresses-1"><a class="header" href="#unusedaddresses-1"><code>unusedAddresses</code></a></h3>
<p>Gets a list of unique unused addresses which can be used to send UTxOs to.</p>
<pre><code class="language-ts">wallet.unusedAddresses: Promise&lt;helios.Address[]&gt;
</code></pre>
<h3 id="utxos-1"><a class="header" href="#utxos-1"><code>utxos</code></a></h3>
<p>Gets the complete list of <a href="api/reference/./utxo.html"><code>UTxO</code>s</a> sitting at the addresses owned by the wallet.</p>
<pre><code class="language-ts">wallet.utxos: Promise&lt;helios.UTxO[]&gt;
</code></pre>
<h2 id="methods-59"><a class="header" href="#methods-59">Methods</a></h2>
<h3 id="ismainnet-1"><a class="header" href="#ismainnet-1"><code>isMainnet</code></a></h3>
<p>Returns <code>true</code> if the wallet is connected to the mainnet.</p>
<pre><code class="language-ts">wallet.isMainnet(): Promise&lt;boolean&gt;
</code></pre>
<h3 id="signtx-1"><a class="header" href="#signtx-1"><code>signTx</code></a></h3>
<p>Signs a <a href="api/reference/./tx.html">transaction</a>, returning a list of signatures needed for submitting a valid transaction.</p>
<pre><code class="language-ts">wallet.signTx(tx: helios.Tx): Promise&lt;helios.Signature[]&gt;
</code></pre>
<h3 id="submittx-4"><a class="header" href="#submittx-4"><code>submitTx</code></a></h3>
<p>Submits a <a href="api/reference/./tx.html">transaction</a> to the blockchain. Returns the <a href="api/reference/./txid.html"><code>TxId</code></a>.</p>
<pre><code class="language-ts">wallet.submitTx(tx: helios.Tx): Promise&lt;helios.TxId&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="walletemulator"><a class="header" href="#walletemulator"><code>WalletEmulator</code></a></h1>
<p>An emulated <a href="api/reference/./wallet.html"><code>Wallet</code></a>, created by calling <a href="api/reference/./networkemulator.html#createwallet"><code>emulator.createWallet()</code></a>.</p>
<p>This wallet only has a single private/public key, which isn't rotated. Staking is not yet supported.</p>
<h2 id="getters-45"><a class="header" href="#getters-45">Getters</a></h2>
<h3 id="address-5"><a class="header" href="#address-5"><code>address</code></a></h3>
<p>Gets the <a href="api/reference/./address.html"><code>Address</code></a> of the wallet.</p>
<pre><code class="language-ts">wallet.address: helios.Address
</code></pre>
<h3 id="pubkeyhash-3"><a class="header" href="#pubkeyhash-3"><code>pubKeyHash</code></a></h3>
<p>Gets the <a href="api/reference/./pubkeyhash.html"><code>PubKeyHash</code></a> of the wallet.</p>
<pre><code class="language-ts">wallet.pubKeyHash: helios.PubKeyHash
</code></pre>
<h2 id="usedaddresses-2"><a class="header" href="#usedaddresses-2"><code>usedAddresses</code></a></h2>
<p>A list containing the emulated wallet's single address.</p>
<pre><code class="language-ts">wallet.usedAddresses: Promise&lt;helios.Address[]&gt;
</code></pre>
<h3 id="unusedaddresses-2"><a class="header" href="#unusedaddresses-2"><code>unusedAddresses</code></a></h3>
<p>Returns an empty list in this case.</p>
<pre><code class="language-ts">wallet.unusedAddresses: Promise&lt;helios.Address[]&gt;
</code></pre>
<h3 id="utxos-2"><a class="header" href="#utxos-2"><code>utxos</code></a></h3>
<p>Gets all the <a href="api/reference/./utxo.html"><code>UTxO</code>s</a> controlled by the emulated wallet.</p>
<pre><code class="language-ts">wallet.utxos: Promise&lt;helios.UTxO[]&gt;
</code></pre>
<h2 id="methods-60"><a class="header" href="#methods-60">Methods</a></h2>
<h3 id="ismainnet-2"><a class="header" href="#ismainnet-2"><code>isMainnet</code></a></h3>
<p>Returns <code>false</code> in this case.</p>
<pre><code class="language-ts">wallet.isMainnet(): Promise&lt;boolean&gt;
</code></pre>
<h3 id="signtx-2"><a class="header" href="#signtx-2"><code>signTx</code></a></h3>
<p>Signs a <a href="api/reference/./tx.html">transaction</a>, returning a list containing the single signature needed for submitting it.</p>
<pre><code class="language-ts">wallet.signTx(tx: helios.Tx): Promise&lt;helios.Signature[]&gt;
</code></pre>
<h3 id="submittx-5"><a class="header" href="#submittx-5"><code>submitTx</code></a></h3>
<p>Submits a <a href="api/reference/./tx.html">transaction</a> to the emulated blockchain. Returns the <a href="api/reference/./txid.html"><code>TxId</code></a>.</p>
<pre><code class="language-ts">wallet.submitTx(tx: helios.Tx): Promise&lt;helios.TxId&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wallethelper"><a class="header" href="#wallethelper"><code>WalletHelper</code></a></h1>
<p>High-level helper class for instances that implement the <a href="api/reference/./wallet.html"><code>Wallet</code></a> interface.</p>
<h2 id="constructor-21"><a class="header" href="#constructor-21">Constructor</a></h2>
<pre><code class="language-ts">const helper = new helios.WalletHelper(wallet: helios.Wallet)
</code></pre>
<h2 id="getters-46"><a class="header" href="#getters-46">Getters</a></h2>
<h3 id="alladdresses"><a class="header" href="#alladdresses"><code>allAddresses</code></a></h3>
<p>Concatenation of <a href="api/reference/./wallet.html#usedaddresses"><code>usedAddresses</code></a> and <a href="api/reference/./wallet.html#unusedaddresses"><code>unusedAddresses</code></a>.</p>
<pre><code class="language-ts">helper.allAddresses: Promise&lt;helios.Address[]&gt;
</code></pre>
<h3 id="baseaddress"><a class="header" href="#baseaddress"><code>baseAddress</code></a></h3>
<p>First <a href="api/reference/./address.html"><code>Address</code></a> in <a href="api/reference/wallethelper.html#alladdresses"><code>allAddresses</code></a>.</p>
<pre><code class="language-ts">helper.baseAddress: Promise&lt;helios.Address&gt;
</code></pre>
<h3 id="changeaddress"><a class="header" href="#changeaddress"><code>changeAddress</code></a></h3>
<p>First <a href="api/reference/./address.html"><code>Address</code></a> in <a href="api/reference/./wallet.html#unusedaddresses"><code>unusedAddresses</code></a>.</p>
<pre><code class="language-ts">helper.changeAddress: Promise&lt;helios.Address&gt;
</code></pre>
<h3 id="refutxo"><a class="header" href="#refutxo"><code>refUtxo</code></a></h3>
<p>First <a href="api/reference/./utxo.html"><code>UTxO</code></a> in <a href="api/reference/./wallet.html#utxos"><code>utxos</code></a>. Can be used to distinguish between preview and preprod networks.</p>
<pre><code class="language-ts">helper.refUtxo: Promise&lt;helios.UTxO&gt;
</code></pre>
<h2 id="methods-61"><a class="header" href="#methods-61">Methods</a></h2>
<h3 id="isownaddress"><a class="header" href="#isownaddress"><code>isOwnAddress</code></a></h3>
<p>Returns <code>true</code> if the <a href="api/reference/./pubkeyhash.html"><code>PubKeyHash</code></a> in the given <a href="api/reference/./address.html"><code>Address</code></a> is controlled by the wallet.</p>
<pre><code class="language-ts">helper.isOwnAddress(address: helios.Address): boolean
</code></pre>
<h3 id="isownpubkeyhash"><a class="header" href="#isownpubkeyhash"><code>isOwnPubKeyHash</code></a></h3>
<p>Returns <code>true</code> if the given<a href="api/reference/./pubkeyhash.html"><code>PubKeyHash</code></a> is controlled by the wallet.</p>
<pre><code class="language-ts">helper.isOwnPubKeyHash(pkh: helios.PubKeyHash): boolean
</code></pre>
<h3 id="pickutxos"><a class="header" href="#pickutxos"><code>pickUtxos</code></a></h3>
<p>Pick a number of <a href="api/reference/./utxo.html"><code>UTxO</code>s</a> needed to cover a given <a href="api/reference/./value.html"><code>Value</code></a>. The coin selection strategy is to pick the smallest first (WiP). </p>
<p>Returns two lists. The first list contains the selected UTxOs, the second list contains the remaining UTxOs.</p>
<pre><code class="language-ts">helper.pickUtxos(amount: helios.Value): Promise&lt;[helios.UTxO[], helios.UTxO[]]&gt;
</code></pre>
<h3 id="pickcollateral"><a class="header" href="#pickcollateral"><code>pickCollateral</code></a></h3>
<p>Picks a single <a href="api/reference/./utxo.html"><code>UTxO</code></a> intended for collateral.</p>
<pre><code class="language-ts">helper.pickCollateral(amount: bigint = 2000000n): Promise&lt;helios.UTxO&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="helios-cli"><a class="header" href="#helios-cli">Helios CLI</a></h1>
<p>This chapter explains how to use the <a href="https://github.com/Hyperion-BT/helios-cli"><em>helios-cli</em></a>, and how to build and submit transactions using <em>cardano-cli</em>.</p>
<blockquote>
<p><strong>Note</strong>: <em>helios-cli</em> is work-in-progress and can only be used for simple operations (compiling, evaluating parameters, calculating script addresses).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>This section explains how to:</p>
<ul>
<li><a href="cli/./install.html">install <em>helios-cli</em></a></li>
<li><a href="cli/./cardano-node.html">install <em>cardano-node</em></a></li>
<li><a href="cli/./wallet.html">create a wallet using <em>cardano-cli</em></a></li>
</ul>
<p>These steps require the following dependencies:</p>
<ul>
<li><em>node</em></li>
<li><em>npm</em></li>
<li><em>docker</em></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-helios-cli"><a class="header" href="#install-helios-cli">Install <em>helios-cli</em></a></h1>
<p>Dependencies:</p>
<ul>
<li><em>node</em></li>
<li><em>npm</em></li>
</ul>
<p>Install using <em>npm</em>:</p>
<pre><code class="language-bash">$ sudo npm install -g @hyperionbt/helios-cli
</code></pre>
<p>Verify the installation using the following command:</p>
<pre><code class="language-bash">$ helios version
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-cardano-node"><a class="header" href="#install-cardano-node">Install <em>cardano-node</em></a></h1>
<p>You will need a Linux environment with <em>docker</em> for this. </p>
<p>We have provided convenient docker containers for running <em>cardano-node</em>.</p>
<pre><code class="language-bash">$ git clone https://github.com/Hyperion-BT/cardano-node-wrappers
$ cd cardano-node-wrappers
</code></pre>
<p>Build and start a <em>cardano-node</em> docker container (non-persistent):</p>
<pre><code class="language-bash">$ make build-preprod

$ make run-preprod # non-persistent, just to check if it works
</code></pre>
<p>Or persistent:</p>
<pre><code class="language-bash">$ make run-preprod-persistent # runs in background with a persistent data volume
</code></pre>
<p>Alternative you can choose <code>preview</code>.</p>
<p>These commands will automatically download IOG's latest <em>cardano-node</em> image, and then create a named docker volume for storing the blockchain state.</p>
<p>Check that the <em>cardano-node</em> container is running using the following command:</p>
<pre><code class="language-bash">$ docker ps
</code></pre>
<p>Take note of the container id.</p>
<p>You can stop the container any time:</p>
<pre><code class="language-bash">$ docker stop &lt;container-id&gt;
</code></pre>
<p>We recommend using <code>docker stop</code> and not <code>docker rm -f</code> as it allows <em>cardano-node</em> processes to receive the more graceful <code>SIGTERM</code> signal (instead of just <code>SIGKILL</code>).</p>
<p>You can clean up stopped containers if you are running low on system resources:</p>
<pre><code class="language-bash">$ docker system prune
</code></pre>
<p>About 30 seconds after starting the <em>cardano-node</em> container, <code>/ipc/node.socket</code> should've been created and you can start using <code>cardano-cli</code> to query the blockchain. If you are restarting the <em>cardano-node</em> after a major upgrade (eg. an HFC) it could take much longer though (an hour or more). If you are impatient you should launch the <em>cardano-node</em> container using the docker <code>run</code> command without the <code>-d</code> flag. This way you can follow the (re)sync progress in your terminal.</p>
<p>Poll for the blockchain sync status using the following command:</p>
<pre><code class="language-bash">$ docker exec &lt;container-id&gt; cardano-cli query tip --testnet-magic 1097911063
</code></pre>
<p>The first time it can take up to 10 hours for your <em>cardano-node</em> to fully synchronize.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wallet-setup"><a class="header" href="#wallet-setup">Wallet setup</a></h1>
<p>Start an interactive shell in your <em>cardano-node</em> docker container:</p>
<pre><code class="language-bash">$ docker exec -it &lt;container-id&gt; bash
</code></pre>
<p>Create the directory where we will store the wallet keys:</p>
<pre><code class="language-bash">&gt; mkdir -p /data/wallets
</code></pre>
<p>Create three wallets, each with an associated payment address:</p>
<pre><code class="language-bash">&gt; cd /data/wallets

&gt; cardano-cli address key-gen \
  --verification-key-file wallet1.vkey \
  --signing-key-file wallet1.skey
&gt; cardano-cli address build \
  --payment-verification-key-file wallet1.vkey \
  --out-file wallet1.addr \
  --testnet-magic $TESTNET_MAGIC_NUM
&gt; cat wallet1.addr

addr_test1vqwj9w0...

&gt; cardano-cli address key-gen \
  --verification-key-file wallet2.vkey \
  --signing-key-file wallet2.skey
&gt; cardano-cli address build \
  --payment-verification-key-file wallet2.vkey \
  --out-file wallet2.addr \
  --testnet-magic $TESTNET_MAGIC_NUM

&gt; cardano-cli address key-gen \
  --verification-key-file wallet3.vkey \
  --signing-key-file wallet3.skey
&gt; cardano-cli address build \
  --payment-verification-key-file wallet3.vkey \
  --out-file wallet3.addr \
  --testnet-magic $TESTNET_MAGIC_NUM
</code></pre>
<p>Take note of the payment address of wallet 1.</p>
<h2 id="funding"><a class="header" href="#funding">Funding</a></h2>
<p>Go to <a href="https://testnets.cardano.org/en/testnets/cardano/tools/faucet/">testnets.cardano.org/en/testnets/cardano/tools/faucet/</a> to add some funds.</p>
<p>After adding some funds, check the balance of the wallet 1's payment address:</p>
<pre><code class="language-bash">&gt; cardano-cli query utxo \
  --address $(cat /data/wallets/wallet1.addr) \
  --testnet-magic $TESTNET_MAGIC_NUM

...
</code></pre>
<p>The funding faucet is limited to one usage per day per user. So try to fund wallets 2 and 3 on other days.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-helios-cli"><a class="header" href="#using-helios-cli">Using <em>helios-cli</em></a></h1>
<h2 id="compiling"><a class="header" href="#compiling">Compiling</a></h2>
<pre><code class="language-bash">$ helios compile my_script.hl -o my_script.json
</code></pre>
<p>Optimization can be switched on using the <code>--optimize</code> (or <code>-O</code>) flag:</p>
<pre><code class="language-bash">$ helios compile my_script.hl --optimize -o my_script.json
</code></pre>
<p><em>helios-cli</em> automatically searches for <a href="cli/../lang/modules.html">modules</a> in the current directory. Other directories can be included using the <code>-I</code> option:</p>
<pre><code class="language-bash">$ helios compile my_script.hl -I ./my_modules/ -o my_script.json
</code></pre>
<p><a href="cli/../lang/parameterized.html">Parameters</a> can be set using the <code>-D&lt;param-name&gt; &lt;param-value&gt;</code> option:</p>
<pre><code class="language-bash">$ helios compile my_script.hl -DMY_PARAM 100 -o my_script.json
</code></pre>
<h2 id="evaluating-a-parameter"><a class="header" href="#evaluating-a-parameter">Evaluating a parameter</a></h2>
<pre><code class="language-bash">$ helios eval my_script.hl MY_PARAM
</code></pre>
<p>Similar to the <code>compile</code> command, additional module directories can be included using <code>-I</code>.</p>
<h2 id="calculating-a-script-address"><a class="header" href="#calculating-a-script-address">Calculating a script address</a></h2>
<p><em>helios-cli</em> can calculate the address of a compiled script:</p>
<pre><code class="language-bash">$ helios address my_script.json
</code></pre>
<p>For mainnet address the <code>--mainnet</code> (or <code>-m</code>) flag must be used:</p>
<pre><code class="language-bash">$ helios address my_script --mainnet
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-always-succeeds"><a class="header" href="#example-always-succeeds">Example: Always succeeds</a></h1>
<p>Create a <code>always_succeeds.hl</code> script with the following code:</p>
<pre><code class="language-helios">spending always_succeeds

func main(_, _, _) -&gt; Bool {
  true
}
</code></pre>
<p>Compile the Always Succeeds script into its JSON representation:</p>
<pre><code>$ helios compile always_succeeds.hl

{&quot;type&quot;: &quot;PlutusScriptV2&quot;, &quot;description&quot;: &quot;&quot;, &quot;cborHex&quot; :&quot;52510100003222253335734a0082930b0a5101&quot;}
</code></pre>
<p>Start an interactive shell in the <em>cardano-node</em> container and copy the content of the JSON representing the script:</p>
<pre><code>$ docker exec -it &lt;container-id&gt; bash

&gt; mkdir -p /data/scripts
&gt; cd /data/scripts

&gt; echo '{
  &quot;type&quot;: &quot;PlutusScriptV2&quot;, 
  &quot;description&quot;: &quot;&quot;, 
  &quot;cborHex&quot;: &quot;52510100003222253335734a0082930b0a5101&quot;
}' &gt; always-succeeds.json

</code></pre>
<p>Generate the script address:</p>
<pre><code>&gt; cardano-cli address build \
  --payment-script-file /data/scripts/always-succeeds.json \
  --out-file /data/scripts/always-succeeds.addr \
  --testnet-magic $TESTNET_MAGIC_NUM

&gt; cat /data/scripts/always-succeeds.addr

addr_test1wpfvdtcvnd6yknhve6pc2w999n4325pck00x3c4m9750cdch6csfq
</code></pre>
<p>We need a datum, which can be chosen arbitrarily in this case:</p>
<pre><code>&gt; DATUM_HASH=$(cardano-cli transaction hash-script-data --script-data-value &quot;42&quot;)
&gt; echo $DATUM_HASH

9e1199a988ba72ffd6e9c269cadb3b53b5f360ff99f112d9b2ee30c4d74ad88b
</code></pre>
<p>We also need to select some UTxOs as inputs to the transaction. At this point we should have one UTxO sitting in wallet 1. We can query this using the following command:</p>
<pre><code>&gt; cardano-cli query utxo \
  --address $(cat /data/wallets/wallet1.addr) \
  --testnet-magic $TESTNET_MAGIC_NUM

TxHash             TxIx  Amount
-------------------------------------------------------------
4f3d0716b07d75...  0     1000000000 lovelace + TxOutDatumNone
</code></pre>
<p><code>4f3d...</code> is the transaction id. The UTxO id in this case is <code>4f3d...#0</code>.</p>
<p>We now have everything we need to build a transaction and submit it.</p>
<p>Let's send 2 tAda (2 million lovelace) to the script address:</p>
<pre><code>&gt; TX_BODY=$(mktemp)
&gt; cardano-cli transaction build \
  --tx-in 4f3d...#0 \
  --tx-out $(cat /data/scripts/always-succeeds.addr)+2000000 \
  --tx-out-datum-hash $DATUM_HASH \
  --change-address $(cat /data/wallets/wallet1.addr) \
  --testnet-magic $TESTNET_MAGIC_NUM \
  --out-file $TX_BODY \
  --babbage-era

Estimated transaction fee: Lovelace 167217

&gt; TX_SIGNED=$(mktemp)
&gt; cardano-cli transaction sign \
  --tx-body-file $TX_BODY \
  --signing-key-file /data/wallets/wallet1.skey \
  --testnet-magic $TESTNET_MAGIC_NUM \
  --out-file $TX_SIGNED

&gt; cardano-cli transaction submit \
  --tx-file $TX_SIGNED \
  --testnet-magic $TESTNET_MAGIC_NUM

Transaction successfully submitted
</code></pre>
<p>If you check the wallet 1 payment address balance after a few minutes you will noticed that it has decreased by 2 tAda + fee. Note the left-over UTxO id, we will need it to pay fees when retrieving funds.</p>
<p>You can also try to check the balance of the script address:</p>
<pre><code>&gt; cardano-cli query utxo \
  --address $(cat /data/scripts/always-succeeds.addr) \
  --testnet-magic $TESTNET_MAGIC_NUM

...
</code></pre>
<p>The table should list at least one UTxO with your specific datum hash.</p>
<p>We can now try and get our funds back from the script by building, signing and submitting another transaction:</p>
<pre><code>&gt; PARAMS=$(mktemp) # most recent protocol parameters
&gt; cardano-cli query protocol-parameters --testnet-magic $TESTNET_MAGIC_NUM &gt; $PARAMS

&gt; TX_BODY=$(mktemp)
&gt; cardano-cli transaction build \
  --tx-in &lt;fee-utxo&gt; \ # used for tx fee
  --tx-in &lt;script-utxo&gt; \
  --tx-in-datum-value &quot;42&quot; \
  --tx-in-redeemer-value &lt;arbitrary-redeemer-data&gt; \
  --tx-in-script-file /data/scripts/always-succeeds.json \
  --tx-in-collateral &lt;fee-utxo&gt; \ # used for script collateral
  --change-address $(cat /data/wallets/wallet1.addr) \
  --tx-out $(cat /data/wallets/wallet1.addr)+2000000 \
  --out-file $TX_BODY \
  --testnet-magic $TESTNET_MAGIC_NUM \
  --protocol-params-file $PARAMS \
  --babbage-era

Estimated transaction fee: Lovelace 178405

&gt; TX_SIGNED=$(mktemp)
&gt; cardano-cli transaction sign \
  --tx-body-file $TX_BODY \
  --signing-key-file /data/wallets/wallet1.skey \
  --testnet-magic $TESTNET_MAGIC_NUM \
  --out-file $TX_SIGNED

&gt; cardano-cli transaction submit \
  --tx-file $TX_SIGNED \
  --testnet-magic $TESTNET_MAGIC_NUM

Transaction successfully submitted
</code></pre>
<p>If you now check the balance of wallet 1 you should see two UTxOs, and the total value should be your starting value minus the two fees you paid. </p>
<p>Note that <em>collateral</em> is only paid if you submit a bad script. Cardano-cli does extensive checking of your script though, and should prevent you from submitting anything faulty. So <em>collateral</em> is only really paid by malicious users.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-time-lock"><a class="header" href="#example-time-lock">Example: Time lock</a></h1>
<p>The <em>always-succeeds</em> contract in the <a href="cli/./example-always-succeeds.html">previous section</a> isn't very useful. Something that is still simple, but has real-world applications, is a <em>time-lock</em> contract. Actors send UTxOs to the <em>time-lock</em> address with a datum that contains a <em>lock-until</em> time. An optional nonce can be included in the datum to allow only the actors who know the nonce value to retrieve the UTxOs. The wallet from which the original UTxOs were sent is also able to retrieve the UTxOs at any time.</p>
<p>The Helios script:</p>
<pre><code class="language-helios">spending time_lock

struct Datum {
    lockUntil: Time
    owner:     PubKeyHash // can't get this info from the ScriptContext
    nonce:     Int
}

func main(datum: Datum, _, ctx: ScriptContext) -&gt; Bool {
    tx: Tx = ctx.tx;
    now: Time = tx.time_range.start;
    returnToOwner: Bool = tx.is_signed_by(datum.owner);

    (now &gt; datum.lockUntil) || returnToOwner
}
// end-of-main, anything that comes after isn't part of the on-chain script

// MY_DATUM parameters
const LOCK_UNTIL = 0 // seconds since 1970, set by cli
const OWNER = PubKeyHash::new(#) // set by cli
const NONCE = 42 // can be set by cli

// Helios can evaluate MY_DATUM into a data-structure that can be used to build a transaction
const MY_DATUM = Datum{
  lockUntil: Time::new(LOCK_UNTIL*1000),  // needs to be in milliseconds
  owner:     OWNER, 
  nonce:     NONCE
}
</code></pre>
<p>UTxOs can be sent into the time-lock script arbitrarily as long as the datum has the correct format. UTxOs can be retrieved any time by the wallet that initiated the time-lock. UTxOs can be retrieved after the time-lock by anyone who knows the datum.</p>
<p>Once we have written the script, we generate its JSON representation using <em>helios-cli</em>, and then calculate the script address using cardano-cli:</p>
<pre><code>$ helios compile time_lock.hl

{&quot;type&quot;: &quot;PlutusScriptV2&quot;, &quot;description&quot;: &quot;&quot;, &quot;cborHex&quot;: &quot;5...&quot;}
</code></pre>
<pre><code>$ docker exec -it &lt;container-id&gt; bash

&gt; echo '{
  &quot;type&quot;: &quot;PlutusScriptV1&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;cborHex&quot;: &quot;5...&quot;,
}' &gt; /data/scripts/time-lock.json

&gt; cardano-cli address build \
  --payment-script-file /data/scripts/time-lock.json \
  --out-file /data/scripts/time-lock.addr \
  --testnet-magic $TESTNET_MAGIC_NUM

&gt; cat time-lock.addr

addr_test1...
</code></pre>
<p>For the datum we need the <code>PubKeyHash</code> of the initiating wallet (i.e. the owner):</p>
<pre><code>$ docker exec -it &lt;container-id&gt; bash

&gt; cardano-cli address key-hash --payment-verification-key-file /data/wallets/wallet1.vkey

1d22b9ff5fc...
</code></pre>
<p>We also need a <code>lockUntil</code> time, for example 5 minutes from now. Now we can build the datum:</p>
<pre><code>$ helios eval time_lock.hl MY_DATUM \
  -DOWNER &quot;000102030405060708090a0b0c0d0e0f101112131415161718191a1b&quot; \
  -DLOCK_UNTIL $(($(date +%s) + 300)) \
  -DNONCE 12345

{&quot;constructor&quot;: 0, &quot;fields&quot;: [{&quot;int&quot;: 16....}, {&quot;bytes&quot;: &quot;0001020304...&quot;}, {&quot;int&quot;: 12345}]}
</code></pre>
<p>Now let's send 2 tAda to the script address using the datum we just generated:</p>
<pre><code>$ docker exec -it &lt;container-id&gt; bash

&gt; cardano-cli query utxo \
  --address $(cat /data/wallets/wallet1.addr) \
  --testnet-magic $TESTNET_MAGIC_NUM

...
# take note of a UTxO big enough to cover 2 tAda + fees

&gt; DATUM=$(mktemp)
&gt; echo '{&quot;constructor&quot;: 0, &quot;fields&quot;: [{&quot;int&quot;: 16....}, {&quot;int&quot;: 42}]}' &gt; $DATUM

&gt; DATUM_HASH=$(cardano-cli transaction hash-script-data --script-data-file $DATUM)

&gt; TX_BODY=$(mktemp)
&gt; cardano-cli transaction build \
  --tx-in &lt;funding-utxo&gt; \
  --tx-out $(cat /data/scripts/time-lock.addr)+2000000 \
  --tx-out-datum-hash $DATUM_HASH \
  --change-address $(cat /data/wallets/wallet1.addr) \
  --testnet-magic $TESTNET_MAGIC_NUM \
  --out-file $TX_BODY \
  --babbage-era

Estimated transaction fee: Lovelace 167217

&gt; TX_SIGNED=$(mktemp)
&gt; cardano-cli transaction sign \
  --tx-body-file $TX_BODY \
  --signing-key-file /data/wallets/wallet1.skey \
  --testnet-magic $TESTNET_MAGIC_NUM \
  --out-file $TX_SIGNED

&gt; cardano-cli transaction submit \
  --tx-file $TX_SIGNED \
  --testnet-magic $TESTNET_MAGIC_NUM

Transaction successfully submitted
</code></pre>
<p>Wait for the transaction to propagate through the network, and query the script address to see the locked UTxO(s).</p>
<p>First thing we should test is returning the UTxO(s) back to wallet 1. For that we use the following transaction:</p>
<pre><code>&gt; PARAMS=$(mktemp) # most recent protocol params
&gt; cardano-cli query protocol-parameters --testnet-magic $TESTNET_MAGIC_NUM &gt; $PARAMS

&gt; TX_BODY=$(mktemp)
&gt; cardano-cli transaction build \
  --tx-in &lt;fee-utxo&gt; \ # used for tx fee
  --tx-in &lt;script-utxo \
  --tx-in-datum-file $DATUM \
  --tx-in-redeemer-value &lt;arbitrary-redeemer-data&gt; \
  --tx-in-script-file /data/scripts/time-lock.json \
  --tx-in-collateral &lt;fee-utxo&gt; \ # used for script collateral
  --invalid-before &lt;current-slot-no&gt; \
  --required-signer /data/wallets/wallet1.skey \
  --change-address $(cat /data/wallets/wallet1.addr) \
  --tx-out $(cat /data/wallets/wallet1.addr)+2000000 \
  --out-file $TX_BODY \
  --testnet-magic $TESTNET_MAGIC_NUM \
  --protocol-params-file $PARAMS \
  --babbage-era

Estimated transaction fee: Lovelace ...

&gt; TX_SIGNED=$(mktemp)
&gt; cardano-cli transaction sign \
  --tx-body-file $TX_BODY \
  --signing-key-file /data/wallets/wallet1.skey \
  --testnet-magic $TESTNET_MAGIC_NUM \
  --out-file $TX_SIGNED

&gt; cardano-cli transaction submit \
  --tx-file $TX_SIGNED \
  --testnet-magic $TESTNET_MAGIC_NUM

Transaction successfully submitted
</code></pre>
<p>Note that this transaction <em>build</em> command differs slightly from the <em>Always succeeds</em> script:</p>
<ul>
<li><code>--invalid-before &lt;current-slot-no&gt;</code> is needed so the transaction is aware of the current time (via the start of the valid time-range). It might seem weird to specify (an approximation of) the current time at this point, as someone might try to cheat the time-lock by specifying a time far into the future. But the slot-leader checks the time-range as well, and rejects any transaction whose time-range doesn't contain the current slot.</li>
<li><code>--required-signer &lt;wallet-private-key-file&gt;</code> is needed so that <code>getTxSignatories(tx)</code> doesn't return an empty list.</li>
</ul>
<p>The second thing we must test is claiming the time-locked funds from another wallet (eg. wallet 2). Let's assume that the time-lock script still contains the 2 tAda sent by wallet 1, and that sufficient time has passed. Wallet 2 can claim the UTxO(s) using the following commands:</p>
<pre><code>&gt; PARAMS=$(mktemp) # most recent protocol params
&gt; cardano-cli query protocol-parameters --testnet-magic $TESTNET_MAGIC_NUM &gt; $PARAMS

&gt; TX_BODY=$(mktemp)
&gt; cardano-cli transaction build \
  --tx-in &lt;fee-utxo&gt; \ # used for tx fee
  --tx-in &lt;script-utxo&gt; \
  --tx-in-datum-file $DATUM \
  --tx-in-redeemer-value &lt;arbitrary-redeemer-data&gt; \
  --tx-in-script-file /data/scripts/time-lock.json \
  --tx-in-collateral &lt;fee-utxo&gt; \ # used for script collateral
  --invalid-before &lt;current-slot-no&gt; \
  --change-address $(cat /data/wallets/wallet2.addr) \
  --tx-out $(cat /data/wallets/wallet2.addr)+2000000 \
  --out-file $TX_BODY \
  --testnet-magic $TESTNET_MAGIC_NUM \
  --protocol-params-file $PARAMS \
  --babbage-era

Estimated transaction fee: Lovelace ...

&gt; TX_SIGNED=$(mktemp)
&gt; cardano-cli transaction sign \
  --tx-body-file $TX_BODY \
  --signing-key-file /data/wallets/wallet2.skey \
  --testnet-magic $TESTNET_MAGIC_NUM \
  --out-file $TX_SIGNED

&gt; cardano-cli transaction submit \
  --tx-file $TX_SIGNED \
  --testnet-magic $TESTNET_MAGIC_NUM

Transaction successfully submitted
</code></pre>
<p>cardano-cli should give an error if you try to submit this transaction before the <code>lockUntil</code> time. After that time it should succeed, and wallet 2 will receive the time-locked UTxO(s).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrations"><a class="header" href="#integrations">Integrations</a></h1>
<ul>
<li><a href="integrations/./different-versions.html">Different versions of Helios for on-chain vs. off-chain</a></li>
<li><a href="integrations/./vscode.html">VSCode plugin</a></li>
<li><a href="integrations/./webpack.html">Webpack loader</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="different-versions-of-helios-for-on-chain-vs-off-chain"><a class="header" href="#different-versions-of-helios-for-on-chain-vs-off-chain">Different versions of Helios for on-chain vs. off-chain</a></h1>
<p>If you have already launched your dApp to mainnet, and want to keep using exactly the same script hashes while also benefiting from improvements to the <a href="integrations/../api/index.html">Helios off-chain API</a>, you can install a second version of Helios alongside the version you want to keep using for compiling on-chain code.</p>
<blockquote>
<p><strong>Note</strong>: the <a href="integrations/./webpack.html">Helios Webpack loader</a> requires the version of the library you want to use for compiling on-chain code to be installed as <code>&quot;@hyperionbt/helios&quot;</code></p>
</blockquote>
<p>To install the latest version of Helios alongside the old verion, you must use an alias:</p>
<pre><code>npm install helios-api@npm:@hyperionbt/helios
</code></pre>
<p>Alternatively you can also install a specific version of Helios using an alias:</p>
<pre><code>npm install helios-api@npm:@hyperionbt/helios@^0.13.33
</code></pre>
<p>You can then import this aliased version of Helios in your Javascript/Typescript project:</p>
<pre><code class="language-ts">import { UplcProgram } from &quot;helios-api&quot;

...
</code></pre>
<h2 id="transfering-uplcprogram-instances"><a class="header" href="#transfering-uplcprogram-instances">Transfering <code>UplcProgram</code> instances</a></h2>
<p>In order to properly use an <a href="integrations/../api/reference/uplcprogram.html"><code>UplcProgram</code></a> instance compiled by an older version of Helios you must <em>transfer</em> it (which ensures the script hash stays the same).</p>
<pre><code class="language-ts">// old version of Helios used to compile the contract
import { Program } from &quot;@hyperionbt/helios&quot; 

// newest version of Helios
import { UplcProgram } from &quot;helios-api&quot; 

const src = `spending ...`

const uplcProgram = Program.new(src).compile(true).transfer(UplcProgram)
</code></pre>
<p>The <a href="integrations/../api/reference/uplcprogram.html#transfer"><code>transfer()</code></a> method also transfers the code mapping wrt. the original Helios code.</p>
<p>The <a href="integrations/../api/reference/uplcprogram.html#transfer"><code>transfer()</code></a> method is only available in versions of Helios &gt;= v0.13.32.</p>
<h3 id="older-versions-of-helios"><a class="header" href="#older-versions-of-helios">Older versions of Helios</a></h3>
<p>For versions of Helios &lt;= v0.13.31 <em>transfering</em> can be achieved by serializing/deserializing the <a href="integrations/../api/reference/uplcprogram.html"><code>UplcProgram</code></a> instance.</p>
<pre><code class="language-ts">// old version of Helios used to compile the contract
import { Program } from &quot;@hyperionbt/helios&quot;

// newest version of Helios
import { UplcProgram } from &quot;helios-api&quot;

const src = `spending ...`

const uplcProgram = Program.new(src).compile(true)

const transferedUplcProgram = UplcProgram.fromCbor(uplcProgram.toCbor())
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vscode-plugin"><a class="header" href="#vscode-plugin">VSCode plugin</a></h1>
<p>This plugin can be installed from within VSCode by searching for <em>Helios</em> and picking the plugin with the following caption: <em>Helios language support for VS Code</em>.</p>
<p>Currently this plugin only provides <strong>syntax highlighting</strong> for files ending with the <code>.hl</code> extension.</p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>The Helios IDE plugins repository can be found <a href="https://github.com/hyperion-bt/helios-ide-plugins">on github</a>.</p>
<h2 id="third-party-language-server"><a class="header" href="#third-party-language-server">Third party language server</a></h2>
<p>There is also a third party language server plugin with more advanced features like <strong>auto-complete</strong> (Helios versions &lt;= 0.9 only). This plugin requires separate installation of the <a href="https://pypi.org/project/helios-language-server">python language server</a>. This plugin can be found within VSCode by searching for <em>Helios Language Server</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webpack-loader"><a class="header" href="#webpack-loader">Webpack loader</a></h1>
<p>The Helios <a href="https://www.npmjs.com/package/@hyperionbt/helios-loader">Webpack loader</a> allows importing Helios scripts directly into Javascript/Typescript projects.</p>
<p>Features:</p>
<ul>
<li>Catches Helios syntax and type errors during build time</li>
<li>Working with Helios sources directly allows using <a href="integrations/./vscode.html">Helios IDE plugins</a></li>
<li>Automatically uses your current version of Helios (must be installed manually inside the repo where you configure webpack)</li>
<li>WiP: generates Typescript declarations for user-defined Helios types (Typescript declaration files are emitted inside the source directory)</li>
</ul>
<blockquote>
<p><strong>Note</strong>: the Helios import syntax must use literal string relative paths instead of module names.</p>
</blockquote>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<p>A Helios module:</p>
<pre><code class="language-helios">// common.hl
module common

struct Datum {
    secret: Int
}

struct Redeemer {
    guess: Int
}
</code></pre>
<p>A Helios validator:</p>
<pre><code class="language-helios">// contract.hl
spending contract 

import { Datum, Redeemer } from &quot;./common.hl&quot;

func main(datum: Datum, redeemer: Redeemer, _) -&gt; Bool {
    datum.secret == redeemer.guess
}
</code></pre>
<p>Typescript off-chain code:</p>
<pre><code class="language-ts">// index.ts
import Program from &quot;./contract.hl&quot;

const program = new Program()

const uplcProgram = program.compile(true)

...
</code></pre>
<p>The imported <code>Program</code> has the same methods as <a href="integrations/../api/reference/program.html"><code>helios.Program</code></a>.</p>
<h2 id="installation-and-configuration"><a class="header" href="#installation-and-configuration">Installation and configuration</a></h2>
<p>Install the loader:</p>
<pre><code>npm install --save-dev @hyperionbt/helios-loader
</code></pre>
<p>Configure <a href="https://webpack.js.org/configuration/">Webpack</a>, for example:</p>
<pre><code class="language-js">// webpack.config.js
module.exports = {
	mode: &quot;development&quot;,
	entry: &quot;./index.ts&quot;,
	output: {
		path: __dirname + &quot;/dist/&quot;
	},
	module: {
		rules: [
		  	{
				test: /(?&lt;!\.d)\.(ts|tsx)$/,
				exclude: /node_modules/,
				resolve: {
			  		extensions: [&quot;.ts&quot;, &quot;.tsx&quot;],
				},
				use: [
					&quot;ts-loader&quot;,
                    // helios-loader AFTER ts-loader so it is able to 
                    //  import Helios scripts BEFORE ts-loader is called
					&quot;@hyperionbt/helios-loader&quot; 
				]
		  	},
			{
				test: /\.(hl|helios)$/,
				exclude: /node_modules/,
				use: [
					{
						loader: &quot;@hyperionbt/helios-loader&quot;,
						options: {
                            // must be true when importing Helios scripts in Typescript
							emitTypes: true 
						}
					}
				]
			}
		]
	}
}
</code></pre>
<h2 id="contributing-1"><a class="header" href="#contributing-1">Contributing</a></h2>
<p>The Helios Webpack loader repository can be found <a href="https://github.com/hyperion-bt/helios-loader">on github</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-concepts"><a class="header" href="#advanced-concepts">Advanced concepts</a></h1>
<p>This chapter covers minting policies, exploits, some more complex scripts, and some recommendations for building dApps.</p>
<p>Still a work in progress...</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exploits"><a class="header" href="#exploits">Exploits</a></h1>
<h2 id="double-satisfaction"><a class="header" href="#double-satisfaction">Double satisfaction</a></h2>
<p>If a smart contract simply checks that a given value is sent to an address, then that condition could be satisfied in another smart contract at the same time. The output is only sent once, but the condition is thus satisfied multiple times in the same transaction.</p>
<p>This can be avoided by enforcing that the output value is sent to the given address with a given datum tag.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intermediate-representation"><a class="header" href="#intermediate-representation">Intermediate representation</a></h1>
<p>Helios scripts aren't compiled directly to UPLC. Rather they are compiled into an Intermediate Representation (IR). This section describes the components of the IR and how the simplification process works. This can be useful information for auditors of the Helios code-base.</p>
<p>The Helios IR is a typeless variant of Helios, where high-level syntactic constructs have been replaced by low-level equivalents (represented a class hierarchy with <code>IRExpr</code> as a base class):</p>
<ul>
<li><code>IRNameExpr</code></li>
<li><code>IRLiteralExpr</code></li>
<li><code>IRConstExpr</code></li>
<li><code>IRFuncExpr</code></li>
<li><code>IRCallExpr</code>
<ul>
<li><code>IRCoreCallExpr</code></li>
<li><code>IRUserCallExpr</code>
<ul>
<li><code>IRAnonCallExpr</code>
<ul>
<li><code>IRFuncDefExpr</code></li>
</ul>
</li>
<li><code>IRNestedAnonCallExpr</code></li>
</ul>
</li>
</ul>
</li>
<li><code>IRErrorCallExpr</code></li>
</ul>
<p>The remaining part of this page describes the IR syntax.</p>
<h2 id="irnameexpr"><a class="header" href="#irnameexpr"><code>IRNameExpr</code></a></h2>
<p>Any word matching of the regular expression <code>[_a-zA-Z][_a-zA-Z0-9]*</code>, except the following keywords: <code>const</code>, <code>error</code>, <code>true</code>, <code>false</code>.</p>
<h2 id="irliteralexpr"><a class="header" href="#irliteralexpr"><code>IRLiteralExpr</code></a></h2>
<ul>
<li><code>true</code> or <code>false</code> for a literal <code>Bool</code></li>
<li><code>##[0-9a-f]*</code> for literal <code>Data</code></li>
<li><code>#[0-9a-f]*</code> for a literal <code>ByteArray</code></li>
<li><code>&quot;.*&quot;</code> for a literal <code>String</code></li>
<li><code>[0-9]+</code> for a literal <code>Int</code></li>
</ul>
<h2 id="irconstexpr"><a class="header" href="#irconstexpr"><code>IRConstExpr</code></a></h2>
<p>Emitted by Helios <code>const</code> statements.</p>
<pre><code>const(&lt;expr&gt;)
</code></pre>
<h2 id="irfuncexpr"><a class="header" href="#irfuncexpr"><code>IRFuncExpr</code></a></h2>
<pre><code>(&lt;arg-name&gt;, &lt;arg-name&gt;, ...) -&gt; {
    &lt;body-expr&gt;
}
</code></pre>
<h2 id="ircallexpr"><a class="header" href="#ircallexpr"><code>IRCallExpr</code></a></h2>
<h3 id="ircorecallexpr"><a class="header" href="#ircorecallexpr"><code>IRCoreCallExpr</code></a></h3>
<pre><code>__core__&lt;builtin-name&gt;(&lt;arg-expr&gt;, &lt;arg-expr&gt;, ...)
</code></pre>
<h3 id="irusercallexpr"><a class="header" href="#irusercallexpr"><code>IRUserCallExpr</code></a></h3>
<pre><code>&lt;expr&gt;(&lt;arg-expr&gt;, &lt;arg-expr&gt;, ...)
</code></pre>
<h3 id="iranoncallexpr"><a class="header" href="#iranoncallexpr"><code>IRAnonCallExpr</code></a></h3>
<pre><code>(&lt;arg-name&gt;, &lt;arg-name&gt;, ...) -&gt; {
    &lt;body-expr&gt;
}(&lt;arg-expr&gt;, &lt;arg-expr&gt;, ...)
</code></pre>
<h3 id="irnestedanoncallexpr"><a class="header" href="#irnestedanoncallexpr"><code>IRNestedAnonCallExpr</code></a></h3>
<pre><code>(&lt;arg-name&gt;, &lt;arg-name&gt;, ...) -&gt; {
    &lt;body-expr&gt;
}(&lt;arg-expr&gt;, &lt;arg-expr&gt;, ...)(&lt;call-arg-expr&gt;, ...)
</code></pre>
<h3 id="irfuncdefexpr"><a class="header" href="#irfuncdefexpr"><code>IRFuncDefExpr</code></a></h3>
<pre><code>(&lt;fn-name&gt;) -&gt; {
    &lt;rest-expr&gt;
}(
    (&lt;arg-name&gt;, &lt;arg-name&gt;, ...) -&gt; {
        &lt;body-expr&gt;
    }
)
</code></pre>
<h2 id="irerrorcallexpr"><a class="header" href="#irerrorcallexpr"><code>IRErrorCallExpr</code></a></h2>
<pre><code>error(&quot;.*&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ir-simplication"><a class="header" href="#ir-simplication">IR simplication</a></h1>
<p>Simplification of a compiled program is done at the IR level because it provides more context.</p>
<p>Simplification consists of the following steps:</p>
<ol>
<li>Evaluation of constants</li>
<li>Simplify literals</li>
</ol>
<ul>
<li>Inline literals</li>
<li>Evaluate core calls with only literal args</li>
</ul>
<ol start="3">
<li>Simplify topology</li>
</ol>
<ul>
<li>Count all references</li>
<li>Inline definitions</li>
<li>Remove unused definitions</li>
<li>Combine nested functions </li>
<li>Eliminate cast/uncast function call combinations</li>
</ul>
<h2 id="evaluation-of-constants"><a class="header" href="#evaluation-of-constants">Evaluation of constants</a></h2>
<p>This is step is always performed (i.e. regardless of the value of <code>simplify</code> when calling <a href="advanced-concepts/ir/../../api/reference/program.html#compile"><code>compile()</code></a>).</p>
<p>This step starts at the root of the syntax tree by calling <code>evalConstants()</code>, which is called recursively until <code>IRConstExpr</code> instances are found. A <code>IRCallStack</code> is filled with definitions in the process. <code>IRConstExpr</code> calls <code>eval()</code> recursively instead.</p>
<p>Note that all definitions must be added as deferred <code>IRValue</code> instances to the stack by <code>IRAnonCallExpr</code>, as they might be needed by inner <code>IRConstExpr</code> instances.</p>
<h2 id="simplify-literals"><a class="header" href="#simplify-literals">Simplify literals</a></h2>
<p>Next we inline all literal arguments defined in higher scopes. Any <code>IRCoreCallExpr</code> instances with only literal arguments are also evaluated.</p>
<p>A single method is defined on <code>IRExpr</code> for this step: <code>simplifyLiterals(map: Map&lt;IRVariable, IRLiteralExpr&gt;)</code>. The literals arguments of <code>IRCallExpr</code> must be simplified before the algorithm goes deeper in the AST. The literal arguments of <code>IRAnonCallExpr</code> are the ones that are inserted in the map passed to <code>simplifyLiterals</code>.</p>
<p>Many builtin functions (e.g. <code>ifThenElse</code>) can already be simplified if only some of the args are literals.</p>
<h2 id="simplify-topology"><a class="header" href="#simplify-topology">Simplify topology</a></h2>
<p>Before starting this step, all references of each <code>IRVariable</code> must be registered.</p>
<h3 id="inline-definitions"><a class="header" href="#inline-definitions">Inline definitions</a></h3>
<p>Care needs to be taken not to inline wherever there is recursion (i.e. loops).</p>
<p>Note: <code>IRNameExpr</code> instances can always be inlined.</p>
<h3 id="remove-unused-definitions"><a class="header" href="#remove-unused-definitions">Remove unused definitions</a></h3>
<p>This is done inside <code>IRAnonCallExpr</code> instances.</p>
<h3 id="combine-nested-functions-functions"><a class="header" href="#combine-nested-functions-functions">Combine nested functions functions</a></h3>
<pre><code>(outer) -&gt; {
  (inner) -&gt; {
    ...
  }
}(a)(b)
</code></pre>
<p>Should be simplified to:</p>
<pre><code>(outer, inner) -&gt; {
  ...
}(a, b)
</code></pre>
<p>This is done inside <code>IRNestedAnonCallExpr</code> instances.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minting-native-assets"><a class="header" href="#minting-native-assets">Minting native assets</a></h1>
<p>One of Cardano's best features is supporting <strong>native multi-assets</strong>. These are user-created tokens on Cardano that  have the same treatment as the native coin (Ada).</p>
<p>This might not seem like a big deal but this offers serious advantages over Ethereum tokens (ERC-20 and ERC-721). But to understand the benefits you have to understand how user-defined tokens work on non-UTxO blockchains.</p>
<h2 id="erc-20-standard"><a class="header" href="#erc-20-standard">ERC-20 Standard</a></h2>
<p>On Ethereum, tokens are defined using the <a href="https://ethereum.org/en/developers/docs/standards/tokens/erc-20/">ERC-20 standard</a>. In this standard tokens are managed by a contract that stores all of the token's metadata and all user balances in a <code>mapping</code> (hashmap) called <code>_balances</code>. All transfers of an ERC-20 token are function calls to the contract to modify the <code>_balances</code>.</p>
<p>Any error in the implementation of the ERC-20 standard can lead to the loss of user funds.</p>
<h2 id="utxo-native-assets"><a class="header" href="#utxo-native-assets">UTxO Native Assets</a></h2>
<p>On Cardano and other eUTxO blockchains user-defined tokens are <em>first-class</em>. Tokens on Cardano are stored in <strong>token bundles</strong> which can contain Ada and any native asset. This allows Cardano to do in one transaction what would normally take multiple contract calls on Ethereum.</p>
<blockquote>
<p><strong>Note</strong>: A <strong>token bundle</strong> must always contain a minimum amount of Ada.</p>
</blockquote>
<h3 id="minting-policies"><a class="header" href="#minting-policies">Minting Policies</a></h3>
<p>Minting policies are a lot like spending scripts. These policies validate attempts to mint or burn a tokens of that policy.</p>
<p>There are a few key differences wrt. spending scripts:</p>
<ul>
<li>Minting policies are not directly linked to any UTxO they are included in the minting transaction directly.</li>
<li>Minting policies take two arguments (the <code>ScriptContext</code> and the <code>Redeemer</code>), they have no input UTxO and therefore no Datum.</li>
</ul>
<h3 id="assetclass-2"><a class="header" href="#assetclass-2">AssetClass</a></h3>
<p>Native assets are identified by their <code>AssetClass</code> this is a combination of:</p>
<ul>
<li>
<p>a <strong><code>MintingPolicyHash</code></strong>: the hash of the minting policy of the token. Sometimes referred to as the CurrencySymbol or the PolicyID.</p>
</li>
<li>
<p>a <strong>token name</strong>: this is used to distinguish different assets within the same policy (e.g. multiple NFTs using the same minting policy)</p>
</li>
</ul>
<blockquote>
<p><strong>Note</strong>: The <code>MintingPolicyHash</code> of ADA is an empty <code>ByteArray</code> (<code>#</code>). Since nothing can hash to an empty string Ada is the only token that can't be minted/burned using a minting policy.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signature-based-minting"><a class="header" href="#signature-based-minting">Signature based minting</a></h1>
<p>This example shows a simple minting policy that allows minting tokens as long as the transaction is signed by an <strong>owner</strong>. The <strong>owner</strong> has a given <code>PubKeyHash</code>.</p>
<pre><code class="language-helios">minting signed

const OWNER: PubKeyHash = PubKeyHash::new(#26372...)

func main(_, ctx: ScriptContext) -&gt; Bool {
    ctx.tx.is_signed_by(OWNER)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unique-minting"><a class="header" href="#unique-minting">Unique minting</a></h1>
<p>NFTs (Non-Fungible tokens) are tokens resulting from a unique minting event. To make an NFT the minting policy must make sure that that policy can only be used once and that only one token can ever be minted. The <strong>token name</strong> for the NFT in this example will be called <code>example_nft</code>. Usually the amount of each token is restricted to 1.</p>
<p>There are two approaches for these kind of minting policies:</p>
<ul>
<li>Deadline-based Approach</li>
<li>UTxO-based Approach</li>
</ul>
<h2 id="deadline-based-approach"><a class="header" href="#deadline-based-approach">Deadline-based Approach</a></h2>
<p>NFTs were available on Cardano before smart contracts (Mary Hardfork) and they were implemented using deadlines.
The main idea is that the token can only be minted before a deadline which already passed.
This ensures no new tokens will ever be minted.
This is very easy to implement:</p>
<pre><code class="language-helios">minting deadline_nft

const DEADLINE: Time = Time::new(1661665196132) // milliseconds since 1970


func main(_, ctx: ScriptContext) -&gt; Bool {
	tx: Tx = ctx.tx;

    nft_assetclass: AssetClass = AssetClass::new(
		ctx.get_current_minting_policy_hash(), 
		&quot;example-nft&quot;.encode_utf8()
	);

    value_minted: Value = tx.minted;

    value_minted == Value::new(nft_assetclass, 1) &amp;&amp; tx.time_range.start &lt; DEADLINE
}
</code></pre>
<h2 id="utxo-based-approach"><a class="header" href="#utxo-based-approach">UTxO-Based Approach</a></h2>
<p>This method is based on an <a href="https://plutus-pioneer-program.readthedocs.io/en/latest/pioneer/week5.html">example</a> in the Plutus Pioneer Program.
This approach takes advantage of the fact that all UTxOs have a unique <code>TxOutputId</code>.
A UTxO's <code>TxOutputId</code> is made up of the transaction hash of the transaction that made the UTxO and the index of the UTxO in the outputs of that transaction.
It's a builtin type that is defined as:</p>
<pre><code class="language-helios">struct TxOutputId {
    tx_id: TxId
    index: Int
}
</code></pre>
<p>So with this approach, we specify in the minting policy that the transaction minting the NFT must spend a UTxO with a specific <strong>output ID</strong>.
Since a UTxO can only be spent once this means the token can only be minted once.</p>
<pre><code class="language-helios">minting utxo_nft

const OUTPUT_ID: TxOutputId = TxOutputId::new(TxId::new(#1213), 1)

func main(_, ctx: ScriptContext) -&gt; Bool {
	tx: Tx = ctx.tx;

    nft_assetclass: AssetClass = AssetClass::new(
		ctx.get_current_minting_policy(), 
		&quot;example-nft&quot;.encode_utf8()
	);

    value_minted: Value = tx.minted;

    value_minted == Value::new(nft_assetclass, 1) &amp;&amp; 
    tx.inputs
        .any((input: TxInput) -&gt; Bool {input.output_id == OUTPUT_ID})

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vesting-contract"><a class="header" href="#vesting-contract">Vesting contract</a></h1>
<p>To put what we've done so far to use we're going to build a simple 'vesting' contract.
This contract will lock up some tokens owned by an <strong>owner</strong>
for a <strong>beneficiary</strong> that can't be claimed until after a <strong>deadline</strong>.
The <strong>owner</strong> can get their funds back if the <strong>deadline</strong> has not passed yet</p>
<h2 id="datum-4"><a class="header" href="#datum-4">Datum</a></h2>
<p>The datum stores the <code>PubKeyHash</code> of the <strong>beneficiary</strong> and <strong>creator</strong>'s wallets and the vesting deadline is represented as a <code>Time</code>.</p>
<pre><code class="language-helios">struct Datum {
    creator: PubKeyHash
    beneficiary: PubKeyHash
    deadline: Time
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: The <code>Time</code> type represents a POSIX time and
for more info <a href="advanced-concepts/../helios_builtins/Helios_Builtins.html">Helios Builtins</a>.</p>
</blockquote>
<h2 id="redeemer"><a class="header" href="#redeemer">Redeemer</a></h2>
<pre><code class="language-helios">enum Redeemer {
    Cancel
    Claim
}
</code></pre>
<p>There are two cases when the validator should return <code>true</code>:</p>
<ul>
<li>
<p><strong>Cancel</strong></p>
<p>In this case, the 'owner' wishes to cancel the contract and get back their funds.
For a 'Cancel' to succeed the following have to be checked</p>
<ul>
<li>The owner signed the transaction.</li>
<li>The deadline hasn't passed.</li>
</ul>
</li>
<li>
<p><strong>Vesting Claim</strong></p>
<p>A 'Claim' occurs when the 'beneficiary' wishes to claim the tokens vested for them.
For it to be valid the following have to be checked:</p>
<ul>
<li>The beneficiary signed the transaction.</li>
<li>The deadline has passed.</li>
</ul>
</li>
</ul>
<h2 id="main"><a class="header" href="#main"><code>main</code></a></h2>
<pre><code class="language-helios">func main(datum: Datum, redeemer: Redeemer, context: ScriptContext) -&gt; Bool {
    tx: Tx = context.tx;
    now: Time = tx.time_range.start;

    redeemer.switch {
        Cancel =&gt; {
            // Check that deadline hasn't passed
            now &lt; datum.deadline &amp;&amp; 

            // Check that the owner signed the transaction
            tx.is_signed_by(datum.creator)
        },
        Claim =&gt; {
           // Check that deadline has passed.
           now &gt; datum.deadline &amp;&amp;

           // Check that the beneficiary signed the transaction.
           tx.is_signed_by(datum.beneficiary)
        }
    }
}
</code></pre>
<h2 id="complete-code"><a class="header" href="#complete-code">Complete code</a></h2>
<pre><code class="language-helios">spending vesting

struct Datum {
    creator: PubKeyHash
    beneficiary: PubKeyHash
    deadline: Time
}

enum Redeemer {
    Cancel
    Claim
}

func main(datum: Datum, redeemer: Redeemer, context: ScriptContext) -&gt; Bool {
    tx: Tx = context.tx;
    now: Time = tx.time_range.start;

    redeemer.switch {
        Cancel =&gt; {
            now &lt; datum.deadline &amp;&amp;
            tx.is_signed_by(datum.creator)
        },
        Claim =&gt; {
           now &gt; datum.deadline &amp;&amp;
           tx.is_signed_by(datum.beneficiary)
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="english-auction"><a class="header" href="#english-auction">English auction</a></h1>
<p>In this example, we will rewrite the <a href="https://plutus-pioneer-program.readthedocs.io/en/latest/pioneer/week1.html">English auction contract</a>
from the Plutus Pioneer's program in Helios.</p>
<p>This validator can be used to lock assets that are to be auctioned in a UTxO.</p>
<h2 id="main-1"><a class="header" href="#main-1"><code>main</code></a></h2>
<pre><code class="language-helios">spending english_auction

struct Datum {
    seller:         PubKeyHash
    bid_asset:      AssetClass     // allow alternative assets (not just lovelace)
    min_bid:        Int
    deadline:       Time
    for_sale:       Value          // the asset that is being auctioned
    highest_bid:    Int            // initialized at 0, which signifies the auction doesn't yet have valid bids
    highest_bidder: PubKeyHash

    func update(self, highest_bid: Int, highest_bidder: PubKeyHash) -&gt; Datum {
        self.copy(highest_bid: highest_bid, highest_bigger: highest_bidder)
    }
}

enum Redeemer {
    Close 
    Bid {
        bidder: PubKeyHash
        bid: Int
    }
}

func main(datum: Datum, redeemer: Redeemer, ctx: ScriptContext) -&gt; Bool {
    tx: Tx = ctx.tx;

    now: Time = tx.time_range.start;

    validator_hash: ValidatorHash = ctx.get_current_validator_hash();

    redeemer.switch {
        Close =&gt; {
            if (datum.highest_bid &lt; datum.min_bid) {
                // the forSale asset must return to the seller, what happens to any erroneous bid value is irrelevant
                tx
                  .value_sent_to(datum.seller)
                  .contains(datum.for_sale + datum.highest_bid) &amp;&amp;
                // Check that the deadline has passed
                now &gt; datum.deadline                                    
            } else {
                // Check that the seller receives the highest bid
                tx
                  .value_sent_to(datum.seller)
                  .contains(Value::new(datum.bid_asset, datum.highest_bid))    &amp;&amp;
                // Check that highest bidder is given the token being auctioned
                tx
                  .value_sent_to(datum.highest_bidder)
                  .contains(datum.for_sale)                                    &amp;&amp;
                // Check that the deadline has passed
                now &gt; datum.deadline                                    
            }
        },
        b: Bid =&gt; {
            if (b.bid &lt; datum.min_bid) {
                false
            } else if (b.bid &lt;= datum.highest_bid) {
                false
            } else {
                // first bid is placed by the auction creator
                expected_datum: Datum = datum.update(b.bid, b.bidder);

                // Check that new Auction UTxO contains the token for sale and the new bid
                tx
                  .value_locked_by_datum(validator_hash, expected_datum)
                  .contains(datum.for_sale + Value::new(datum.bid_asset, b.bid)) &amp;&amp;
                // Check that the old highest bidder is repayed
                tx
                  .value_sent_to(datum.highest_bidder)
                  .contains(Value::new(datum.bid_asset, datum.highest_bid))      &amp;&amp;
                // Check that the deadline hasn't passed
                now &lt; datum.deadline
            }
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oracle-pools-wip"><a class="header" href="#oracle-pools-wip">Oracle pools (WiP)</a></h1>
<p>Oracles post information on the blockchain periodically (eg. the ADA/USD exchange rate), and thanks to the recent Vasil upgrade it has become easier to use that information in smart contracts (eg. stable-coin contracts).</p>
<p>Of course relying on a single centralized oracle goes against the spirit of cryptocurrencies and blockchain technology, so oracles should be grouped in pools. An oracle pool is essentially a smart contract which periodically groups inputs from all participating oracles into a single UTxO. The participating oracles are also rewarded from the oracle pool contract.</p>
<p>A more complete description of oracle pools can be found (here)[https://github.com/Emurgo/Emurgo-Research/blob/master/oracles/Oracle-Pools.md].</p>
<h2 id="oracle-pool-design-decisions"><a class="header" href="#oracle-pool-design-decisions">Oracle pool design decisions</a></h2>
<h3 id="membership"><a class="header" href="#membership">Membership</a></h3>
<p>The first question we need to answer is who can be a member of the pool:</p>
<ol>
<li>new members can be voted in by existed members, malicious members can be voted out</li>
<li>member performance is measured on-chain, and only the best performing X oracles can claim rewards, in case of a draw seniority wins, X can be changed by voting</li>
<li>token-based membership</li>
</ol>
<p>Of course the concept of individual 'members' doesn't really apply to an anonymous blockchain, as a single physical actor can control multiple memberships.</p>
<p>Membership based purely on voting allows the founder(s) to keep exerting strong control over the oracle pool. Initial membership distribution is also entirely obscured from the public. So closed or limited membership is probably a bad idea from a decentralization perspective.</p>
<p>Entry into the pool based on performance is essentially a time and resource intensive method of acquiring membership. Existing members will vote to keep the max number of members low, in order maximize individual rewards. To avoid that the max number of members might need to be fixed via the contract, but that way the contract loses a lot of flexibility.</p>
<p>Token-based membership is vulnerable to a 51% attack. An attacker could quietly acquire the majority of tokens. Any subsequent attack would instantly destroy all smart contracts relying on the oracle. Because oracle pools are expected to be critical infrastructure for DeFi on Cardano, such an attack must of course be avoided at all costs. So that means initial token distribution must be spread very well, for which several rounds of ISPOs can be used. There also needs to be high enough oracle operation reward, so the tokens are effectively staked and aren't floating around on exchanges.</p>
<p>Note that oracle pools with open membership are also vulnerable to 51% attacks, but that such attacks are made more difficult by the time-delay of requiring the membership.</p>
<p>For this example we will choose a token-based membership. So the first task will be minting the tokens (see (how-to guide to mintin)[tutorial_06-minting_policy_scripts.md]).</p>
<h3 id="data-point-collection"><a class="header" href="#data-point-collection">Data-point collection</a></h3>
<p>Data-point submission happens in three phases.</p>
<p>An active oracle must own some oracle tokens. Every posting period it calculates the data-point and sends a UTxO into the oracle pool contract. The data-point is described in a conventional hash, along with salt. The posting UTxO must also contain the oracle tokens and sufficient collateral.</p>
<p>In a second phase each participating oracle resends the UTxO into the oracle pool contract, while adding a provable time-stamp to the datum.</p>
<p>In the last phase the datum is 'unhidden' by resending the UTxO into the oracle pool contract with an inline-datum. At this point the script can check if sufficient time has passed since unhiding. The 'unhidden' UTxO must also be registered in a special registration UTxO (of which there can be multiple for parallel posting).</p>
<p>Note that data-point submission also contains governance parameters.</p>
<h3 id="data-point-aggregation"><a class="header" href="#data-point-aggregation">Data-point aggregation</a></h3>
<p>This is the most complex transaction of the oracle pool contract.</p>
<p>This transaction can be submitted after a predefined period after the first entry in one of the registration UTxOs.</p>
<p>In this transaction all 'unhidden' UTxOs, with a time-stamp lying in the correct range, are used to resend the data carrying UTxO into the script contract with the new data-point (inline-datum of course). The submitting oracle must use all the 'unhidden' UTxOs that have been registered in the registration UTxOs. A token-weighted median of the data-point is calculated. Any oracles that lie within a predefined range of the median receive rewards according to how many oracle tokens they own (the submitting transaction gets double the rewards). Any oracles that lie outside the predefined range lose their collateral to the contract. The registration UTxOs are emptied, and the oracle tokens/left-over collateral is sent back to the owners.</p>
<p>The uniqueness of each input UTxO datum must also be checked. Two or more UTxOs with the same datum are obviously colluding (they would've had to have picked the same salt) and lose their collateral. </p>
<p>The final data-point UTxO can also contain governance parameters, which are updated if there is a sufficient majority. One of these parameters is the number of registration UTxOs, for which additional ones need to be minted if the number increases, and superfluous ones need to burned if the number decreases.</p>
<p>The final data-point UTxO must be marked by a unique data-NFT.</p>
<h2 id="minting-1"><a class="header" href="#minting-1">Minting</a></h2>
<p>The oracle pool described above requires minting 3 different kinds of tokens:</p>
<ol>
<li>oracle pool membership tokens (unique minting)</li>
<li>a single data NFT (unique minting)</li>
<li>registration NFT (non-unique minting/burning)</li>
</ol>
<h2 id="governance-parameters"><a class="header" href="#governance-parameters">Governance parameters</a></h2>
<ul>
<li>submissionPeriod             Duration (period in which the first two phases of data submission must be completed, unhiding must happen after this period)</li>
<li>unhidingPeriod               Duration (period in which data-point UTxOs are unhidden and registered in registration UTxOs)</li>
<li>nRegistrationQueues          Integer (number of registration UTxOs)</li>
<li>collateralPerMembershipToken Integer (collateral asset will probably be ADA)</li>
<li>validDataRange               Integer (+- around the median, could be in 'points', so '1' is 1%)</li>
<li>governanceQuorum             Integer (could be '75' for 75%)</li>
<li>postRewardForWholePool       Integer (postReward asset will probably be ADA)</li>
<li>extraRewardForPoster         Integer (could be '100' for 100% extra i.e. x2)</li>
</ul>
<p>The datum of the data-point UTxO will contain the governance parameters and the data-point itself:</p>
<ul>
<li>dataPoint  Integer</li>
</ul>
<p>This could be extended to multiple data-points at some, although makes (dis)incentives more difficult to calulate.</p>
<h2 id="other-datums"><a class="header" href="#other-datums">Other datums</a></h2>
<p>Registration UTxO datum:</p>
<ul>
<li>inputs []TxOutputId</li>
</ul>
<p>Submission UTxO datum:</p>
<ul>
<li>owner     PubKeyHash</li>
<li>salt      Integer</li>
<li>dataPoint Integer</li>
<li>all the governance parameters</li>
</ul>
<p>The sometimes vastly differing datum types probably made it worthwhile to introduce union types:</p>
<pre><code class="language-golang">enum Datum {
    Post {
        dataPoint: Integer,
        govParams: GovernanceParams
    }, 
    Submit {
        owner:     PubKeyHash,
        salt:      Integer,
        dataPoint: Integer,
        time:      Time,
        govParams: GovernanceParams
    },
    Queue {
        inputs: []TxOutputId
    }
}
</code></pre>
<p>Data constructors must have a unique order, and can only be used in a single union. The data constructor type can be referenced using the <code>::</code> symbol (eg. <code>Datum::Post</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dapp-recommendations"><a class="header" href="#dapp-recommendations">dApp recommendations</a></h1>
<h2 id="no-build-tools"><a class="header" href="#no-build-tools">No build tools</a></h2>
<p>A lot of care went into making the Helios library as auditable as possible. Therefore we recommend for your dApp to use the library in its unminified form so users can audit the compiler more easily.</p>
<p>We also recommened using an client-side UI framework (like Preact/Htm), so that your dApp can be served directly to the client without needing a build-step.</p>
<h2 id="show-contract-button"><a class="header" href="#show-contract-button">Show contract button</a></h2>
<p>The smart contracts used in the dApp should be viewable by the user.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tx-finalization"><a class="header" href="#tx-finalization">Tx finalization</a></h1>
<p>The Helios API can be used to build transactions. Finalization consist of the following steps:</p>
<ol>
<li>balancing of non-ADA assets</li>
<li>calculation of script execution units (using a dummy fee set to the maximum possible value)</li>
<li>setting collateral inputs and collateral output (using total execution budget calculated in previous step)</li>
<li>iteratively calculate the min fee for the transaction and balance the lovelace</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/custom.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
