<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Helios Programming Language</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="The_Helios_Programming_Language.html"><strong aria-hidden="true">1.</strong> The Helios Programming Language</a></li><li class="chapter-item expanded "><a href="chapter_1/00_Basics_of_Helios.html"><strong aria-hidden="true">2.</strong> Basics of Helios</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_1/01_Variables.html"><strong aria-hidden="true">2.1.</strong> Variables</a></li><li class="chapter-item expanded "><a href="chapter_1/02_Builtin_Types.html"><strong aria-hidden="true">2.2.</strong> Builtin Types</a></li><li class="chapter-item expanded "><a href="chapter_1/03_Functions.html"><strong aria-hidden="true">2.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="chapter_1/04_Structs_and_Enums.html"><strong aria-hidden="true">2.4.</strong> Structs and Enums</a></li><li class="chapter-item expanded "><a href="chapter_1/05_Methods_and_Associated_Functions.html"><strong aria-hidden="true">2.5.</strong> Methods and Associated Functions</a></li><li class="chapter-item expanded "><a href="chapter_1/06_Comments_Printing_and_Branching.html"><strong aria-hidden="true">2.6.</strong> Comments, Printing, and Branching</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_2/00_Blockchain_Programming_in_Helios.html"><strong aria-hidden="true">3.</strong> Blockchain Development with Helios</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_2/01_The_EUTXO_Model.html"><strong aria-hidden="true">3.1.</strong> The EUTXO Model</a></li><li class="chapter-item expanded "><a href="chapter_2/02_Validator_Scripts.html"><strong aria-hidden="true">3.2.</strong> Validator Scripts</a></li><li class="chapter-item expanded "><a href="chapter_2/03_ScriptContext.html"><strong aria-hidden="true">3.3.</strong> The ScriptContext</a></li><li class="chapter-item expanded "><a href="chapter_2/04_vesting_contract.html"><strong aria-hidden="true">3.4.</strong> Example 1: Vesting Contract</a></li><li class="chapter-item expanded "><a href="chapter_2/05_english_auction.html"><strong aria-hidden="true">3.5.</strong> Example 2: English Auction</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_3/Native_Assets.html"><strong aria-hidden="true">4.</strong> Native Assets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_3/Value.html"><strong aria-hidden="true">4.1.</strong> Value</a></li><li class="chapter-item expanded "><a href="chapter_3/Signed.html"><strong aria-hidden="true">4.2.</strong> Signed Policy</a></li><li class="chapter-item expanded "><a href="chapter_3/NFT.html"><strong aria-hidden="true">4.3.</strong> NFT</a></li></ol></li><li class="chapter-item expanded "><a href="helios_builtins/helios_builtins.html"><strong aria-hidden="true">5.</strong> Helios Builtins</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="helios_builtins/primitive_types.html"><strong aria-hidden="true">5.1.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="helios_builtins/time_types.html"><strong aria-hidden="true">5.2.</strong> Time Types</a></li><li class="chapter-item expanded "><a href="helios_builtins/cryptography_types.html"><strong aria-hidden="true">5.3.</strong> Cryptography Types</a></li><li class="chapter-item expanded "><a href="helios_builtins/native-asset_types.html"><strong aria-hidden="true">5.4.</strong> Native-Assets Types</a></li><li class="chapter-item expanded "><a href="helios_builtins/transaction_types.html"><strong aria-hidden="true">5.5.</strong> Transaction Types</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Helios Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-helios-programming-language"><a class="header" href="#the-helios-programming-language">The Helios Programming Language</a></h1>
<p><a href="https://github.com/Hyperion-BT/Helios">Helios</a> is a DSL for writing smart contracts on the Cardano blockchain.
It's heavily inspired by Rust, Go and Sway.</p>
<h2 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h2>
<ul>
<li>Helios should be readable by almost any programmer.</li>
<li>There should be one and preferrably only one way to do everything (For example, no trailing commas).</li>
</ul>
<br/>
<pre><code class="language-go  noplaypen">// All Helios programs begin with a script purpose.
spending always_true 

// The 'main' function contains the core validator logic.
func main() -&gt; Bool {
    // Helios is an expression based language
    true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics-of-helios"><a class="header" href="#basics-of-helios">Basics of Helios</a></h1>
<p>In this chapter we will cover the basics of the Helios programming language.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>As a functional programming language, Helios doesn't support mutable variables. Helios does however support binding values to names.</p>
<h2 id="binding-inside-a-function"><a class="header" href="#binding-inside-a-function">Binding inside a function</a></h2>
<p>Inside a function body, values can be bound to names using assignment expressions:</p>
<pre><code class="language-rust  noplaypen">my_number: Int = 42; ...
</code></pre>
<p>In this example <code>my_number</code> has value <code>42</code> and has type <code>Int</code>. <code>my_number</code> cannot be mutated after its definition.</p>
<p>Assignment expressions must be followed by another expression, separated by a semicolon (<code>;</code>). The assignment expression above should be seen as syntactic sugar for <code>((my_number: Int) -&gt; {...})(42)</code>.</p>
<blockquote>
<p><strong>Note</strong>: <code>Int</code> is Helios' only number type, and represents an unbounded integer. See <a href="chapter_1/./02_Builtin_Types.html">Builtin Types</a> for more details.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: an assignment expression can alternatively be seen as a ternary operator: <code>... = ... ; ...</code></p>
</blockquote>
<h2 id="const-statements"><a class="header" href="#const-statements"><code>const</code> statements</a></h2>
<p>Values can also be bound to names at the <em>top-level</em> of a script, or inside <code>struct</code> or <code>enum</code> blocks. This is done with the <code>const</code> keyword:</p>
<pre><code class="language-rust  noplaypen">const AGE: Int = 123
</code></pre>
<blockquote>
<p><strong>Note</strong>: The right-hand side of a constant can contain complex expressions and even function calls. The compiler is smart enough to evaluate these at compile-time.</p>
</blockquote>
<h2 id="type-annotations"><a class="header" href="#type-annotations">Type Annotations</a></h2>
<p>Assignment expressions and <code>const</code> statements usually include  a <em>type annotation</em>. For literal right-hand sides <em>type annotations</em> are optional:</p>
<pre><code class="language-rust  noplaypen">list_of_ints = []Int{1, 1, 2, 3, 5}; ...

// instead of the more verbose:

list_of_ints: []Int = []Int{1, 1, 2, 3, 5}; ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builtin-types"><a class="header" href="#builtin-types">Builtin Types</a></h1>
<p>Helios has 4 <strong>primitive</strong> types and 3 <strong>container</strong> types:</p>
<ul>
<li><code>Int</code> (an unbounded integer)</li>
<li><code>Bool</code> (<code>true</code> or <code>false</code>)</li>
<li><code>ByteArray</code> (array of uint8)</li>
<li><code>String</code> (utf-8 text)</li>
<li><code>List</code> (linked list)</li>
<li><code>Map</code> (association list of key-value pairs)</li>
<li><code>Option</code> (aka <code>Maybe</code> in Haskell)</li>
</ul>
<h2 id="int"><a class="header" href="#int"><code>Int</code></a></h2>
<hr />
<p>Helios' <code>Int</code> type represents an unbounded integer like Haskell's <code>Integer</code> type.</p>
<pre><code class="language-rust noplaypen">// Helios supports typical integer literals:
my_decimal: Int = 17;
my_binary: Int = 0b10001;
my_hex: Int = 0x11;
my_octal: Int = 0o121; ...
</code></pre>
<h2 id="bool"><a class="header" href="#bool"><code>Bool</code></a></h2>
<hr />
<p>The <code>Bool</code> type has two possible values: <code>true</code> or <code>false</code>. Booleans are used throughout validator scripts, and validator scripts must always return a boolean. The simplest validator script is just a literal boolean expression:</p>
<pre><code class="language-rust noplaypen">func main() -&gt; Bool {
    true
}
</code></pre>
<p>Booleans can be converted into integers using the builtin <code>to_int</code> method:</p>
<pre><code class="language-rust noplaypen">x: Int = (true).to_int(); // x == 1
y: Int = (false).to_int(); ... // y == 0
</code></pre>
<h2 id="bytearray"><a class="header" href="#bytearray"><code>ByteArray</code></a></h2>
<hr />
<p>The <code>ByteArray</code> type, as you've likely guessed, represents an array of bytes. A literal <code>ByteArray</code> is a hexadecimal sequence with <code>#</code> as a prefix:</p>
<pre><code class="language-rust noplaypen">my_bytes: ByteArray = #af2e221a; ... // 
</code></pre>
<p>All builtin and user types can be converted into a <code>ByteArray</code> using the builtin <code>serialize</code> method:</p>
<pre><code class="language-rust noplaypen">cbor_bytes: ByteArray = (123).serialize(); ... // cbor encoding of 123
</code></pre>
<h2 id="string"><a class="header" href="#string"><code>String</code></a></h2>
<hr />
<p>A literal Helios string uses double quotes (<code>&quot;...&quot;</code>):</p>
<pre><code class="language-ts noplaypen">my_message: String = &quot;hello world&quot;; ...
</code></pre>
<p>Similar to all other values in Helios, strings are immutable and have a fixed length. Strings cannot <em>grow</em> after definition. Concatenating two strings creates a new string:</p>
<pre><code class="language-rust noplaypen">string_1: String = &quot;Hel&quot;;
string_2: String = &quot;ios&quot;;
result: String = string_1 + string_2; ... // &quot;Helios&quot;
</code></pre>
<h2 id="list"><a class="header" href="#list">List</a></h2>
<hr />
<p>Helios has a builtin linked list type, similar to Haskell's <code>List</code>. The type signature for a list is <code>[]a</code> where <code>a</code> is the item type. The item type can be any type except a function type.</p>
<p>List literals have a syntax similar to Go:</p>
<pre><code class="language-rust noplaypen">my_ints = []Int{1, 2, 3, 4, 5};

x: Int = some_ints.get(2); ...   // x == 3
</code></pre>
<blockquote>
<p><strong>Note</strong>: lists aren't indexed with <code>[]</code>. Instead the <code>get</code> method must used, check out <a href="chapter_1/../helios_builtins/Helios_Builtins.html">Helios Builtins</a>.</p>
</blockquote>
<h3 id="useful-methods"><a class="header" href="#useful-methods">Useful methods</a></h3>
<p>Helios lists have typical builtin getters and methods:</p>
<pre><code class="language-rust noplaypen">fib_list: []Int = []Int{1, 1, 2, 3, 5};

//  '.length' returns the length of the list.
fib_list.length == 5;

//  '.get()' is used instead of square brackets for getting a list item by index.
// throws error if index is out of range. 
fib_list.get(4) == 5; 

// '.head' returns the first element of a list.
// throws error if list is empty.
fib_list.head == 1;

// '.tail' returns the list items following the first item
// throws error if list is empty.
fib_list.tail == []Int{1, 2, 3, 5};

// '.prepend()' extends a list (creating a new list)
fib_list.prepend(0) == []Int{0, 1, 1, 2, 3, 5};

// '.is_empty()' returns true if list is empty
[]Int{}.is_empty() == true; 

// '.map()' creates a new list of equal length
fib_list.map((x: Int) -&gt; Int {x*2}) == []Int{2, 2, 4, 6, 10}; 

// '.fold()' is be used to reduce the over the whole list
fib_list.fold((sum: Int, x: Int) -&gt; Int {sum + x}, 0) == 12; ...
</code></pre>
<h2 id="map"><a class="header" href="#map">Map</a></h2>
<hr />
<p>A Map in Helios is internally represented as a list of key-value pairs. Both key and value can have any type except a function type. Uniqueness of keys isn't guaranteed.</p>
<p>A Map has a type signature and a literal syntax similar to Go:</p>
<pre><code class="language-go  noplaypen">my_map: Map[String]Int = Map[String]Int{&quot;zero&quot;: 0, &quot;one&quot;: 1, &quot;two&quot;: 2}; // either side of the colon can be an arbitrary expression that evaluates to the correct type

print(my_map.get(&quot;zero&quot;).show()); ... // prints '0'
</code></pre>
<h2 id="option"><a class="header" href="#option">Option</a></h2>
<hr />
<p>The Option type is a builtin enum with type signature <code>Option[a]</code>. It is internally defined as:</p>
<pre><code class="language-rust  noplaypen">enum Option[a] {
    Some { some: a }
    None
}
</code></pre>
<h3 id="instantiating-an-option"><a class="header" href="#instantiating-an-option">Instantiating an <code>Option</code></a></h3>
<pre><code class="language-rust  noplaypen">some_int: Option[Int] = Option[Int]::Some{42};

none_int: Option[Int] = Option[Int]::None; ...
</code></pre>
<h2 id="more-information"><a class="header" href="#more-information">More Information</a></h2>
<p>For more information on the Builtin type, check out <a href="chapter_1/../helios_builtins/helios_builtins.html">Builtin Types</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions are a core feature of Helios. All Helios functions are <em>pure</em>, which means they have no side effects and always return the same result when given the same arguments.</p>
<p>Function statements are defined using the <code>func</code> keyword. Helios has no <code>return</code> statement, the last expression in a function is <em>implicitly returned</em> (like in Rust):</p>
<pre><code class="language-go  noplaypen">func add(a: Int, b: Int) -&gt; Int {
    a + b 
}
</code></pre>
<p>Helios also supports recursion:</p>
<pre><code class="language-go  noplaypen">func fib(n: Int) -&gt; Int {
    // the branches of an if/else expresion return values
    if (n &lt; 1) {
        1
    } else {
        fib(n-1) + fib(n-2)
    }
}
</code></pre>
<blockquote>
<p><strong>Note:</strong>: A function can only reference itself when recursing. Helios doesn't support hoisting, so mutual recursion by referring to functions defined after the current one isn't possible:</p>
<pre><code class="language-go  noplaypen">01 func a(n: Int) -&gt; Int {
02     b(n)                   // ReferenceError: 'b' undefined
03 }
04
05 func b(n: Int) -&gt; Int {
06     a(n)                   // ok
07 }
</code></pre>
</blockquote>
<h2 id="anonymous-functions"><a class="header" href="#anonymous-functions">Anonymous functions</a></h2>
<p>Helios also supports anonymous functions. Anonymous functions have a syntax similar to closures in Javascript: </p>
<pre><code class="language-rust  noplaypen">is_even = (n: Int) -&gt; Bool { (n % 2) == 0 }; ...
// type of 'is_even' can be infered, 
//  but return type of the anonymous function must be specified
</code></pre>
<blockquote>
<p><strong>Note:</strong> Function statements can be referenced by their name, returning a function value. This should be preferred to using anonymous functions, as it is more readable.</p>
</blockquote>
<h2 id="function-values"><a class="header" href="#function-values">Function values</a></h2>
<p>Functions are first-class citizens in Helios and can be used as values. This means:</p>
<h3 id="1-functions-can-be-passed-as-arguments"><a class="header" href="#1-functions-can-be-passed-as-arguments">1. Functions can be passed as arguments</a></h3>
<pre><code class="language-ts  noplaypen">evens: []Int = ([]Int{1, 2, 3, 4, 5, 6}).filter(is_even); ... // [2, 4. 6]; 
</code></pre>
<h3 id="2-functions-can-be-returned"><a class="header" href="#2-functions-can-be-returned">2. Functions can be returned</a></h3>
<pre><code class="language-rust  noplaypen">add = (a: Int) -&gt; (Int) -&gt; Int { (b: Int) -&gt; Int { a + b } }; ...
</code></pre>
<blockquote>
<p><strong>Note:</strong> So I <em>kind of</em> lied when I told you that functions are first-class: functions can't be stored in containers or structs.</p>
</blockquote>
<h2 id="example-collatz-sequence-"><a class="header" href="#example-collatz-sequence-">Example: Collatz sequence :)</a></h2>
<p>One of my favorite things in maths is the Collatz sequence. A Collatz sequence starts with a given number, <code>n</code>, and calculates the next number in the sequence using the following rules:</p>
<ol>
<li>if <code>n == 1</code> the sequence ends</li>
<li>if <code>n</code> is even the next number is <code>n / 2</code></li>
<li>if <code>n</code> is odd the next number is <code>(n * 3) + 1</code></li>
</ol>
<p>Curiously the Collatz sequence always converges to <code>1</code>, regardless the starting number.</p>
<p>The following function generates the Collatz sequence as a (reversed) list of integers:</p>
<pre><code class="language-go  noplaypen">// eg. collatz(10, []Int{}) == []Int{10, 5, 16, 8, 4, 2, 1}
func collatz(n: Int, sequence: []Int) -&gt; []Int {
	updated_sequence: []Int = sequence.prepend(n);

    // Rule (1)
    if (n == 1) {
		updated_sequence

    // Rule (2)
    } else if (n % 2 == 0) {
        collatz(n / 2, updated_sequence)

    // Rule (3)
    } else {
        collatz(n * 3 + 1, updated_sequence)
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs-and-enums"><a class="header" href="#structs-and-enums">Structs and Enums</a></h1>
<h2 id="structs"><a class="header" href="#structs">Structs</a></h2>
<p>A struct in Helios is a named grouping of types (sometimes called <em>product types</em> in CS). They are similar to structs in other languages (e.g. C, Go and Rust):</p>
<pre><code class="language-rust  noplaypen">// example of a Rational (fractional type)
struct Rational {
    top: Int
    bottom: Int
}

// instantiating a struct:
const x: Rational = Rational { top: 1, bottom: 3 }

// type can be inferred for struct literals:
const x = Rational { top: 1, bottom: 3 }
</code></pre>
<h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<p>Enums are used to represent types that have multiple variants (sometimes called <em>sum types</em> in CS). These are useful for datums and redeemers.</p>
<p>Example of an enum:</p>
<pre><code class="language-rust  noplaypen">enum FanSetting {
    On{ speed: Int }
    Off
}

// instantiating an enum:
const current_setting: FanSetting = FanSetting::On { 5 }

// type can be inferred for enum literals:
const current_setting = FanSetting::On { 5 }
</code></pre>
<blockquote>
<p><strong>Note:</strong> Structs and enum variants with one field are constructed without that field's name as a key.</p>
</blockquote>
<h3 id="switch"><a class="header" href="#switch"><code>switch</code></a></h3>
<p>A <code>switch</code> expression is used to perform different actions depending on the enum variant. It is similar to a <code>switch</code> statement in C or Go (and dissimilar to a <code>match</code> expression in Rust, as Helios doesn't support pattern-matching/destructuring):</p>
<pre><code class="language-rust  noplaypen">enum Datum {
	// content of each variant has the same syntax as a regular struct-type
    Submission{...} 
    Queue{...}
    Post{...}
}

func main(datum: Datum) -&gt; Bool {
	datum.switch {
		x: Submission =&gt; { 
			... // expression must use x
		},
		Queue =&gt; {
			... // x not used, so can't be declared
		},
		else =&gt; true // default must come last if all sub-types of Datum aren't handled explicitely
		// braces surrounding the cases are optional
	}
}

</code></pre>
<blockquote>
<p><strong>Note:</strong> In Helios, <strong>all</strong> fields in a struct and <strong>all</strong> variants in an enum <strong>must be used</strong>,
or else the compiler will throw an error.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methods-and-associated-functions"><a class="header" href="#methods-and-associated-functions">Methods and Associated Functions</a></h1>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p>You can define methods for structs and enums. The syntax for this is similar to many OOP languages: methods are defined by placing <code>func</code> statements inside a <code>struct</code> or <code>enum</code> blocks.</p>
<pre><code class="language-go  noplaypen">struct Rational {
    top: Int
    bottom: Int

    // 'self' implicitely has type 'Rational'
    func add(self, rhs: Rational) -&gt; Rational {
        top: Int = (self.top * rhs.bottom) + (rhs.top * self.bottom);
        bottom: Int = self.bottom * rhs.bottom;

        Rational { top: top, bottom: bottom }
    }
}

const example_rational: Rational = Rational { top: 7, bottom: 21}

const result: Rational = example_rational.add(example_rational)
</code></pre>
<p>Methods are accessed using a <code>.</code> (i.e. a dot). Methods cannot modify <code>self</code> as all Helios values are immutable (instead they should return new instantations of the own type).</p>
<blockquote>
<p><strong>Note:</strong> <code>self</code> is a reserved word and can only be used for the first argument of a method. The <code>self</code> argument is always implicitely typed and can't have a type annotation.</p>
</blockquote>
<h3 id="methods-can-be-used-as-values"><a class="header" href="#methods-can-be-used-as-values">Methods can be used as values</a></h3>
<p>A method is syntactic sugar for a <strong>curried function</strong> (a function that returns a function) that takes <code>self</code> as it's first argument:</p>
<pre><code class="language-rust  noplaypen">// the following:
rational_1.add(rational_2); ...
// desugars into: __user__Rational_add(rational_1)(rational_2)
//  of type (Rational) -&gt; (Rational) -&gt; Rational
</code></pre>
<p>A method value is a function, and can be seen as a closure over <code>self</code>:</p>
<pre><code class="language-rust  noplaypen">// 'rational_1.add' returns a function of type ((Rational) -&gt; Rational) 
//   which can be used just like any other function value
add_to_rational_1: (Rational) -&gt; Rational = rational_1.add; ...

// Note: add_to_rational_1(rational_2) == rational_1.add(rational_2)
</code></pre>
<h2 id="associated-functions-and-constants"><a class="header" href="#associated-functions-and-constants">Associated functions and constants</a></h2>
<p>Associated functions (aka <em>static methods</em>) and constants are just like regular functions or constants but are also namespaced by a type, for example <code>Rational::new(top, bottom)</code>.</p>
<h3 id="defining-associated-functions-and-constants"><a class="header" href="#defining-associated-functions-and-constants">Defining Associated functions and constants</a></h3>
<p>Associated functions are defined just like methods but without the <code>self</code> argument. Associated constants are simply <code>const</code> statements inside a <code>struct</code> or <code>enum</code> block:</p>
<pre><code class="language-rust  noplaypen">struct Rational {
    top: Int
    bottom: Int

	const PI = Rational{ 355, 113 }

	func new(top: Int, bottom: Int) -&gt; Rational {
		Rational { top: top, bottom: bottom }
	}
}
</code></pre>
<h3 id="using-associated-functions-and-constants"><a class="header" href="#using-associated-functions-and-constants">Using Associated functions and constants</a></h3>
<p>Associated functions and constants are <em>namespaced</em> by the type they are associated with
and can be referenced using a double colon (<code>::</code>) just like in Rust.
For example:</p>
<pre><code class="language-rust  noplaypen">half: Rational = Rational::new(1, 2); ...
</code></pre>
<h2 id="example-rational"><a class="header" href="#example-rational">Example: Rational</a></h2>
<pre><code class="language-ts">struct Rational {
    top: Int
    bottom: Int

    const PI = Rational{ top: 355, bottom: 113}

    func new(top: Int, bottom: Int) -&gt; Rational {
        Rational { top: top, bottom: bottom }
    }

    func add(self, rhs: Rational) -&gt; Rational {
        top: Int = (self.top * rhs.bottom) + (rhs.top * self.bottom);
        bottom: Int = self.bottom * rhs.bottom;

        Rational { top: top, bottom: bottom }
    }

}

const rational_1: Rational = Rational::new(1, 5) // 1/5 or 0.2
const rational_2: Rational = Rational::new(2, 5) // 2/5 or 0.4
const rational_3: Rational = rational_1.add(rational_2) // 15/25 or 3/5 or 0.6
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments-printing-and-branching"><a class="header" href="#comments-printing-and-branching">Comments, Printing, and Branching</a></h1>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>Helios comments are C-like. </p>
<p>Single-line comments use two forward slashes (<code>//</code>):</p>
<pre><code class="language-rust  noplaypen">// This is a comment.
</code></pre>
<p>Multi-line comments use <code>/* ... */</code>:</p>
<pre><code class="language-rust  noplaypen">/*
    This is a multi-line comment.
*/
</code></pre>
<h2 id="printing"><a class="header" href="#printing">Printing</a></h2>
<p>For debugging purposes, Helios has a special <code>print</code> expression. <code>print(...)</code> takes an expression that evaluates to a <code>String</code> as an argument, and must be followed by a semicolon and another expression:</p>
<pre><code class="language-rust  noplaypen">print(&quot;Imagine something cool.&quot;);
...
</code></pre>
<blockquote>
<p><strong>Note</strong>: Print expressions are useful when debugging scripts. They are however eliminated by the compiler when compiling scripts for production.</p>
</blockquote>
<h2 id="branching"><a class="header" href="#branching">Branching</a></h2>
<p>Helios has conventional <code>if/else</code> syntax for branching:</p>
<pre><code class="language-rust  noplaypen">if (tag == 0) {
    23
} else if (tag == 1) {
    42
} else {
	0
}
</code></pre>
<p>The last expression is each branch block is implicitly returned (much like Rust and Ruby). </p>
<p>The following is valid syntax:</p>
<pre><code class="language-rust  noplaypen">x: Int = 
	if (true) {
		42
	} else {
		24
	}; ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blockchain-programming-in-helios"><a class="header" href="#blockchain-programming-in-helios">Blockchain Programming in Helios</a></h1>
<p>Helios is a DSL (Domain Specific Language) made for <strong>blockchain development</strong> on the Cardano blockchain.
In the following chapters we will learn how to use Helios to write smart contracts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-the-eutxo-model"><a class="header" href="#understanding-the-eutxo-model">Understanding The eUTXO Model</a></h1>
<p>Before we get into any coding we need to first understand how smart contracts work on Cardano
and how it differs from the currently more popular Accounts-based model.</p>
<p>This section wouldn't be possible without <a href="https://dav009.medium.com/learning-ergo-101-blockchain-paradigm-eutxo-c90b0274cf5e">this</a> great blog post by the awesome <a href="https://github.com/dav009">David Pryzbilla</a> and a lot of helpful feedback from <a href="https://github.com/christianschmitz">Christian Schmitz</a>.</p>
<h2 id="accounts-model-vs-eutxo-model"><a class="header" href="#accounts-model-vs-eutxo-model">Accounts Model vs eUTXO Model</a></h2>
<p>Smart contracts on Cardano are quite different from those on Ethereum.</p>
<h3 id="ethereum-style-smart-contracts-accounts-based-model"><a class="header" href="#ethereum-style-smart-contracts-accounts-based-model">Ethereum-style Smart Contracts (Accounts-based Model)</a></h3>
<p>When a transaction occurs, the balance of one the sender's account is directly decremented and that of the recipient is incremented, similar to how conventional bank accounts work.</p>
<p>Contracts on Ethereum run via the EVM (Ethereum Virtual Machine), the EVM can be thought of as a global on-chain computer which smart contracts take turns running on, before their results are accepted on-chain.</p>
<blockquote>
<p><strong>Note</strong>: The data of all accounts on Ethereum are stored in a <a href="https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/"><strong>Merkle-Patricia Trie</strong></a>, which is kind of like a fancy hashmap.
After all the transactions in a block are run the <strong>root hash</strong> of the new Trie is included in the block.</p>
</blockquote>
<h2 id="the-eutxo-model"><a class="header" href="#the-eutxo-model">The eUTXO Model</a></h2>
<p>In the UTXO model tokens are stored in UTXOs (Unspent Transaction Outputs).
A UTXO is like (electronic)-cash where an individual bundle of bills (Ada and native-tokens) is stored separately.</p>
<p>In a transaction in the UTXO model, one or more UTXOs are used as inputs to the transaction and destroyed, <strong>Transaction Inputs</strong> and one or more UTXOs are created as the result/output of a transaction, <strong>Transaction Outputs</strong>.</p>
<p>Transactions in the accounts-based model mutate the data-points storing the total amounts (this is <strong>very risky</strong>; regular banks have special insurances and paper backups in case of mistakes, blockchains have no such fallbacks).
In the UTXO model only the &quot;bills&quot; that participate in a given transaction can potentially be lost (bad, but not catastrophic).</p>
<p>Of course a UTXO chain can emulate account-based models (for example the <a href="https://fuel.network">Fuel Rollup</a> uses UTXOs under the hood for parallel execution) and vice versa.</p>
<h3 id="components-of-a-utxo-on-cardano"><a class="header" href="#components-of-a-utxo-on-cardano">Components of a UTXO on Cardano</a></h3>
<p>On eUTXO blockchain the ledger is made up of many UTXOs (Unspent Transaction Outputs). A UTXO has four main components:</p>
<ul>
<li>An Address</li>
<li>Tokens (Native Assets)</li>
<li>A Validator Script</li>
<li>A Datum.</li>
</ul>
<h4 id="the-address"><a class="header" href="#the-address">The Address</a></h4>
<p>The address of a UTXO is used to determine who owns the UTXO (who has the right to spend it in a transaction).
To know the balance of a user wallets searches the ledger for all UTXOs <em>owned</em> by the user's address and their total value is the user's balance.</p>
<p>An address can be either be derived from the hash of a user's public key (<code>PubKeyHash</code> in Helios) or the hash of a validator script (<code>ValidatorHash</code>).</p>
<h4 id="datums"><a class="header" href="#datums">Datums</a></h4>
<p>These are data stored onchain associated with a particular UTXO.
The Datum is used to store state in Smart Contracts.
The 'e' in eUTXO comes from the Datum, this is because the addition of a datum makes the eUTXO model Turing-Complete (like Ethereum smart contracts and unlike Bitcoin Script).
With this state anything that an account-based model can do also be done with a eUTXO-based model.@hyperionbt/helios&quot;</p>
<blockquote>
<p><strong>Note</strong>: To be exact on Cardano previously the Datum couldn't be stored onchain but as of Plutus V2 we now have actual <em>onchain/inline</em> datums.</p>
</blockquote>
<h4 id="validators"><a class="header" href="#validators">Validators</a></h4>
<p>A validators is a function that runs when a transaction attempts to spend a UTXO.
It takes in the data of the transaction and returns a boolean which determines if the UTXO can be spent.
Validators contain the 'business logic' of a smart contract.</p>
<p>For example for a simple vesting contract one could lock up some tokens in a UTXO with a validator which returns <code>true</code> if the transaction is signed by the beneficiary.</p>
<blockquote>
<p><strong>Note</strong>: A UTXO can only be spent once. In every transaction some UTXOs are destroyed,
<strong>Transaction Inputs (TxInputs)</strong> and new UTXOs are created, <strong>Transaction Inputs (TxOutputs)</strong>.
For a transaction to be valid it must satisfy some things:</p>
<ul>
<li>The total amount of tokens in the <strong>Transaction Inputs</strong> must be equal to those in the <strong>Transaction Ouputs</strong>.</li>
<li>The validators for all the <strong>Transaction Inputs</strong> must evaluate to <code>true</code>.</li>
</ul>
</blockquote>
<h2 id="pros-and-cons-of-the-eutxo-model"><a class="header" href="#pros-and-cons-of-the-eutxo-model">Pros and Cons of the eUTXO Model</a></h2>
<h3 id="pros"><a class="header" href="#pros">Pros</a></h3>
<ul>
<li>
<h4 id="fixed-transaction-fees"><a class="header" href="#fixed-transaction-fees">Fixed Transaction Fees</a></h4>
<p>eUTXO contracts are deterministic this means that you can verify if a transaction will suceed and it's resource usage before posting it to the blockchain.
This is means the transaction fees for a transaction are fixed  and can be deterministically calculated offchain.
On Account-based blockchains transaction fees can vary <strong>a lot</strong>.</p>
</li>
<li>
<h4 id="easier-to-audit"><a class="header" href="#easier-to-audit">Easier to Audit</a></h4>
<p>The <strong>locally-scoped</strong> nature of eUTXO contracts reduces the potential attack surface by a lot.
This makes auditing way easier because you're auditing a <strong>the validation</strong> function and the space of possible outcomes is greatly reduced.</p>
</li>
<li>
<h4 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h4>
<p>If designed properly eUTXO smart contracts can be very parallel.</p>
</li>
<li>
<h4 id="better-for-layer-2s"><a class="header" href="#better-for-layer-2s">Better for Layer 2s</a></h4>
<p>The local nature of UTXOs lends itself well to building Layer 2 scaling solutions
such as sidechains(Milkomeda), state channels</p>
</li>
<li>
<h4 id="simpler"><a class="header" href="#simpler">Simpler</a></h4>
<p>Though not immediately obvious eUTXO smart contracts are often simpler than an equivalent Solidity smart contract.</p>
</li>
<li>
<h4 id="no-reentrancy-attacks"><a class="header" href="#no-reentrancy-attacks">No Reentrancy Attacks</a></h4>
<p>Reentrancy attacks such as the <a href="https://en.wikipedia.org/wiki/The_DAO_(organization)">DAO hack</a>.</p>
</li>
</ul>
<h3 id="cons"><a class="header" href="#cons">Cons</a></h3>
<ul>
<li>
<h4 id="contention"><a class="header" href="#contention">Contention</a></h4>
<p>If eUTXO contracts aren't designed properly they can encounter <em>contention</em>.
Contention occurs when two transaction try to spend the same UTXO,
this isn't possible and leads to UX issues like in the case of <a href="chapter_2/">Minswap in the past</a>.
This is not usually an issue on Ethereum as the EVM usually handles ordering smart contract calls.</p>
<blockquote>
<p><strong>Note</strong>: There are ways to take advantage of the avoid contention and take advantage of
the parallel nature of UTXOs instead of struggling with the such as SundaeSwap's <a href="chapter_2/">scooper model</a>.</p>
<p>These approaches usually use <em>offchain batching</em> to execute 'batches' of UTXOs in a single efficient transaction.
This can be done trustlessy as a UTXO can't be spent in a transaction unless it's validator is satisfied.</p>
</blockquote>
</li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>It's totally normal if you're still confused about eUTXO it's not immediately intuitive.
It is worth the extra effort in rewiring you're thinking as it often leads to contracts that are simpler and safer overall.</p>
<p>I advise you to read <a href="https://dav009.medium.com/learning-ergo-101-blockchain-paradigm-eutxo-c90b0274cf5e">this article</a> top even if you understand eUTXO, it's written for the Ergo blockchain but a lot of the concepts carry over into cardano.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validator-scripts"><a class="header" href="#validator-scripts">Validator Scripts</a></h1>
<p>In the previous chapter we learned that validators are functions that return a boolean (<code>true</code>  or <code>false</code>) when validating a transaction. In Helios validators are functions that take three arguments:</p>
<ul>
<li>The Redeemer: A piece of data attached to the transaction.</li>
<li>The Datum: Data stored onchain linked to the UTXO.</li>
<li>The ScriptContext: This is huge struct that holds data about the transaction spending the UTXO.</li>
</ul>
<p>The Redeemer and the Datum are user-defined but the <code>ScriptContext</code> struct is the same across all validators.</p>
<p>A simple validator</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>spending always_true        // -------- (1)

struct Datum {..}           // --------- (2)

enum Redeemer {..}          // --------- (3)
                            
// ------------- (4)
func main(datum: Datum, redeemer: Redeemer, ctx: ScriptContext) -&gt; Bool {
    ...
    true                     
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="script-purpose"><a class="header" href="#script-purpose">Script Purpose</a></h2>
<p>In Helios all scripts start with a  <strong>script purpose</strong>(1), followed by the name of the script. There are four script purposes currently:</p>
<ul>
<li><strong>spending</strong></li>
<li><strong>minting</strong>
<strong>staking</strong></li>
<li><strong>testing</strong></li>
</ul>
<p>In this chapter we are only concerned with the <code>spending</code> script purpose. We will cover the remaining three in later chapters.</p>
<pre><code class="language-rust  noplaypen">spending always_true
</code></pre>
<h2 id="the-main-function"><a class="header" href="#the-main-function">The Main Function</a></h2>
<p>The main function of a validator accepts three arguments and returns a <code>Bool</code>:</p>
<ul>
<li><strong>The Datum</strong> (2)</li>
<li><strong>The Redeemer</strong> (3)</li>
<li><strong>The ScriptContext</strong></li>
</ul>
<pre><code class="language-go  noplaypen">spending my_validator

func main(datum: Datum, redeemer: Redeemer, context: ScriptContext) -&gt; Bool {
    ...
}
</code></pre>
<p>Most of the data needed for writing useful validators is contained in the <code>ScriptContext</code>.
We will cover the <code>ScriptContext</code> in the next page.</p>
<blockquote>
<p><strong>Note</strong>: The Datum and the Redeemer are user-defined types (structs or enums) that <strong>must</strong> be named <code>Datum</code> and <code>Redeemer</code>.</p>
</blockquote>
<h2 id="alwaystrue-validator"><a class="header" href="#alwaystrue-validator">AlwaysTrue Validator</a></h2>
<p>This basic script allows UTXOs to be spent any way the user wants:</p>
<pre><code class="language-go  noplaypen">spending always_true

func main() -&gt; Bool {
    true
}
</code></pre>
<p>Unused arguments must be eliminated. In this case all three arguments of <code>main</code> function must be omitted (the compiler is smart enough to add them internally).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-scriptcontext"><a class="header" href="#the-scriptcontext">The ScriptContext</a></h1>
<p>The <code>ScriptContext</code> contains all the data about the transaction and is usually the most important argument in determining whether a <code>validator</code> should succeed or fail.
Because of how important it is we are going to try to go fairly deep into the internals in this chapter.</p>
<p>This is roughly the internal implementation of the <code>ScriptContext</code> struct.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ScriptContext {
    tx: Tx

    // Some useful methods

    // Get the ValidatorHash of the current script
    func get_current_validator_hash(self) -&gt; ByteArray

    // Get the TxInput locked by the validator.
    func get_current_input(self) -&gt; TxInput
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Note</strong>: Internally <code>ScriptContext</code> is a wrapper around the <code>Tx</code> struct,
the <code>Tx</code> holds the metadata of a signed on-chain transaction.</p>
</blockquote>
<h2 id="tx"><a class="header" href="#tx">Tx</a></h2>
<p>The <code>Tx</code> struct stores the data on the current transaction.</p>
<pre><code class="language-rust  noplaypen">struct Tx {
    inputs: []TxInput          // Transaction inputs
	ref_inputs: []TxInput      // Reference inputs that aren't spent
    outputs: []TxOutput        // Transaction outputs
    fee: Value                 // Fee paid for this transaction
    minted: Value              // Value minted by this transaction
    time_range: TimeRange      // Valid range for this transaction
    signatories: []PubKeyHash  // Signatories of the transaction
    id: TxId

    // Some useful methods

    func now(self) -&gt; Time

    func outputs_sent_to(self, addr: PubKeyHash) -&gt; []TxOutput

    func value_sent_to(self, addr: PubKeyHash) -&gt; Value

	// Use datum tagging to prevent double satisfaction exploits
    func value_sent_to_datum(self, addr: PubKeyHash, datum: Any) -&gt; Value

    func value_locked_by(self, val_hash: ValidatorHash) -&gt; Value

    func value_locked_by_datum(self, val_hash: ValidatorHash, datum: Any) -&gt; Value

    // Checks if a given PubKeyHash is in tx.signatories
    func is_signed_by(self, pk: PubKeyHash) -&gt; Bool;
}

</code></pre>
<h2 id="txinput"><a class="header" href="#txinput">TxInput</a></h2>
<p>The <code>TxInput</code> struct as you've probably guessed represents a <strong>Transaction Input</strong>.
As you can see a <strong>Transaction Input</strong> is just a wrapper around UTXO created by a previous transaction on the blockchain.</p>
<pre><code class="language-rust  noplaypen">struct TxInput {
    output_id: TxOutputId // ID of the UTXO
    output: TxOutput      // UTXO being spent
}
</code></pre>
<h2 id="txoutput"><a class="header" href="#txoutput">TxOutput</a></h2>
<p>The <code>TxOutput</code> represents a <strong>Transaction Output</strong>. This is a <strong>UTXO</strong> that will be created by this transaction.</p>
<pre><code class="language-rust  noplaypen">struct TxOutput {
    address: Address          // Address of the UTXO
    value: Value              // Value in the UTXO
    datum:  OutputDatum       // UTXO's datum (none, hash, or inline)
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: For more info on the <code>Address</code> and <code>Value</code> types check out <a href="chapter_2/../helios_builtins/Helios_Builtins.html">Helios Builtins</a> .</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vesting-contract"><a class="header" href="#vesting-contract">Vesting Contract</a></h1>
<p>To put what we've done so far to use we're going to build a simple 'vesting' contract.
This contract will lock up some tokens owned by an <strong>owner</strong>
for a <strong>beneficiary</strong> that can't be claimed until after a <strong>deadline</strong>.
The <strong>owner</strong> can get their funds back if the <strong>deadline</strong> has not passed yet</p>
<h2 id="the-datum"><a class="header" href="#the-datum">The Datum</a></h2>
<p>The Datum stores the <code>PubKeyHash</code> of the <strong>beneficiary</strong> and <strong>creator</strong>'s wallets and the vesting deadline is represented as a <code>Time</code>.</p>
<pre><code class="language-rust  noplaypen">struct Datum {
    creator: PubKeyHash
    beneficiary: PubKeyHash
    deadline: Time
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: The <code>Time</code> type represents a POSIX time and
for more info <a href="chapter_2/../helios_builtins/Helios_Builtins.html">Helios Builtins</a>.</p>
</blockquote>
<h2 id="the-redeemer"><a class="header" href="#the-redeemer">The Redeemer</a></h2>
<pre><code class="language-rust  noplaypen">enum Redeemer {
    Cancel
    Claim
}
</code></pre>
<p>There are two cases when the validator should return <code>true</code>:</p>
<ul>
<li>
<p><strong>Cancel</strong></p>
<p>In this case, the 'owner' wishes to cancel the contract and get back their funds.
For a 'Cancel' to succeed the following have to be checked</p>
<ul>
<li>The owner signed the transaction.</li>
<li>The deadline hasn't passed.</li>
</ul>
</li>
<li>
<p><strong>Vesting Claim</strong></p>
<p>A 'Claim' occurs when the 'beneficiary' wishes to claim the tokens vested for them.
For it to be valid the following have to be checked:</p>
<ul>
<li>The beneficiary signed the transaction.</li>
<li>The deadline has passed.</li>
</ul>
</li>
</ul>
<h2 id="the-main-function-1"><a class="header" href="#the-main-function-1">The Main Function</a></h2>
<pre><code class="language-go  noplaypen">func main(datum: Datum, redeemer: Redeemer, context: ScriptContext) -&gt; Bool {
    tx: Tx = context.tx;
    now: TimeRange = tx.now();

    redeemer.switch {
        Cancel =&gt; {
            // Check that deadline hasn't passed
            now &lt; datum.deadline &amp;&amp; 

            // Check that the owner signed the transaction
            tx.is_signed_by(datum.creator)
        },
        Claim =&gt; {
           // Check that deadline has passed.
           now &gt; datum.deadline &amp;&amp;

           // Check that the beneficiary signed the transaction.
           tx.is_signed_by(datum.beneficiary)
        }
    }
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: A <code>TimeRange</code> represents a <em>range</em> of time using a pair of <code>Time</code> values.
for more info <a href="chapter_2/../helios_builtins/Helios_Builtins.html">Helios Builtins</a>.</p>
</blockquote>
<blockquote>
<p><strong>P.S.</strong>: There is a <em>possible</em> security vulnerability in this contract that we will examine in a later chapter.
See if  you can find it .</p>
</blockquote>
<h2 id="finished-code"><a class="header" href="#finished-code">Finished Code</a></h2>
<pre><code class="language-go  noplaypen">spending vesting

struct Datum {
    creator: PubKeyHash
    beneficiary: PubKeyHash
    deadline: Time
}

enum Redeemer {
    Cancel
    Claim
}

func main(datum: Datum, redeemer: Redeemer, context: ScriptContext) -&gt; Bool {
    tx: Tx = context.tx;
    now: Time = tx.now();

    redeemer.switch {
        Cancel =&gt; {
            now &gt; datum.deadline &amp;&amp;
            tx.is_signed_by(datum.creator)
        },
        Claim =&gt; {
           now &gt; datum.deadline &amp;&amp;
           tx.is_signed_by(datum.beneficiary)
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="english-auction"><a class="header" href="#english-auction">English Auction</a></h1>
<p>In this example, we will rewrite the <a href="https://plutus-pioneer-program.readthedocs.io/en/latest/pioneer/week1.html">English Auction contract</a>
from the Plutus Pioneer's program in Helios.</p>
<p>This validator is can be used to lock assets that are to be auctioned in a UTXO.</p>
<h2 id="the-datum-1"><a class="header" href="#the-datum-1">The Datum</a></h2>
<pre><code class="language-go">spending english_auction

struct Datum {
    seller: PubKeyHash
    bid_asset: AssetClass       // allow alternative assets (not just lovelace)
    min_bid: Int
    deadline: Time
    for_sale: Value             // the asset that is being auctioned
    highest_bid: Int            // initialized at 0, which signifies the auction doesn't yet have valid bids
    highest_bidder: PubKeyHash

    func update(self, highest_bid: Int, highest_bidder: PubKeyHash) -&gt; Datum {
        Datum {
            seller: self.seller,
            bid_asset: self.bid_asset,
            min_bid: self.min_bid,
            deadline: self.deadline,
            for_sale: self.for_sale,
            highest_bid: highest_bid,
            highest_bidder: highest_bidder
        }
    }
}

enum Redeemer {
    Close 
    Bid { bidder: PubKeyHash, bid: Int }
}

func main(datum: Datum, redeemer: Redeemer, ctx: ScriptContext) -&gt; Bool {
    tx: Tx = ctx.tx;

    now: Time = tx.now();

    validator_hash: ValidatorHash = ctx.current_validator_hash();

    redeemer.switch {
        Close =&gt; {
            if (datum.highest_bid &lt; datum.min_bid) {
                // the forSale asset must return to the seller, what happens to any erroneous bid value is irrelevant
                tx
                  .value_sent_to(datum.seller)
                  .contains(datum.for_sale + datum.highest_bid) &amp;&amp;
                // Check that the deadline has passed
                now &gt; datum.deadline                                    
            } else {
                // Check that the seller receives the highest bid
                tx
                  .value_sent_to(datum.seller)
                  .contains(Value::new(datum.bid_asset, datum.highest_bid))    &amp;&amp;
                // Check that highest bidder is given the token being auctioned
                tx
                  .value_sent_to(datum.highest_bidder)
                  .contains(datum.for_sale)                                    &amp;&amp;
                // Check that the deadline has passed
                now &gt; datum.deadline                                    
            }
        },
        b: Bid =&gt; {
            if (b.bid &lt; datum.min_bid) {
                false
            } else if (b.bid &lt;= datum.highest_bid) {
                false
            } else {
                // first bid is placed by the auction creator
                expected_datum: Datum = datum.update(b.bid, b.bidder);

                // Check that new Auction UTXO contains the token for sale and the new bid
                tx
                  .value_locked_by_datum(validator_hash, expected_datum)
                  .contains(datum.for_sale + Value::new(datum.bid_asset, b.bid)) &amp;&amp;
                // Check that the old highest bidder is repayed
                tx
                  .value_sent_to(datum.highest_bidder)
                  .contains(Value::new(datum.bid_asset, datum.highest_bid))      &amp;&amp;
                // Check that the deadline hasn't passed
                now &lt; datum.deadline
            }
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="native-assets"><a class="header" href="#native-assets">Native Assets</a></h1>
<p>One of Cardano's best features is <strong>Native Multi-Asset(NMA)</strong>.
It's a bit of a mouthful but what this means is that on Cardano
user-defined tokens have the same treatment as the native coin (ADA).</p>
<p>This might not seem like a big deal but this offers serious advantages
over Ethereum tokens (ERC-20 and ERC-721). But to understand the benefits
you have to understand how user-defined tokens work on non-UTXO blockchains.</p>
<h2 id="erc-20-standard"><a class="header" href="#erc-20-standard">ERC-20 Standard</a></h2>
<p>On Ethereum, tokens are defined using the <a href="https://ethereum.org/en/developers/docs/standards/tokens/erc-20/">ERC-20 standard</a>.
In this standard tokens are managed by a contract that stores all of the token's metadata
and all user balances in a <code>mapping</code> (hashmap) called <code>_balances</code>.
All transfers of an ERC-20 token are function calls to the contract to modify the <code>_balances</code>.</p>
<p>Any error in the implementation of the ERC-20 standard can lead to the loss of user funds.</p>
<h2 id="utxo-native-assets"><a class="header" href="#utxo-native-assets">UTXO Native Assets</a></h2>
<p>On Cardano and other eUTXO blockchains user-defined tokens are <em>first-class</em>.
Tokens on Cardano are stored in <strong>Token Bundles</strong> which can contain
ADA and any native asset.
This allows Cardano to do in one transaction what would normally take multiple
contract calls on Ethereum.</p>
<blockquote>
<p><strong>Note</strong>: A <strong>Token Bundle</strong> must contain a minimum amount of ADA
at the time of this writing this is 1 ADA.</p>
</blockquote>
<h3 id="minting-policies"><a class="header" href="#minting-policies">Minting Policies</a></h3>
<p>Minting policies are a lot like validator scripts, they run when a transaction
attempts to mint a token and return a boolean that determines whether the minting is valid.</p>
<p>There are a few key differences:</p>
<ul>
<li>Minting policies are not directly linked to any UTXO
they are included in the minting transaction directly.</li>
<li>Minting policies take two arguments (the <code>ScriptContext</code> and the <code>Redeemer</code>)
they have no UTXO and therefore no Datum and don't need
a Redeemer.</li>
</ul>
<h3 id="assetclass"><a class="header" href="#assetclass">AssetClass</a></h3>
<p>Native assets are identified by their <code>AssetClass</code> this is a combination of:</p>
<ul>
<li>
<p>a <strong><code>MintingPolicyHash</code></strong>: the hash of the minting policy of the token. Sometimes referred to as the CurrencySymbol or the PolicyID.</p>
</li>
<li>
<p>a <strong><code>TokenName</code></strong>: this is an (immutable) property of an asset that is used to distinguish different assets within the same policy (e.g. minting multiple NFTs using the same minting policy)</p>
</li>
</ul>
<pre><code class="language-rust  noplaypen">struct AssetClass {
    ...

    // ADA's assetclass
    const ADA: AssetClass

    // Constructor
    func new(policy_hash: ByteArray, token_name: ByteArray) -&gt; AssetClass;
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> The MintingPolicyHash of ADA is an empty <code>ByteArray</code> (<code>#</code>) since nothing can hash
to an empty string ADA is the only token that can't be minted using a minting policy.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="value"><a class="header" href="#value">Value</a></h1>
<p><code>Value</code> represents a <em>token bundle</em>, where each entry is represented by an <code>AssetClass</code> and an integer amount. <code>AssetClass</code> is turn represents a pair of <code>MintingPolicyHash</code> (a.k.a. PolicyID) and token name.</p>
<pre><code class="language-go  noplaypen">// Value is opaque (it's internals aren't directly accessible from Helios)
struct Value {
    ...

    // A constant representing an empty Value.
    const ZERO: Value

    // Instantiates a Value of a given AssetClass and Amount.
    func new(asset_class: AssetClass, amount: Int) -&gt; Value

    // Constructs a Value containing 'amount' number of lovelaces.
    func lovelace(amount: Int) -&gt; Value

    // Checks if a Value is empty.
    func is_zero(self) -&gt; Bool

    // Gets the amount of a specific AssetClass contained in a Value.
	// @notice Throws an error if asset_class isn't found
    func get(self, asset_class: AssetClass) -&gt; Int

    // Returns 'true' if self contains other_value.
    func contains(self, other_value: Value) -&gt; Bool
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: 1 ADA is equal to 1 million Lovelace</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: You might find yourself comparing the output of <code>value.get()</code> to a number in order to check if <code>value</code> contains something, but in that case it usually better to use the <code>value.contains()</code> method instead.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signed-policy"><a class="header" href="#signed-policy">Signed Policy</a></h1>
<p>This example shows a simple minting policy that allows minting tokens as long as
the transaction is signed by an <strong>owner</strong>. The <strong>owner</strong> has a given <code>PubKeyHash</code>.</p>
<pre><code class="language-go  noplaypen">minting signed

const OWNER: PubKeyHash = PubKeyHash::new(#26372...)

func main(ctx: ScriptContext) -&gt; Bool {
    ctx.tx.is_signed_by(OWNER)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-nft"><a class="header" href="#simple-nft">Simple NFT</a></h1>
<p>NFTs (Non-Fungible tokens) are simply tokens with a quantity of 1.
To make an NFT the minting policy must make sure that it can only be used once and that only one token can ever be minted.
The <strong>Token Name</strong> for the NFT in this example will be called <code>example_nft</code>.</p>
<p>There are two ways to do this on Cardano:</p>
<ul>
<li>Deadline-based Approach</li>
<li>UTXO-based Approach</li>
</ul>
<h2 id="deadline-based-approach"><a class="header" href="#deadline-based-approach">Deadline-based Approach</a></h2>
<p>NFTs were available on Cardano before smart contracts (Mary Hardfork) and they were implemented using deadlines.
The main idea is that the token can only be minted before a deadline which already passed.
This ensures no new tokens will ever be minted.
This is very easy to implement:</p>
<pre><code class="language-go  noplaypen">minting deadline_nft

const DEADLINE: Time = Time::new(1661665196132) // milliseconds since 1970


func main(ctx: ScriptContext) -&gt; Bool {
	tx: Tx = ctx.tx;

    nft_assetclass: AssetClass = AssetClass::new(
		ctx.get_current_minting_policy(), 
		&quot;example-nft&quot;.encode_utf8()
	);

    value_minted: Value = tx.minted;

    value_minted == Value::new(nft_assetclass, 1) &amp;&amp; tx.now() &lt; DEADLINE
}
</code></pre>
<h2 id="utxo-based-approach"><a class="header" href="#utxo-based-approach">UTXO-Based Approach</a></h2>
<p>This method is based on an <a href="https://plutus-pioneer-program.readthedocs.io/en/latest/pioneer/week5.html">example</a> in the Plutus Pioneer Program.
This approach takes advantage of the fact that all UTXOs have a unique <code>TxOutputId</code>.
A UTXO's <code>TxOutputId</code> is made up of the transaction hash of the transaction that made the UTXO and the index of the UTXO in the outputs of that transaction.
It's a builtin type that is defined as:</p>
<pre><code class="language-go  noplaypen">struct TxOutputId {
    tx_id: TxId
    index: Int
}
</code></pre>
<p>So with this approach, we specify in the minting policy that the transaction minting the NFT must spend a UTXO with a specific <strong>Output ID</strong>.
Since a UTXO can only be spent once this means the token can only be minted once.</p>
<pre><code class="language-go  noplaypen">minting utxo_nft

const OUTPUT_ID: TxOutputId = TxOutputId::new(TxId::new(#1213), 1)

func main(ctx: ScriptContext) -&gt; Bool {
	tx: Tx = ctx.tx;

    nft_assetclass: AssetClass = AssetClass::new(
		ctx.get_current_minting_policy(), 
		&quot;example-nft&quot;.encode_utf8()
	);

    value_minted: Value = tx.minted;

    value_minted == Value::new(nft_assetclass, 1) &amp;&amp; 
    tx.inputs
        .any((input: TxInput) -&gt; Bool {input.output_id == OUTPUT_ID})

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="helios-builtins"><a class="header" href="#helios-builtins">Helios Builtins</a></h1>
<p>This book is also meant to be a guide to the internals of Helios for Helios developers and other compiler implementations of Helios in the future.</p>
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<ul>
<li><a href="helios_builtins/./primitive_types.html">Primitive Types</a></li>
<li><a href="helios_builtins/./time_types.html">Time Types</a></li>
<li><a href="helios_builtins/./cryptography_types.html">Cryptography Types</a></li>
<li><a href="helios_builtins/./native-asset_types.html">Native-Asset Types</a></li>
<li><a href="helios_builtins/./transaction_types.html">Transaction Types</a></li>
</ul>
<h2 id="helios-operators"><a class="header" href="#helios-operators">Helios Operators</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Operator</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>==</code></td></tr>
<tr><td style="text-align: left"><code>!=</code></td></tr>
<tr><td style="text-align: left"><code>&gt;</code></td></tr>
<tr><td style="text-align: left"><code>&gt;=</code></td></tr>
<tr><td style="text-align: left"><code>&lt;</code></td></tr>
<tr><td style="text-align: left"><code>&lt;=</code></td></tr>
<tr><td style="text-align: left"><code>!</code></td></tr>
<tr><td style="text-align: left"><code>&amp;&amp;</code></td></tr>
<tr><td style="text-align: left">`</td></tr>
<tr><td style="text-align: left"><code>+</code></td></tr>
<tr><td style="text-align: left"><code>-</code></td></tr>
<tr><td style="text-align: left"><code>*</code></td></tr>
<tr><td style="text-align: left"><code>/</code></td></tr>
<tr><td style="text-align: left"><code>%</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h1>
<p>Helios has six (6) primitive types.</p>
<h2 id="int-1"><a class="header" href="#int-1">Int</a></h2>
<hr />
<p>This is an unbounded integer like Haskell's <code>Integer</code> type.</p>
<h3 id="operators"><a class="header" href="#operators">Operators</a></h3>
<p><code>==</code>, <code>!=</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&gt;=</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&lt;</code></p>
<h3 id="associated-functions"><a class="header" href="#associated-functions">Associated functions</a></h3>
<pre><code class="language-go  noplaypen">func from_data(data: Data) -&gt; Int
</code></pre>
<h3 id="methods-1"><a class="header" href="#methods-1">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self) -&gt; ByteArray

func to_bool(self) -&gt; Bool

func to_hex(self) -&gt; String

func show(self) -&gt; String
</code></pre>
<h2 id="bool-1"><a class="header" href="#bool-1">Bool</a></h2>
<hr />
<p>Represents a boolean value (<code>true</code>/<code>false</code>).</p>
<pre><code class="language-go  noplaypen">true_val: Bool = true;
false_val: Bool = false; ...
</code></pre>
<h3 id="associated-functions-1"><a class="header" href="#associated-functions-1">Associated Functions</a></h3>
<pre><code class="language-go  noplaypen">func and(fn_bool_1: () -&gt; Bool, fn_bool_2: () -&gt; Bool) -&gt; Bool

func or(fn_bool_1: () -&gt; Bool, fn_bool_2: () -&gt; Bool) -&gt; Bool

func from_data(data: Data) -&gt; Bool
</code></pre>
<h3 id="operators-1"><a class="header" href="#operators-1">Operators</a></h3>
<p><code>==</code>, <code>!=</code>, <code>!</code>, <code>&amp;&amp;</code>, <code>||</code></p>
<h3 id="methods-2"><a class="header" href="#methods-2">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self) -&gt; ByteArray

func to_int(self) -&gt; Int

func show(self) -&gt; String
</code></pre>
<h2 id="string-1"><a class="header" href="#string-1">String</a></h2>
<hr />
<p>This is a fixed-size string.</p>
<pre><code class="language-rust  noplaypen">example: String = &quot;Woah!&quot;; ...
</code></pre>
<h3 id="operators-2"><a class="header" href="#operators-2">Operators</a></h3>
<p><code>==</code>, <code>!=</code>,<code>+</code></p>
<h3 id="associated-functions-2"><a class="header" href="#associated-functions-2">Associated functions</a></h3>
<pre><code class="language-go  noplaypen">func from_data(data: Data) -&gt; String
</code></pre>
<h3 id="methods-3"><a class="header" href="#methods-3">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self) -&gt; ByteArray

func encode_utf8(self) -&gt; String

func starts_with(self, prefix: String) -&gt; Bool

func ends_with(self, suffix: String) -&gt; Bool
</code></pre>
<h2 id="bytearray-1"><a class="header" href="#bytearray-1">ByteArray</a></h2>
<hr />
<p>This represents an array of bytes.</p>
<pre><code class="language-rust  noplaypen">example: ByteArray = #213212; ...
</code></pre>
<h3 id="operators-3"><a class="header" href="#operators-3">Operators</a></h3>
<p><code>==</code>, <code>!=</code>, <code>+</code></p>
<h3 id="associated-functions-3"><a class="header" href="#associated-functions-3">Associated functions</a></h3>
<pre><code class="language-go  noplaypen">func from_data(data: Data) -&gt; ByteArray
</code></pre>
<h3 id="getters"><a class="header" href="#getters">Getters</a></h3>
<p><code>length: Int</code>, returns the length of the <code>ByteArray</code>.</p>
<h3 id="methods-4"><a class="header" href="#methods-4">Methods:</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self) -&gt; ByteArray

// @returns The SHA2-256 hash of the ByteArray
func sha2(self) -&gt; ByteArray

// @returns The SHA3-256 hash of the ByteArray
func sha3(self) -&gt; ByteArray

// @returns The Blake2b256 hash of the ByteArray
func blake2b(self) -&gt; ByteArray

func decode_utf8(self) -&gt; String

func show(self) -&gt; String

func starts_with(self, prefix: ByteArray) -&gt; Bool

func ends_with(self, suffix: ByteArray) -&gt; Bool

func slice(self, start: Int, end: Int) -&gt; ByteArray
</code></pre>
<h2 id="list-a"><a class="header" href="#list-a">List (<code>[]a</code>)</a></h2>
<hr />
<p>Helios linked-list type.</p>
<pre><code class="language-go  playpen">example: []Int = []Int{1, 2, 3, 4, 5}; ...
</code></pre>
<h3 id="associated-functions-4"><a class="header" href="#associated-functions-4">Associated Functions</a></h3>
<pre><code class="language-go  noplaypen">func from_data(data: Data) -&gt; []a

func new(n: Int, fn: (Int) -&gt; a) -&gt; []a

func new_const(n: Int, item: a) -&gt; []a
</code></pre>
<h3 id="operators-4"><a class="header" href="#operators-4">Operators</a></h3>
<p><code>==</code>, <code>!=</code>, <code>+</code></p>
<h3 id="getters-1"><a class="header" href="#getters-1">Getters</a></h3>
<pre><code class="language-go  noplaypen">// @returns The length of the list.
length: Int

// @returns The element at the front of the list
// @notice Throws an error if the list is empty.
head: a

// @returns The element at the end of the list.
// @notice Throws an error if the list is empty.
tail: []a
</code></pre>
<h3 id="methods-5"><a class="header" href="#methods-5">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self) -&gt; ByteArray

// @returns 'true' if the list is empty.
func is_empty(self) -&gt; Bool

// @returns The element the index in the list.
// @notice Throws an error if the list is too short.
func get(self, index: Int) -&gt; a

// @returns A new list with the item prepended at the front of the list.
func prepend(self, item: a) -&gt; []a

// @return 'true' if any of the items in the list satisfy the predicate.
func any(self, predicate: (a) -&gt; Bool) -&gt; Bool

// @return 'true' if all of the items in the list satisfy the predicate.
func all(self, predicate: (a) -&gt; Bool) -&gt; Bool

// @return The first element in the list that satisfies the predicate.
// @notice Throws an error is no element satisfies the predicate.
func find(self, predicate: (a) -&gt; Bool) -&gt; a

// @returns A list of all the elements in the list that satisfy the predicate.
func filter(self, predicate: (a) -&gt; Bool) -&gt; []a

// @returns Folds a list into a single value by continuosly applying the binary
//         function to the elements of the list.
func fold(self, reducer: (b, a) -&gt; b, init: b) -&gt; b

// @returns The original list list with the transformation function called on
//          all it's elements.
func map(self, transformation: (a) -&gt; b) -&gt; []b
</code></pre>
<h2 id="map-mapab"><a class="header" href="#map-mapab">Map (<code>Map[a]b</code>)</a></h2>
<hr />
<p>List of key-value pairs.</p>
<pre><code class="language-go  noplaypen">my_map = Map[String]Int{&quot;zero&quot;: 0, &quot;one&quot;: 1, &quot;two&quot;: 2};
print(my_map.get(&quot;zero&quot;).show()); ... // prints '0'
</code></pre>
<h3 id="associated-functions-5"><a class="header" href="#associated-functions-5">Associated Functions</a></h3>
<pre><code class="language-go  noplaypen">func from_data(data: Data) -&gt; Map[a]b
</code></pre>
<h3 id="operators-5"><a class="header" href="#operators-5">Operators</a></h3>
<p><code>==</code>,<code>!=</code>, <code>+</code></p>
<h3 id="getters-2"><a class="header" href="#getters-2">Getters</a></h3>
<pre><code class="language-go  noplaypen">// @returns the number of items in a map.
length: Int
</code></pre>
<h3 id="methods-6"><a class="header" href="#methods-6">Methods</a></h3>
<pre><code class="language-go  noplaypen">// @returns The Value in the map for the given key.
// @notice  Throws an error if the value isn't in the map.
func get(self, key: a) -&gt; b

func get_safe(self, key: a) -&gt; Option[b]

// @returns 'true' if all the pairs satisfy the predicate.
func all(self, predicate: (a, b) -&gt; Bool) -&gt; Bool

func all_keys(self, predicate: (a) -&gt; Bool) -&gt; Bool

func all_values(self, predicate: (b) -&gt; Bool) -&gt; Bool

// @returns 'true' if all the pairs satisfy the predicate.
func any(self, predicate: (a, b) -&gt; Bool) -&gt; Bool

func any_key(self, predicate: (a) -&gt; Bool) -&gt; Bool

func any_value(self, predicate: (b) -&gt; Bool) -&gt; Bool

func filter(self, predicate: (a, b) -&gt; Bool) -&gt; Map[a]b

func filter_by_key(self, predicate: (a) -&gt; Bool) -&gt; Map[a]b

func filter_by_value(self, predicate: (b) -&gt; Bool) -&gt; Map[a]b

func fold(self, reducer: (c, a, b) -&gt; c, init: c) -&gt; c

func fold_keys(self, reducer: (c, a) -&gt; c, init: c) -&gt; c

func fold_values(self, reducer: (c, b) -&gt; c, init: c) -&gt; c

func serialize(self: Map[a, b]) -&gt; ByteArray
</code></pre>
<h2 id="option-optiona"><a class="header" href="#option-optiona">Option (<code>Option[a]</code>)</a></h2>
<hr />
<p><code>Option[a]</code> is an enum used to represent an optional value.</p>
<pre><code class="language-rust  noplaypen">// internal representation
enum Option[a] {
    Some { some: a }
    None
}

example_1: Option[Int] = Option[Int]::Some{42};
example_2: Option[Int] = Option[Int]::None; ...
</code></pre>
<h3 id="associated-functions-6"><a class="header" href="#associated-functions-6">Associated Functions</a></h3>
<pre><code class="language-go  noplaypen">func from_data(data: Data) -&gt; Option[a]
</code></pre>
<h3 id="operators-6"><a class="header" href="#operators-6">Operators</a></h3>
<p><code>==</code>, <code>!=</code></p>
<h3 id="getters-3"><a class="header" href="#getters-3">Getters</a></h3>
<pre><code class="language-go  noplaypen">// @returns content of Option[a]::Some
Option[a]::Some.some: a
</code></pre>
<h3 id="methods-7"><a class="header" href="#methods-7">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self) -&gt; ByteArray
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time-types"><a class="header" href="#time-types">Time Types</a></h1>
<h2 id="time"><a class="header" href="#time">Time</a></h2>
<hr />
<p>Represents POSIX time in milliseconds (time since 1970/01/01 00:00:00 UTC).</p>
<h3 id="associated-functions-7"><a class="header" href="#associated-functions-7">Associated Functions</a></h3>
<pre><code class="language-go  noplaypen">func new(millis: Int) -&gt; Time

func from_data(data: Data) -&gt; Time
</code></pre>
<h3 id="operators-7"><a class="header" href="#operators-7">Operators</a></h3>
<p><code>==</code>, <code>!=</code>, <code>+</code>, <code>-</code>, <code>&gt;=</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&lt;</code></p>
<h3 id="methods-8"><a class="header" href="#methods-8">Methods</a></h3>
<pre><code class="language-rust  noplaypen">func show(self) -&gt; String

func serialize(self) -&gt; ByteArray
</code></pre>
<h2 id="duration"><a class="header" href="#duration">Duration</a></h2>
<hr />
<p>The difference of two <code>Time</code> values is a <code>Duration</code> value. Only a <code>Duration</code> can be added to a <code>Time</code> (two <code>Time</code> values can't be added).</p>
<h3 id="associated-functions-8"><a class="header" href="#associated-functions-8">Associated Functions</a></h3>
<pre><code class="language-go  noplaypen">func new(raw: Int) -&gt; Duration

func from_data(data: Int) -&gt; Duration
</code></pre>
<h3 id="operators-8"><a class="header" href="#operators-8">Operators</a></h3>
<p><code>==</code>, <code>!=</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&gt;=</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&lt;</code></p>
<h3 id="methods-9"><a class="header" href="#methods-9">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self: Time) -&gt; ByteArray
</code></pre>
<h2 id="timerange"><a class="header" href="#timerange">TimeRange</a></h2>
<hr />
<p>This represents a range of time using a pair of <code>Time</code> values, or open ends.</p>
<h3 id="associated-functions-and-constants-1"><a class="header" href="#associated-functions-and-constants-1">Associated functions and constants</a></h3>
<pre><code class="language-go  noplaypen">// Represents TimeRange starting from negative to positive infinity.
// It contains all possible Time values.
const ALWAYS: TimeRange

// Represents TimeRange starting from positive to negative infinity.
// It contains nothing as it's impossible.
const NEVER: TimeRange

// @returns A TimeRange that contains all Time values from 'start' onwards.
func from(start: Time) -&gt; TimeRange

// @returns A TimeRange that contains all Time values before 'start' up to 'start'.
func to(end: Time) -&gt; TimeRange

func new(start: Time, end: Time) -&gt; TimeRange

func from_data(data: Data) -&gt; TimeRange
</code></pre>
<h3 id="operators-9"><a class="header" href="#operators-9">Operators</a></h3>
<p><code>==</code>,<code>!=</code></p>
<h3 id="methods-10"><a class="header" href="#methods-10">Methods</a></h3>
<pre><code class="language-go  noplaypen">// @returns The start of TimeRange.
// @notice Throws an error if start is negative or positive infinity
func get_start(self) -&gt; Time

// @returns 'true' if self contains the 'time'
func contains(self, time: Time) -&gt; Bool

// @returns 'true' if the end of 'self' is before 'time'
// @notice Always returns 'false' if end of 'self' is positive infinity
func is_before(self, time: Time) -&gt; Bool

// @returns 'true' if the start of 'self' is after 'time'
// @notice Always returns 'false' if start of 'self' is negative infinity
func is_after(self, time: Time) -&gt; Bool

func serialize(self) -&gt; ByteArray
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cryptography-types"><a class="header" href="#cryptography-types">Cryptography Types</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="native-asset-types"><a class="header" href="#native-asset-types">Native-Asset Types</a></h1>
<p>Helios uses the <code>AssetClass</code> and <code>Value</code> types to represent Cardano Native-Assets.</p>
<h2 id="assetclass-1"><a class="header" href="#assetclass-1">AssetClass</a></h2>
<hr />
<p>Represents a unique token on the blockchain using the hash of it's minting policy and it's token name.</p>
<pre><code class="language-rust  noplaypen">// internal representation
struct AssetClass {
    MintingPolicyHash // not directly accessible
    ByteArray // not directly accessible
}
</code></pre>
<h3 id="associated-functions-and-constants-2"><a class="header" href="#associated-functions-and-constants-2">Associated functions and constants</a></h3>
<pre><code class="language-rust  noplaypen">const ADA: AssetClass

// @returns a new AssetClass
func new(policy_hash: MintingPolicyHash, token_name: ByteArray) -&gt; AssetClass

func from_data(data: Data) -&gt; AssetClass
</code></pre>
<h3 id="operators-10"><a class="header" href="#operators-10">Operators</a></h3>
<p><code>==</code>,<code>!=</code></p>
<h3 id="methods-11"><a class="header" href="#methods-11">Methods</a></h3>
<pre><code class="language-rust  noplaypen">func serialize(self) -&gt; ByteArray
</code></pre>
<h2 id="value-1"><a class="header" href="#value-1">Value</a></h2>
<hr />
<p>The <code>Value</code> type represents a <strong>token bundle</strong> using a map of <code>AssetClass</code>es to <code>Int</code> quantities,</p>
<pre><code class="language-rust  noplaypen">struct Value {..}
</code></pre>
<h3 id="associated-functions-and-constants-3"><a class="header" href="#associated-functions-and-constants-3">Associated functions and constants</a></h3>
<pre><code class="language-go  noplaypen">// An empty Value
const ZERO: Value

// @returns A Value containing 'amount' number of lovelaces.
func lovelace(amount: Int) -&gt; Value

// @returns A Value containing 'amount' number of the given 'asset_class'
func new(asset_class: AssetClass, amount: Int) -&gt; Value
</code></pre>
<h3 id="operators-11"><a class="header" href="#operators-11">Operators</a></h3>
<p><code>==</code>, <code>!=</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>&gt;=</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&lt;</code></p>
<h3 id="methods-12"><a class="header" href="#methods-12">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self) -&gt; ByteArray

func is_zero(self) -&gt; Bool

// @notice Throws error if asset_class isn't found
func get(self, asset_class: AssetClass) -&gt; Int

// @returns A map of tokenName -&gt; quantity
func get_policy(self, mph: MintingPolicyHash) -&gt; Map[ByteArray]Int

func contains(self, other_value: Value) -&gt; Bool
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="helios-builtins-1"><a class="header" href="#helios-builtins-1">Helios Builtins</a></h1>
<h2 id="pubkeyhash-validatorhash-mintingpolicyhash-datumhash"><a class="header" href="#pubkeyhash-validatorhash-mintingpolicyhash-datumhash">PubKeyHash, ValidatorHash, MintingPolicyHash, DatumHash</a></h2>
<hr />
<p>These are type-safe wrappers around the <code>ByteArray</code> type that represent the hash of
a public key, validator script, minting policy or datum.</p>
<h3 id="associated-functions-9"><a class="header" href="#associated-functions-9">Associated Functions</a></h3>
<pre><code class="language-go  playpen">func new(bytes: ByteArray) -&gt; *Hash

func from_data(data: Data) -&gt; *Hash
</code></pre>
<h3 id="operators-12"><a class="header" href="#operators-12">Operators</a></h3>
<p><code>==</code>, <code>!=</code></p>
<h3 id="methods-13"><a class="header" href="#methods-13">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self) -&gt; ByteArray

func show(self) -&gt; String
</code></pre>
<h2 id="scriptcontext"><a class="header" href="#scriptcontext">ScriptContext</a></h2>
<hr />
<p>The <code>ScriptContext</code> type contains all the metadata related to a signed Cardano transaction.
It's just a wrapper around the <code>Tx</code> type with some extra methods.</p>
<pre><code class="language-go  noplaypen">// internal representation
struct ScriptContext {
    tx: Tx
	ScriptPurpose // not directly accessible
}
</code></pre>
<h3 id="associated-functions-10"><a class="header" href="#associated-functions-10">Associated functions</a></h3>
<pre><code class="language-rust  noplaypen">func from_data(data: Data) -&gt; ScriptContext
</code></pre>
<h3 id="operators-13"><a class="header" href="#operators-13">Operators</a></h3>
<p><code>==</code>, <code>!=</code></p>
<h3 id="methods-14"><a class="header" href="#methods-14">Methods</a></h3>
<pre><code class="language-go  noplaypen">// @returns The ScriptContext serialized into bytes.
func serialize(self) -&gt; ByteArray

// @notice only available in spending scripts
// @returns The TxOutputId of the current UTXO being spent
func get_spending_purpose_output_id(self) -&gt; TxOutputId

// @notice only available in spending scripts
// @returns the current UTXO being spent as TxInput
func get_current_input(self) -&gt; TxInput

// @notice only availabe in spending scripts
// @returns The ValidatorHash of the current script
func get_current_validator_hash(self) -&gt; ValidatorHash

// @notice only available in minting scripts
// @returns The MintingPolicyHash of the minting policy being evaluated.
func get_current_minting_policy_hash(self) -&gt; MintingPolicyHash

// @notice only available in staking scripts
// @returns the current staking sub-purpose (Rewarding or Certifying)
func get_staking_purpose(self) -&gt; StakingPurpose
</code></pre>
<h2 id="tx-1"><a class="header" href="#tx-1">Tx</a></h2>
<hr />
<p>This type stores the data related to a signed transaction.</p>
<pre><code class="language-rust  noplaypen">struct Tx {
    inputs: []TxInput            // Transactin Inputs
	ref_inputs: []TxInput        // Reference inputs (not spent)
    outputs: []TxOutput          // Transaction Outputs
    fee: Value                   // Fee paid for this transaction
    minted: Value                // Value minted by this transaction
	dcerts: []DCert              // Digests involved in this transaction
	withdrawals: Map[StakingCredential]Int // Staking withdrawals in this transaction
    time_range: TimeRange        // Valid Time Range of a transaction
    signatories: []PubKeyHash    // signatories of the transaction
    id: TxId                     // Transaction ID
}
</code></pre>
<h3 id="associated-functions-11"><a class="header" href="#associated-functions-11">Associated functions</a></h3>
<pre><code class="language-rust  noplaypen">func from_data(data: Data) -&gt; Tx
</code></pre>
<h3 id="operators-14"><a class="header" href="#operators-14">Operators</a></h3>
<p><code>==</code>, <code>!=</code></p>
<h3 id="methods-15"><a class="header" href="#methods-15">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self) -&gt; ByteArray

// @returns The current POSIX time.
// @notice Uses the start of 'self.time_range'. Throws an error if that start is negative or positive infinity.
// @notice Use cardano-cli's --invalid-before option to set the start time of the valid 'time_range' to something finite. 
func now(self) -&gt; Time; 

// @returns true if the transaction was signed by pubkeyhash.
func is_signed_by(self, pubkeyhash: PubKeyHash) -&gt; Bool

// @returns The Datum Hash of the UTXO guarded by the script.
func find_datum_hash(self) -&gt; ByteArray

// @returns The TxOutputs sent to a regular payment address.
func outputs_sent_to(self, pkh: PubKeyHash) -&gt; []TxOutput

func outputs_sent_to_datum(self, pkh: PubKeyHash, datum: Any) -&gt; []TxOutput

// @returns The TxOutputs locked by a script.
func outputs_locked_by(self, script_hash: ValidatorHash) -&gt; []TxOutput

func outputs_locked_by_datum(self, script_hash: ValidatorHash, datum: Any) -&gt; []TxOutput

// @returns The output Value sent to a regular payment address.
func value_sent_to(self, addr: PubKeyHash) -&gt; Value

func value_sent_to_datum(self, addr: PubKeyHash, datum: Any) -&gt; Value

// @returns The output Value locked by a script
func value_locked_by(self, script_hash: ValidatorHash) -&gt; Value

// @returns The output Value locked by a script with a certain datum.
func value_locked_by_datum(self, script_hash: ValidatorHash, datum: Any) -&gt; Value
</code></pre>
<h2 id="txid"><a class="header" href="#txid">TxId</a></h2>
<hr />
<p>This is a type-safe wrapper around the <code>ByteArray</code></p>
<pre><pre class="playground"><code class="language-rust  playpen"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TxId {...}
<span class="boring">}
</span></code></pre></pre>
<h3 id="associated-functions-12"><a class="header" href="#associated-functions-12">Associated functions</a></h3>
<pre><code class="language-rust  noplaypen">func new(bytes: ByteArray) -&gt; TxId

func from_data(data: Data) -&gt; TxId
</code></pre>
<h3 id="operators-15"><a class="header" href="#operators-15">Operators</a></h3>
<p><code>==</code>, <code>!=</code></p>
<h3 id="methods-16"><a class="header" href="#methods-16">Methods</a></h3>
<pre><code class="language-rust  noplaypen">func serialize(self) -&gt; ByteArray
</code></pre>
<h2 id="txinput-1"><a class="header" href="#txinput-1">TxInput</a></h2>
<hr />
<p>This type represents a <strong>Transaction Input</strong>.</p>
<pre><code class="language-rust  noplaypen">struct TxInput {
    output_id: TxOutputId
    output: TxOutput
}
</code></pre>
<h3 id="associated-functions-13"><a class="header" href="#associated-functions-13">Associated functions</a></h3>
<pre><code class="language-rust  noplaypen">func from_data(data: Data) -&gt; TxInput
</code></pre>
<h3 id="operators-16"><a class="header" href="#operators-16">Operators</a></h3>
<p><code>==</code>, <code>!=</code></p>
<h3 id="methods-17"><a class="header" href="#methods-17">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self) -&gt; ByteArray
</code></pre>
<h2 id="txoutput-1"><a class="header" href="#txoutput-1">TxOutput</a></h2>
<hr />
<p>This type represents a <strong>Transaction Output</strong>.</p>
<pre><code class="language-go  noplaypen">struct TxOutput {
    address: Address
    value: Value
    datum: OutputDatum
}
</code></pre>
<h3 id="associated-functions-14"><a class="header" href="#associated-functions-14">Associated functions</a></h3>
<pre><code class="language-rust  noplaypen">func from_data(data: Data) -&gt; TxOutput
</code></pre>
<h3 id="operators-17"><a class="header" href="#operators-17">Operators</a></h3>
<p><code>==</code>, <code>!=</code></p>
<h3 id="methods-18"><a class="header" href="#methods-18">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self) -&gt; ByteArray
</code></pre>
<h2 id="outputdatum"><a class="header" href="#outputdatum">OutputDatum</a></h2>
<pre><code class="language-rust  noplaypen">enum OutputDatum {
	None
	Hash{hash: DatumHash}
	Inline{data: Data}
}
</code></pre>
<h3 id="associated-functions-15"><a class="header" href="#associated-functions-15">Associated functions</a></h3>
<pre><code class="language-rust  noplaypen">func from_data(data: Data) -&gt; OutputDatum
</code></pre>
<h3 id="operators-18"><a class="header" href="#operators-18">Operators</a></h3>
<p><code>==</code>, <code>!=</code></p>
<h3 id="methods-19"><a class="header" href="#methods-19">Methods</a></h3>
<pre><code class="language-rust  noplaypen">func serialize(self) -&gt; ByteArray
</code></pre>
<h2 id="txoutputid"><a class="header" href="#txoutputid">TxOutputId</a></h2>
<hr />
<p>This type is a unique ID for a UTXO (Unspent Transaction Output).
It's composed of the <strong>Transaction ID</strong> (<code>TxId</code>) of the transaction that created the UTXO and the index (<code>Int</code>) of the UTXO in the outputs of that transaction.</p>
<pre><code class="language-go  noplaypen">struct TxOutputId {
    TxId // not directly accessible
    Int // not directly accessible
}
</code></pre>
<h3 id="associated-functions-16"><a class="header" href="#associated-functions-16">Associated Functions</a></h3>
<pre><code class="language-go  noplaypen">func new(tx_id: TxId, index: Int) -&gt; TxOutputId

func from_data(data: Data) -&gt; TxOutputId
</code></pre>
<h3 id="operators-19"><a class="header" href="#operators-19">Operators</a></h3>
<p><code>==</code>, <code>!=</code></p>
<h3 id="methods-20"><a class="header" href="#methods-20">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self) -&gt; ByteArray
</code></pre>
<h2 id="address"><a class="header" href="#address">Address</a></h2>
<hr />
<p>The <code>Address</code> type represents a cardano address.</p>
<pre><code class="language-rust  noplaypen">struct Address {
    credential: Credential
    staking_credential: Option[StakingCredential]
}
</code></pre>
<h3 id="associated-functions-17"><a class="header" href="#associated-functions-17">Associated functions</a></h3>
<pre><code class="language-rust  noplaypen">func new(credential: Credential, staking_credential: Option[StakingCredential]) -&gt; Address

func from_data(data: Data) -&gt; Address
</code></pre>
<h3 id="operators-20"><a class="header" href="#operators-20">Operators</a></h3>
<p><code>==</code>, <code>!=</code></p>
<h3 id="methods-21"><a class="header" href="#methods-21">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self: Address) -&gt; ByteArray
</code></pre>
<h2 id="credential"><a class="header" href="#credential">Credential</a></h2>
<hr />
<p>The <code>Credential</code> type represents the an onchain credential which can be a <code>PubKeyHash</code> or a <code>ValidatorHash</code></p>
<pre><code class="language-rust  noplaypen">enum Credential {
    Pubkey { hash: PubKeyHash }
    Validator { hash: ValidatorHash }
}
</code></pre>
<h3 id="associated-functions-18"><a class="header" href="#associated-functions-18">Associated functions</a></h3>
<pre><code class="language-rust  noplaypen">func new_pubkey(pkh: PubKeyHash) -&gt; Credential::PubKeyHash

func new_validator(vh: ValidatorHash) -&gt; Credential::ValidatorHash

func from_data(data: Data) -&gt; Credential
</code></pre>
<h3 id="operators-21"><a class="header" href="#operators-21">Operators</a></h3>
<p><code>==</code>, <code>!=</code></p>
<h3 id="methods-22"><a class="header" href="#methods-22">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self) -&gt; ByteArray
</code></pre>
<h3 id="operators-22"><a class="header" href="#operators-22">Operators</a></h3>
<p><code>==</code>, <code>!=</code></p>
<h2 id="stakingcredential"><a class="header" href="#stakingcredential">StakingCredential</a></h2>
<hr />
<pre><code class="language-rust  noplaypen">enum StakingCredential {
	Hash{Credential}
	Ptr{Int, Int, Int}
}
</code></pre>
<h3 id="associated-functions-19"><a class="header" href="#associated-functions-19">Associated functions</a></h3>
<pre><code class="language-rust  noplaypen">func new_hash(credential: Credential) -&gt; StakingCredential::Hash

func new_ptr(a: Int, b: Int, c: Int) -&gt; StakingCredential::Ptr

func from_data(data: Data) -&gt; StakingCredential
</code></pre>
<h3 id="operators-23"><a class="header" href="#operators-23">Operators</a></h3>
<p><code>==</code>, <code>!=</code></p>
<h3 id="methods-23"><a class="header" href="#methods-23">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self) -&gt; ByteArray
</code></pre>
<h2 id="stakingpurpose"><a class="header" href="#stakingpurpose">StakingPurpose</a></h2>
<pre><code class="language-rust  noplaypen">enum StakingPurpose {
	Rewarding{credential: StakingCredential}
	Certifying{dcert: DCert}
}
</code></pre>
<h3 id="associated-functions-20"><a class="header" href="#associated-functions-20">Associated functions</a></h3>
<pre><code class="language-rust  noplaypen">func from_data(data: Data) -&gt; StakingPurpose
</code></pre>
<h3 id="operators-24"><a class="header" href="#operators-24">Operators</a></h3>
<p><code>==</code>, <code>!=</code></p>
<h3 id="methods-24"><a class="header" href="#methods-24">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self) -&gt; ByteArray
</code></pre>
<h2 id="dcert"><a class="header" href="#dcert">DCert</a></h2>
<pre><code class="language-rust  noplaypen">enum DCert {
	Register{credential: StakingCredential}
	Deregister{credential: StakingCredential}
	Delegate{delegator: StakingCredential, pool_id: PubKeyHash}
	RegisterPool{pool_id: PubKeyHash, pool_vfr: PubKeyHash}
	RetirePool{pool_id: PubKeyHash, epoch: Int}
}
</code></pre>
<h3 id="associated-functions-21"><a class="header" href="#associated-functions-21">Associated functions</a></h3>
<pre><code class="language-rust  noplaypen">func from_data(data: Data) -&gt; DCert

func new_register(credential: StakingCredential) -&gt; DCert::Register

func new_deregister(credential: StakingCredential) -&gt; DCert::Deregister

func new_delegate(delegator: StakingCredential, pool_id: PubKeyHash) -&gt; DCert::Delegate

func new_register_pool(pool_id: PubKeyHash, pool_vfr: PubKeyHash) -&gt; DCert::RegisterPool

func new_retire_pool(pool_id: PubKeyHash, epoch: Int) -&gt; DCert::RetirePool
</code></pre>
<h3 id="operators-25"><a class="header" href="#operators-25">Operators</a></h3>
<p><code>==</code>, <code>!=</code></p>
<h3 id="methods-25"><a class="header" href="#methods-25">Methods</a></h3>
<pre><code class="language-rust  noplaypen">func serialize(self) -&gt; ByteArray
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
